var foundation = (function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var jquery = createCommonjsModule(function (module) {
	/*!
	 * jQuery JavaScript Library v3.5.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2020-05-04T22:49Z
	 */
	(function (global, factory) {

	  {
	    // For CommonJS and CommonJS-like environments where a proper `window`
	    // is present, execute the factory and get jQuery.
	    // For environments that do not have a `window` with a `document`
	    // (such as Node.js), expose a factory as module.exports.
	    // This accentuates the need for the creation of a real `window`.
	    // e.g. var jQuery = require("jquery")(window);
	    // See ticket #14549 for more info.
	    module.exports = global.document ? factory(global, true) : function (w) {
	      if (!w.document) {
	        throw new Error("jQuery requires a window with a document");
	      }

	      return factory(w);
	    };
	  } // Pass this if window is not defined yet

	})(typeof window !== "undefined" ? window : commonjsGlobal, function (window, noGlobal) {

	  var arr = [];
	  var getProto = Object.getPrototypeOf;
	  var slice = arr.slice;
	  var flat = arr.flat ? function (array) {
	    return arr.flat.call(array);
	  } : function (array) {
	    return arr.concat.apply([], array);
	  };
	  var push = arr.push;
	  var indexOf = arr.indexOf;
	  var class2type = {};
	  var toString = class2type.toString;
	  var hasOwn = class2type.hasOwnProperty;
	  var fnToString = hasOwn.toString;
	  var ObjectFunctionString = fnToString.call(Object);
	  var support = {};

	  var isFunction = function isFunction(obj) {
	    // Support: Chrome <=57, Firefox <=52
	    // In some browsers, typeof returns "function" for HTML <object> elements
	    // (i.e., `typeof document.createElement( "object" ) === "function"`).
	    // We don't want to classify *any* DOM node as a function.
	    return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };

	  var isWindow = function isWindow(obj) {
	    return obj != null && obj === obj.window;
	  };

	  var document = window.document;
	  var preservedScriptAttributes = {
	    type: true,
	    src: true,
	    nonce: true,
	    noModule: true
	  };

	  function DOMEval(code, node, doc) {
	    doc = doc || document;
	    var i,
	        val,
	        script = doc.createElement("script");
	    script.text = code;

	    if (node) {
	      for (i in preservedScriptAttributes) {
	        // Support: Firefox 64+, Edge 18+
	        // Some browsers don't support the "nonce" property on scripts.
	        // On the other hand, just using `getAttribute` is not enough as
	        // the `nonce` attribute is reset to an empty string whenever it
	        // becomes browsing-context connected.
	        // See https://github.com/whatwg/html/issues/2369
	        // See https://html.spec.whatwg.org/#nonce-attributes
	        // The `node.getAttribute` check was added for the sake of
	        // `jQuery.globalEval` so that it can fake a nonce-containing node
	        // via an object.
	        val = node[i] || node.getAttribute && node.getAttribute(i);

	        if (val) {
	          script.setAttribute(i, val);
	        }
	      }
	    }

	    doc.head.appendChild(script).parentNode.removeChild(script);
	  }

	  function toType(obj) {
	    if (obj == null) {
	      return obj + "";
	    } // Support: Android <=2.3 only (functionish RegExp)


	    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
	  }
	  /* global Symbol */
	  // Defining this global in .eslintrc.json would create a danger of using the global
	  // unguarded in another place, it seems safer to define global only for this module


	  var version = "3.5.1",
	      // Define a local copy of jQuery
	  jQuery = function (selector, context) {
	    // The jQuery object is actually just the init constructor 'enhanced'
	    // Need init if jQuery is called (just allow error to be thrown if not included)
	    return new jQuery.fn.init(selector, context);
	  };

	  jQuery.fn = jQuery.prototype = {
	    // The current version of jQuery being used
	    jquery: version,
	    constructor: jQuery,
	    // The default length of a jQuery object is 0
	    length: 0,
	    toArray: function () {
	      return slice.call(this);
	    },
	    // Get the Nth element in the matched element set OR
	    // Get the whole matched element set as a clean array
	    get: function (num) {
	      // Return all the elements in a clean array
	      if (num == null) {
	        return slice.call(this);
	      } // Return just the one element from the set


	      return num < 0 ? this[num + this.length] : this[num];
	    },
	    // Take an array of elements and push it onto the stack
	    // (returning the new matched element set)
	    pushStack: function (elems) {
	      // Build a new jQuery matched element set
	      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

	      ret.prevObject = this; // Return the newly-formed element set

	      return ret;
	    },
	    // Execute a callback for every element in the matched set.
	    each: function (callback) {
	      return jQuery.each(this, callback);
	    },
	    map: function (callback) {
	      return this.pushStack(jQuery.map(this, function (elem, i) {
	        return callback.call(elem, i, elem);
	      }));
	    },
	    slice: function () {
	      return this.pushStack(slice.apply(this, arguments));
	    },
	    first: function () {
	      return this.eq(0);
	    },
	    last: function () {
	      return this.eq(-1);
	    },
	    even: function () {
	      return this.pushStack(jQuery.grep(this, function (_elem, i) {
	        return (i + 1) % 2;
	      }));
	    },
	    odd: function () {
	      return this.pushStack(jQuery.grep(this, function (_elem, i) {
	        return i % 2;
	      }));
	    },
	    eq: function (i) {
	      var len = this.length,
	          j = +i + (i < 0 ? len : 0);
	      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
	    },
	    end: function () {
	      return this.prevObject || this.constructor();
	    },
	    // For internal use only.
	    // Behaves like an Array's method, not like a jQuery method.
	    push: push,
	    sort: arr.sort,
	    splice: arr.splice
	  };

	  jQuery.extend = jQuery.fn.extend = function () {
	    var options,
	        name,
	        src,
	        copy,
	        copyIsArray,
	        clone,
	        target = arguments[0] || {},
	        i = 1,
	        length = arguments.length,
	        deep = false; // Handle a deep copy situation

	    if (typeof target === "boolean") {
	      deep = target; // Skip the boolean and the target

	      target = arguments[i] || {};
	      i++;
	    } // Handle case when target is a string or something (possible in deep copy)


	    if (typeof target !== "object" && !isFunction(target)) {
	      target = {};
	    } // Extend jQuery itself if only one argument is passed


	    if (i === length) {
	      target = this;
	      i--;
	    }

	    for (; i < length; i++) {
	      // Only deal with non-null/undefined values
	      if ((options = arguments[i]) != null) {
	        // Extend the base object
	        for (name in options) {
	          copy = options[name]; // Prevent Object.prototype pollution
	          // Prevent never-ending loop

	          if (name === "__proto__" || target === copy) {
	            continue;
	          } // Recurse if we're merging plain objects or arrays


	          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
	            src = target[name]; // Ensure proper type for the source value

	            if (copyIsArray && !Array.isArray(src)) {
	              clone = [];
	            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
	              clone = {};
	            } else {
	              clone = src;
	            }

	            copyIsArray = false; // Never move original objects, clone them

	            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
	          } else if (copy !== undefined) {
	            target[name] = copy;
	          }
	        }
	      }
	    } // Return the modified object


	    return target;
	  };

	  jQuery.extend({
	    // Unique for each copy of jQuery on the page
	    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
	    // Assume jQuery is ready without the ready module
	    isReady: true,
	    error: function (msg) {
	      throw new Error(msg);
	    },
	    noop: function () {},
	    isPlainObject: function (obj) {
	      var proto, Ctor; // Detect obvious negatives
	      // Use toString instead of jQuery.type to catch host objects

	      if (!obj || toString.call(obj) !== "[object Object]") {
	        return false;
	      }

	      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

	      if (!proto) {
	        return true;
	      } // Objects with prototype are plain iff they were constructed by a global Object function


	      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
	      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
	    },
	    isEmptyObject: function (obj) {
	      var name;

	      for (name in obj) {
	        return false;
	      }

	      return true;
	    },
	    // Evaluates a script in a provided context; falls back to the global one
	    // if not specified.
	    globalEval: function (code, options, doc) {
	      DOMEval(code, {
	        nonce: options && options.nonce
	      }, doc);
	    },
	    each: function (obj, callback) {
	      var length,
	          i = 0;

	      if (isArrayLike(obj)) {
	        length = obj.length;

	        for (; i < length; i++) {
	          if (callback.call(obj[i], i, obj[i]) === false) {
	            break;
	          }
	        }
	      } else {
	        for (i in obj) {
	          if (callback.call(obj[i], i, obj[i]) === false) {
	            break;
	          }
	        }
	      }

	      return obj;
	    },
	    // results is for internal usage only
	    makeArray: function (arr, results) {
	      var ret = results || [];

	      if (arr != null) {
	        if (isArrayLike(Object(arr))) {
	          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
	        } else {
	          push.call(ret, arr);
	        }
	      }

	      return ret;
	    },
	    inArray: function (elem, arr, i) {
	      return arr == null ? -1 : indexOf.call(arr, elem, i);
	    },
	    // Support: Android <=4.0 only, PhantomJS 1 only
	    // push.apply(_, arraylike) throws on ancient WebKit
	    merge: function (first, second) {
	      var len = +second.length,
	          j = 0,
	          i = first.length;

	      for (; j < len; j++) {
	        first[i++] = second[j];
	      }

	      first.length = i;
	      return first;
	    },
	    grep: function (elems, callback, invert) {
	      var callbackInverse,
	          matches = [],
	          i = 0,
	          length = elems.length,
	          callbackExpect = !invert; // Go through the array, only saving the items
	      // that pass the validator function

	      for (; i < length; i++) {
	        callbackInverse = !callback(elems[i], i);

	        if (callbackInverse !== callbackExpect) {
	          matches.push(elems[i]);
	        }
	      }

	      return matches;
	    },
	    // arg is for internal usage only
	    map: function (elems, callback, arg) {
	      var length,
	          value,
	          i = 0,
	          ret = []; // Go through the array, translating each of the items to their new values

	      if (isArrayLike(elems)) {
	        length = elems.length;

	        for (; i < length; i++) {
	          value = callback(elems[i], i, arg);

	          if (value != null) {
	            ret.push(value);
	          }
	        } // Go through every key on the object,

	      } else {
	        for (i in elems) {
	          value = callback(elems[i], i, arg);

	          if (value != null) {
	            ret.push(value);
	          }
	        }
	      } // Flatten any nested arrays


	      return flat(ret);
	    },
	    // A global GUID counter for objects
	    guid: 1,
	    // jQuery.support is not used in Core but other projects attach their
	    // properties to it so it needs to exist.
	    support: support
	  });

	  if (typeof Symbol === "function") {
	    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	  } // Populate the class2type map


	  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
	    class2type["[object " + name + "]"] = name.toLowerCase();
	  });

	  function isArrayLike(obj) {
	    // Support: real iOS 8.2 only (not reproducible in simulator)
	    // `in` check used to prevent JIT error (gh-2145)
	    // hasOwn isn't used here due to false negatives
	    // regarding Nodelist length in IE
	    var length = !!obj && "length" in obj && obj.length,
	        type = toType(obj);

	    if (isFunction(obj) || isWindow(obj)) {
	      return false;
	    }

	    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	  }

	  var Sizzle =
	  /*!
	   * Sizzle CSS Selector Engine v2.3.5
	   * https://sizzlejs.com/
	   *
	   * Copyright JS Foundation and other contributors
	   * Released under the MIT license
	   * https://js.foundation/
	   *
	   * Date: 2020-03-14
	   */
	  function (window) {
	    var i,
	        support,
	        Expr,
	        getText,
	        isXML,
	        tokenize,
	        compile,
	        select,
	        outermostContext,
	        sortInput,
	        hasDuplicate,
	        // Local document vars
	    setDocument,
	        document,
	        docElem,
	        documentIsHTML,
	        rbuggyQSA,
	        rbuggyMatches,
	        matches,
	        contains,
	        // Instance-specific data
	    expando = "sizzle" + 1 * new Date(),
	        preferredDoc = window.document,
	        dirruns = 0,
	        done = 0,
	        classCache = createCache(),
	        tokenCache = createCache(),
	        compilerCache = createCache(),
	        nonnativeSelectorCache = createCache(),
	        sortOrder = function (a, b) {
	      if (a === b) {
	        hasDuplicate = true;
	      }

	      return 0;
	    },
	        // Instance methods
	    hasOwn = {}.hasOwnProperty,
	        arr = [],
	        pop = arr.pop,
	        pushNative = arr.push,
	        push = arr.push,
	        slice = arr.slice,
	        // Use a stripped-down indexOf as it's faster than native
	    // https://jsperf.com/thor-indexof-vs-for/5
	    indexOf = function (list, elem) {
	      var i = 0,
	          len = list.length;

	      for (; i < len; i++) {
	        if (list[i] === elem) {
	          return i;
	        }
	      }

	      return -1;
	    },
	        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
	        // Regular expressions
	    // http://www.w3.org/TR/css3-selectors/#whitespace
	    whitespace = "[\\x20\\t\\r\\n\\f]",
	        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
	        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
	    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
	    // or strings [capture 3 or capture 4]"
	    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
	        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	    // 1. quoted (capture 3; capture 4 or capture 5)
	    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
	    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
	    ".*" + ")\\)|)",
	        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	    rwhitespace = new RegExp(whitespace + "+", "g"),
	        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
	        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
	        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
	        rdescend = new RegExp(whitespace + "|>"),
	        rpseudo = new RegExp(pseudos),
	        ridentifier = new RegExp("^" + identifier + "$"),
	        matchExpr = {
	      "ID": new RegExp("^#(" + identifier + ")"),
	      "CLASS": new RegExp("^\\.(" + identifier + ")"),
	      "TAG": new RegExp("^(" + identifier + "|[*])"),
	      "ATTR": new RegExp("^" + attributes),
	      "PSEUDO": new RegExp("^" + pseudos),
	      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
	      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
	      // For use in libraries implementing .is()
	      // We use this for POS matching in `select`
	      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
	    },
	        rhtml = /HTML$/i,
	        rinputs = /^(?:input|select|textarea|button)$/i,
	        rheader = /^h\d$/i,
	        rnative = /^[^{]+\{\s*\[native \w/,
	        // Easily-parseable/retrievable ID or TAG or CLASS selectors
	    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	        rsibling = /[+~]/,
	        // CSS escapes
	    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
	        funescape = function (escape, nonHex) {
	      var high = "0x" + escape.slice(1) - 0x10000;
	      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
	      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
	      // Support: IE <=11+
	      // For values outside the Basic Multilingual Plane (BMP), manually construct a
	      // surrogate pair
	      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
	    },
	        // CSS string/identifier serialization
	    // https://drafts.csswg.org/cssom/#common-serializing-idioms
	    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	        fcssescape = function (ch, asCodePoint) {
	      if (asCodePoint) {
	        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
	        if (ch === "\0") {
	          return "\uFFFD";
	        } // Control characters and (dependent upon position) numbers get escaped as code points


	        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
	      } // Other potentially-special ASCII characters get backslash-escaped


	      return "\\" + ch;
	    },
	        // Used for iframes
	    // See setDocument()
	    // Removing the function wrapper causes a "Permission Denied"
	    // error in IE
	    unloadHandler = function () {
	      setDocument();
	    },
	        inDisabledFieldset = addCombinator(function (elem) {
	      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
	    }, {
	      dir: "parentNode",
	      next: "legend"
	    }); // Optimize for push.apply( _, NodeList )


	    try {
	      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
	      // Detect silently failing push.apply
	      // eslint-disable-next-line no-unused-expressions

	      arr[preferredDoc.childNodes.length].nodeType;
	    } catch (e) {
	      push = {
	        apply: arr.length ? // Leverage slice if possible
	        function (target, els) {
	          pushNative.apply(target, slice.call(els));
	        } : // Support: IE<9
	        // Otherwise append directly
	        function (target, els) {
	          var j = target.length,
	              i = 0; // Can't trust NodeList.length

	          while (target[j++] = els[i++]) {}

	          target.length = j - 1;
	        }
	      };
	    }

	    function Sizzle(selector, context, results, seed) {
	      var m,
	          i,
	          elem,
	          nid,
	          match,
	          groups,
	          newSelector,
	          newContext = context && context.ownerDocument,
	          // nodeType defaults to 9, since context defaults to document
	      nodeType = context ? context.nodeType : 9;
	      results = results || []; // Return early from calls with invalid selector or context

	      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
	        return results;
	      } // Try to shortcut find operations (as opposed to filters) in HTML documents


	      if (!seed) {
	        setDocument(context);
	        context = context || document;

	        if (documentIsHTML) {
	          // If the selector is sufficiently simple, try using a "get*By*" DOM method
	          // (excepting DocumentFragment context, where the methods don't exist)
	          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
	            // ID selector
	            if (m = match[1]) {
	              // Document context
	              if (nodeType === 9) {
	                if (elem = context.getElementById(m)) {
	                  // Support: IE, Opera, Webkit
	                  // TODO: identify versions
	                  // getElementById can match elements by name instead of ID
	                  if (elem.id === m) {
	                    results.push(elem);
	                    return results;
	                  }
	                } else {
	                  return results;
	                } // Element context

	              } else {
	                // Support: IE, Opera, Webkit
	                // TODO: identify versions
	                // getElementById can match elements by name instead of ID
	                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
	                  results.push(elem);
	                  return results;
	                }
	              } // Type selector

	            } else if (match[2]) {
	              push.apply(results, context.getElementsByTagName(selector));
	              return results; // Class selector
	            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
	              push.apply(results, context.getElementsByClassName(m));
	              return results;
	            }
	          } // Take advantage of querySelectorAll


	          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
	          // Exclude object elements
	          nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
	            newSelector = selector;
	            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
	            // descendant combinators, which is not what we want.
	            // In such cases, we work around the behavior by prefixing every selector in the
	            // list with an ID selector referencing the scope context.
	            // The technique has to be used as well when a leading combinator is used
	            // as such selectors are not recognized by querySelectorAll.
	            // Thanks to Andrew Dupont for this technique.

	            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
	              // Expand context for sibling selectors
	              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
	              // supports it & if we're not changing the context.

	              if (newContext !== context || !support.scope) {
	                // Capture the context ID, setting it first if necessary
	                if (nid = context.getAttribute("id")) {
	                  nid = nid.replace(rcssescape, fcssescape);
	                } else {
	                  context.setAttribute("id", nid = expando);
	                }
	              } // Prefix every selector in the list


	              groups = tokenize(selector);
	              i = groups.length;

	              while (i--) {
	                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
	              }

	              newSelector = groups.join(",");
	            }

	            try {
	              push.apply(results, newContext.querySelectorAll(newSelector));
	              return results;
	            } catch (qsaError) {
	              nonnativeSelectorCache(selector, true);
	            } finally {
	              if (nid === expando) {
	                context.removeAttribute("id");
	              }
	            }
	          }
	        }
	      } // All others


	      return select(selector.replace(rtrim, "$1"), context, results, seed);
	    }
	    /**
	     * Create key-value caches of limited size
	     * @returns {function(string, object)} Returns the Object data after storing it on itself with
	     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	     *	deleting the oldest entry
	     */


	    function createCache() {
	      var keys = [];

	      function cache(key, value) {
	        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
	        if (keys.push(key + " ") > Expr.cacheLength) {
	          // Only keep the most recent entries
	          delete cache[keys.shift()];
	        }

	        return cache[key + " "] = value;
	      }

	      return cache;
	    }
	    /**
	     * Mark a function for special use by Sizzle
	     * @param {Function} fn The function to mark
	     */


	    function markFunction(fn) {
	      fn[expando] = true;
	      return fn;
	    }
	    /**
	     * Support testing using an element
	     * @param {Function} fn Passed the created element and returns a boolean result
	     */


	    function assert(fn) {
	      var el = document.createElement("fieldset");

	      try {
	        return !!fn(el);
	      } catch (e) {
	        return false;
	      } finally {
	        // Remove from its parent by default
	        if (el.parentNode) {
	          el.parentNode.removeChild(el);
	        } // release memory in IE


	        el = null;
	      }
	    }
	    /**
	     * Adds the same handler for all of the specified attrs
	     * @param {String} attrs Pipe-separated list of attributes
	     * @param {Function} handler The method that will be applied
	     */


	    function addHandle(attrs, handler) {
	      var arr = attrs.split("|"),
	          i = arr.length;

	      while (i--) {
	        Expr.attrHandle[arr[i]] = handler;
	      }
	    }
	    /**
	     * Checks document order of two siblings
	     * @param {Element} a
	     * @param {Element} b
	     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	     */


	    function siblingCheck(a, b) {
	      var cur = b && a,
	          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

	      if (diff) {
	        return diff;
	      } // Check if b follows a


	      if (cur) {
	        while (cur = cur.nextSibling) {
	          if (cur === b) {
	            return -1;
	          }
	        }
	      }

	      return a ? 1 : -1;
	    }
	    /**
	     * Returns a function to use in pseudos for input types
	     * @param {String} type
	     */


	    function createInputPseudo(type) {
	      return function (elem) {
	        var name = elem.nodeName.toLowerCase();
	        return name === "input" && elem.type === type;
	      };
	    }
	    /**
	     * Returns a function to use in pseudos for buttons
	     * @param {String} type
	     */


	    function createButtonPseudo(type) {
	      return function (elem) {
	        var name = elem.nodeName.toLowerCase();
	        return (name === "input" || name === "button") && elem.type === type;
	      };
	    }
	    /**
	     * Returns a function to use in pseudos for :enabled/:disabled
	     * @param {Boolean} disabled true for :disabled; false for :enabled
	     */


	    function createDisabledPseudo(disabled) {
	      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	      return function (elem) {
	        // Only certain elements can match :enabled or :disabled
	        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
	        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
	        if ("form" in elem) {
	          // Check for inherited disabledness on relevant non-disabled elements:
	          // * listed form-associated elements in a disabled fieldset
	          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
	          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
	          // * option elements in a disabled optgroup
	          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
	          // All such elements have a "form" property.
	          if (elem.parentNode && elem.disabled === false) {
	            // Option elements defer to a parent optgroup if present
	            if ("label" in elem) {
	              if ("label" in elem.parentNode) {
	                return elem.parentNode.disabled === disabled;
	              } else {
	                return elem.disabled === disabled;
	              }
	            } // Support: IE 6 - 11
	            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


	            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

	            /* jshint -W018 */
	            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
	          }

	          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
	          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
	          // even exist on them, let alone have a boolean value.
	        } else if ("label" in elem) {
	          return elem.disabled === disabled;
	        } // Remaining elements are neither :enabled nor :disabled


	        return false;
	      };
	    }
	    /**
	     * Returns a function to use in pseudos for positionals
	     * @param {Function} fn
	     */


	    function createPositionalPseudo(fn) {
	      return markFunction(function (argument) {
	        argument = +argument;
	        return markFunction(function (seed, matches) {
	          var j,
	              matchIndexes = fn([], seed.length, argument),
	              i = matchIndexes.length; // Match elements found at the specified indexes

	          while (i--) {
	            if (seed[j = matchIndexes[i]]) {
	              seed[j] = !(matches[j] = seed[j]);
	            }
	          }
	        });
	      });
	    }
	    /**
	     * Checks a node for validity as a Sizzle context
	     * @param {Element|Object=} context
	     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	     */


	    function testContext(context) {
	      return context && typeof context.getElementsByTagName !== "undefined" && context;
	    } // Expose support vars for convenience


	    support = Sizzle.support = {};
	    /**
	     * Detects XML nodes
	     * @param {Element|Object} elem An element or a document
	     * @returns {Boolean} True iff elem is a non-HTML XML node
	     */

	    isXML = Sizzle.isXML = function (elem) {
	      var namespace = elem.namespaceURI,
	          docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8
	      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	      // https://bugs.jquery.com/ticket/4833

	      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
	    };
	    /**
	     * Sets document-related variables once based on the current document
	     * @param {Element|Object} [doc] An element or document object to use to set the document
	     * @returns {Object} Returns the current document
	     */


	    setDocument = Sizzle.setDocument = function (node) {
	      var hasCompare,
	          subWindow,
	          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
	      // Support: IE 11+, Edge 17 - 18+
	      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	      // two documents; shallow comparisons work.
	      // eslint-disable-next-line eqeqeq

	      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
	        return document;
	      } // Update global variables


	      document = doc;
	      docElem = document.documentElement;
	      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
	      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	      // Support: IE 11+, Edge 17 - 18+
	      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	      // two documents; shallow comparisons work.
	      // eslint-disable-next-line eqeqeq

	      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
	        // Support: IE 11, Edge
	        if (subWindow.addEventListener) {
	          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
	        } else if (subWindow.attachEvent) {
	          subWindow.attachEvent("onunload", unloadHandler);
	        }
	      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
	      // IE/Edge & older browsers don't support the :scope pseudo-class.
	      // Support: Safari 6.0 only
	      // Safari 6.0 supports :scope but it's an alias of :root there.


	      support.scope = assert(function (el) {
	        docElem.appendChild(el).appendChild(document.createElement("div"));
	        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
	      });
	      /* Attributes
	      ---------------------------------------------------------------------- */
	      // Support: IE<8
	      // Verify that getAttribute really returns attributes and not properties
	      // (excepting IE8 booleans)

	      support.attributes = assert(function (el) {
	        el.className = "i";
	        return !el.getAttribute("className");
	      });
	      /* getElement(s)By*
	      ---------------------------------------------------------------------- */
	      // Check if getElementsByTagName("*") returns only elements

	      support.getElementsByTagName = assert(function (el) {
	        el.appendChild(document.createComment(""));
	        return !el.getElementsByTagName("*").length;
	      }); // Support: IE<9

	      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
	      // Check if getElementById returns elements by name
	      // The broken getElementById methods don't pick up programmatically-set names,
	      // so use a roundabout getElementsByName test

	      support.getById = assert(function (el) {
	        docElem.appendChild(el).id = expando;
	        return !document.getElementsByName || !document.getElementsByName(expando).length;
	      }); // ID filter and find

	      if (support.getById) {
	        Expr.filter["ID"] = function (id) {
	          var attrId = id.replace(runescape, funescape);
	          return function (elem) {
	            return elem.getAttribute("id") === attrId;
	          };
	        };

	        Expr.find["ID"] = function (id, context) {
	          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
	            var elem = context.getElementById(id);
	            return elem ? [elem] : [];
	          }
	        };
	      } else {
	        Expr.filter["ID"] = function (id) {
	          var attrId = id.replace(runescape, funescape);
	          return function (elem) {
	            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
	            return node && node.value === attrId;
	          };
	        }; // Support: IE 6 - 7 only
	        // getElementById is not reliable as a find shortcut


	        Expr.find["ID"] = function (id, context) {
	          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
	            var node,
	                i,
	                elems,
	                elem = context.getElementById(id);

	            if (elem) {
	              // Verify the id attribute
	              node = elem.getAttributeNode("id");

	              if (node && node.value === id) {
	                return [elem];
	              } // Fall back on getElementsByName


	              elems = context.getElementsByName(id);
	              i = 0;

	              while (elem = elems[i++]) {
	                node = elem.getAttributeNode("id");

	                if (node && node.value === id) {
	                  return [elem];
	                }
	              }
	            }

	            return [];
	          }
	        };
	      } // Tag


	      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
	        if (typeof context.getElementsByTagName !== "undefined") {
	          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
	        } else if (support.qsa) {
	          return context.querySelectorAll(tag);
	        }
	      } : function (tag, context) {
	        var elem,
	            tmp = [],
	            i = 0,
	            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
	        results = context.getElementsByTagName(tag); // Filter out possible comments

	        if (tag === "*") {
	          while (elem = results[i++]) {
	            if (elem.nodeType === 1) {
	              tmp.push(elem);
	            }
	          }

	          return tmp;
	        }

	        return results;
	      }; // Class

	      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
	        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
	          return context.getElementsByClassName(className);
	        }
	      };
	      /* QSA/matchesSelector
	      ---------------------------------------------------------------------- */
	      // QSA and matchesSelector support
	      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


	      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
	      // We allow this because of a bug in IE8/9 that throws an error
	      // whenever `document.activeElement` is accessed on an iframe
	      // So, we allow :focus to pass through QSA all the time to avoid the IE error
	      // See https://bugs.jquery.com/ticket/13378

	      rbuggyQSA = [];

	      if (support.qsa = rnative.test(document.querySelectorAll)) {
	        // Build QSA regex
	        // Regex strategy adopted from Diego Perini
	        assert(function (el) {
	          var input; // Select is set to empty string on purpose
	          // This is to test IE's treatment of not explicitly
	          // setting a boolean content attribute,
	          // since its presence should be enough
	          // https://bugs.jquery.com/ticket/12359

	          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
	          // Nothing should be selected when empty strings follow ^= or $= or *=
	          // The test attribute must be unknown in Opera but "safe" for WinRT
	          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

	          if (el.querySelectorAll("[msallowcapture^='']").length) {
	            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
	          } // Support: IE8
	          // Boolean attributes and "value" are not treated correctly


	          if (!el.querySelectorAll("[selected]").length) {
	            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
	          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


	          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
	            rbuggyQSA.push("~=");
	          } // Support: IE 11+, Edge 15 - 18+
	          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
	          // Adding a temporary attribute to the document before the selection works
	          // around the issue.
	          // Interestingly, IE 10 & older don't seem to have the issue.


	          input = document.createElement("input");
	          input.setAttribute("name", "");
	          el.appendChild(input);

	          if (!el.querySelectorAll("[name='']").length) {
	            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
	          } // Webkit/Opera - :checked should return selected option elements
	          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	          // IE8 throws error here and will not see later tests


	          if (!el.querySelectorAll(":checked").length) {
	            rbuggyQSA.push(":checked");
	          } // Support: Safari 8+, iOS 8+
	          // https://bugs.webkit.org/show_bug.cgi?id=136851
	          // In-page `selector#id sibling-combinator selector` fails


	          if (!el.querySelectorAll("a#" + expando + "+*").length) {
	            rbuggyQSA.push(".#.+[+~]");
	          } // Support: Firefox <=3.6 - 5 only
	          // Old Firefox doesn't throw on a badly-escaped identifier.


	          el.querySelectorAll("\\\f");
	          rbuggyQSA.push("[\\r\\n\\f]");
	        });
	        assert(function (el) {
	          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
	          // The type and name attributes are restricted during .innerHTML assignment

	          var input = document.createElement("input");
	          input.setAttribute("type", "hidden");
	          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
	          // Enforce case-sensitivity of name attribute

	          if (el.querySelectorAll("[name=d]").length) {
	            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
	          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	          // IE8 throws error here and will not see later tests


	          if (el.querySelectorAll(":enabled").length !== 2) {
	            rbuggyQSA.push(":enabled", ":disabled");
	          } // Support: IE9-11+
	          // IE's :disabled selector does not pick up the children of disabled fieldsets


	          docElem.appendChild(el).disabled = true;

	          if (el.querySelectorAll(":disabled").length !== 2) {
	            rbuggyQSA.push(":enabled", ":disabled");
	          } // Support: Opera 10 - 11 only
	          // Opera 10-11 does not throw on post-comma invalid pseudos


	          el.querySelectorAll("*,:x");
	          rbuggyQSA.push(",.*:");
	        });
	      }

	      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
	        assert(function (el) {
	          // Check to see if it's possible to do matchesSelector
	          // on a disconnected node (IE 9)
	          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
	          // Gecko does not error, returns false instead

	          matches.call(el, "[s!='']:x");
	          rbuggyMatches.push("!=", pseudos);
	        });
	      }

	      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
	      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
	      /* Contains
	      ---------------------------------------------------------------------- */

	      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
	      // Purposefully self-exclusive
	      // As in, an element does not contain itself

	      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
	        var adown = a.nodeType === 9 ? a.documentElement : a,
	            bup = b && b.parentNode;
	        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
	      } : function (a, b) {
	        if (b) {
	          while (b = b.parentNode) {
	            if (b === a) {
	              return true;
	            }
	          }
	        }

	        return false;
	      };
	      /* Sorting
	      ---------------------------------------------------------------------- */
	      // Document order sorting

	      sortOrder = hasCompare ? function (a, b) {
	        // Flag for duplicate removal
	        if (a === b) {
	          hasDuplicate = true;
	          return 0;
	        } // Sort on method existence if only one input has compareDocumentPosition


	        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

	        if (compare) {
	          return compare;
	        } // Calculate position if both inputs belong to the same document
	        // Support: IE 11+, Edge 17 - 18+
	        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	        // two documents; shallow comparisons work.
	        // eslint-disable-next-line eqeqeq


	        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
	        1; // Disconnected nodes

	        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
	          // Choose the first element that is related to our preferred document
	          // Support: IE 11+, Edge 17 - 18+
	          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	          // two documents; shallow comparisons work.
	          // eslint-disable-next-line eqeqeq
	          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
	            return -1;
	          } // Support: IE 11+, Edge 17 - 18+
	          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	          // two documents; shallow comparisons work.
	          // eslint-disable-next-line eqeqeq


	          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
	            return 1;
	          } // Maintain original order


	          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
	        }

	        return compare & 4 ? -1 : 1;
	      } : function (a, b) {
	        // Exit early if the nodes are identical
	        if (a === b) {
	          hasDuplicate = true;
	          return 0;
	        }

	        var cur,
	            i = 0,
	            aup = a.parentNode,
	            bup = b.parentNode,
	            ap = [a],
	            bp = [b]; // Parentless nodes are either documents or disconnected

	        if (!aup || !bup) {
	          // Support: IE 11+, Edge 17 - 18+
	          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	          // two documents; shallow comparisons work.

	          /* eslint-disable eqeqeq */
	          return a == document ? -1 : b == document ? 1 :
	          /* eslint-enable eqeqeq */
	          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
	        } else if (aup === bup) {
	          return siblingCheck(a, b);
	        } // Otherwise we need full lists of their ancestors for comparison


	        cur = a;

	        while (cur = cur.parentNode) {
	          ap.unshift(cur);
	        }

	        cur = b;

	        while (cur = cur.parentNode) {
	          bp.unshift(cur);
	        } // Walk down the tree looking for a discrepancy


	        while (ap[i] === bp[i]) {
	          i++;
	        }

	        return i ? // Do a sibling check if the nodes have a common ancestor
	        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
	        // Support: IE 11+, Edge 17 - 18+
	        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	        // two documents; shallow comparisons work.

	        /* eslint-disable eqeqeq */
	        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
	        /* eslint-enable eqeqeq */
	        0;
	      };
	      return document;
	    };

	    Sizzle.matches = function (expr, elements) {
	      return Sizzle(expr, null, null, elements);
	    };

	    Sizzle.matchesSelector = function (elem, expr) {
	      setDocument(elem);

	      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
	        try {
	          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

	          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
	          // fragment in IE 9
	          elem.document && elem.document.nodeType !== 11) {
	            return ret;
	          }
	        } catch (e) {
	          nonnativeSelectorCache(expr, true);
	        }
	      }

	      return Sizzle(expr, document, null, [elem]).length > 0;
	    };

	    Sizzle.contains = function (context, elem) {
	      // Set document vars if needed
	      // Support: IE 11+, Edge 17 - 18+
	      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	      // two documents; shallow comparisons work.
	      // eslint-disable-next-line eqeqeq
	      if ((context.ownerDocument || context) != document) {
	        setDocument(context);
	      }

	      return contains(context, elem);
	    };

	    Sizzle.attr = function (elem, name) {
	      // Set document vars if needed
	      // Support: IE 11+, Edge 17 - 18+
	      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	      // two documents; shallow comparisons work.
	      // eslint-disable-next-line eqeqeq
	      if ((elem.ownerDocument || elem) != document) {
	        setDocument(elem);
	      }

	      var fn = Expr.attrHandle[name.toLowerCase()],
	          // Don't get fooled by Object.prototype properties (jQuery #13807)
	      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
	      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	    };

	    Sizzle.escape = function (sel) {
	      return (sel + "").replace(rcssescape, fcssescape);
	    };

	    Sizzle.error = function (msg) {
	      throw new Error("Syntax error, unrecognized expression: " + msg);
	    };
	    /**
	     * Document sorting and removing duplicates
	     * @param {ArrayLike} results
	     */


	    Sizzle.uniqueSort = function (results) {
	      var elem,
	          duplicates = [],
	          j = 0,
	          i = 0; // Unless we *know* we can detect duplicates, assume their presence

	      hasDuplicate = !support.detectDuplicates;
	      sortInput = !support.sortStable && results.slice(0);
	      results.sort(sortOrder);

	      if (hasDuplicate) {
	        while (elem = results[i++]) {
	          if (elem === results[i]) {
	            j = duplicates.push(i);
	          }
	        }

	        while (j--) {
	          results.splice(duplicates[j], 1);
	        }
	      } // Clear input after sorting to release objects
	      // See https://github.com/jquery/sizzle/pull/225


	      sortInput = null;
	      return results;
	    };
	    /**
	     * Utility function for retrieving the text value of an array of DOM nodes
	     * @param {Array|Element} elem
	     */


	    getText = Sizzle.getText = function (elem) {
	      var node,
	          ret = "",
	          i = 0,
	          nodeType = elem.nodeType;

	      if (!nodeType) {
	        // If no nodeType, this is expected to be an array
	        while (node = elem[i++]) {
	          // Do not traverse comment nodes
	          ret += getText(node);
	        }
	      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
	        // Use textContent for elements
	        // innerText usage removed for consistency of new lines (jQuery #11153)
	        if (typeof elem.textContent === "string") {
	          return elem.textContent;
	        } else {
	          // Traverse its children
	          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	            ret += getText(elem);
	          }
	        }
	      } else if (nodeType === 3 || nodeType === 4) {
	        return elem.nodeValue;
	      } // Do not include comment or processing instruction nodes


	      return ret;
	    };

	    Expr = Sizzle.selectors = {
	      // Can be adjusted by the user
	      cacheLength: 50,
	      createPseudo: markFunction,
	      match: matchExpr,
	      attrHandle: {},
	      find: {},
	      relative: {
	        ">": {
	          dir: "parentNode",
	          first: true
	        },
	        " ": {
	          dir: "parentNode"
	        },
	        "+": {
	          dir: "previousSibling",
	          first: true
	        },
	        "~": {
	          dir: "previousSibling"
	        }
	      },
	      preFilter: {
	        "ATTR": function (match) {
	          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

	          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

	          if (match[2] === "~=") {
	            match[3] = " " + match[3] + " ";
	          }

	          return match.slice(0, 4);
	        },
	        "CHILD": function (match) {
	          /* matches from matchExpr["CHILD"]
	          	1 type (only|nth|...)
	          	2 what (child|of-type)
	          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	          	4 xn-component of xn+y argument ([+-]?\d*n|)
	          	5 sign of xn-component
	          	6 x of xn-component
	          	7 sign of y-component
	          	8 y of y-component
	          */
	          match[1] = match[1].toLowerCase();

	          if (match[1].slice(0, 3) === "nth") {
	            // nth-* requires argument
	            if (!match[3]) {
	              Sizzle.error(match[0]);
	            } // numeric x and y parameters for Expr.filter.CHILD
	            // remember that false/true cast respectively to 0/1


	            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
	            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
	          } else if (match[3]) {
	            Sizzle.error(match[0]);
	          }

	          return match;
	        },
	        "PSEUDO": function (match) {
	          var excess,
	              unquoted = !match[6] && match[2];

	          if (matchExpr["CHILD"].test(match[0])) {
	            return null;
	          } // Accept quoted arguments as-is


	          if (match[3]) {
	            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
	          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
	          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
	          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
	            // excess is a negative index
	            match[0] = match[0].slice(0, excess);
	            match[2] = unquoted.slice(0, excess);
	          } // Return only captures needed by the pseudo filter method (type and argument)


	          return match.slice(0, 3);
	        }
	      },
	      filter: {
	        "TAG": function (nodeNameSelector) {
	          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
	          return nodeNameSelector === "*" ? function () {
	            return true;
	          } : function (elem) {
	            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	          };
	        },
	        "CLASS": function (className) {
	          var pattern = classCache[className + " "];
	          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
	            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
	          });
	        },
	        "ATTR": function (name, operator, check) {
	          return function (elem) {
	            var result = Sizzle.attr(elem, name);

	            if (result == null) {
	              return operator === "!=";
	            }

	            if (!operator) {
	              return true;
	            }

	            result += "";
	            /* eslint-disable max-len */

	            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
	            /* eslint-enable max-len */
	          };
	        },
	        "CHILD": function (type, what, _argument, first, last) {
	          var simple = type.slice(0, 3) !== "nth",
	              forward = type.slice(-4) !== "last",
	              ofType = what === "of-type";
	          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
	          function (elem) {
	            return !!elem.parentNode;
	          } : function (elem, _context, xml) {
	            var cache,
	                uniqueCache,
	                outerCache,
	                node,
	                nodeIndex,
	                start,
	                dir = simple !== forward ? "nextSibling" : "previousSibling",
	                parent = elem.parentNode,
	                name = ofType && elem.nodeName.toLowerCase(),
	                useCache = !xml && !ofType,
	                diff = false;

	            if (parent) {
	              // :(first|last|only)-(child|of-type)
	              if (simple) {
	                while (dir) {
	                  node = elem;

	                  while (node = node[dir]) {
	                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
	                      return false;
	                    }
	                  } // Reverse direction for :only-* (if we haven't yet done so)


	                  start = dir = type === "only" && !start && "nextSibling";
	                }

	                return true;
	              }

	              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

	              if (forward && useCache) {
	                // Seek `elem` from a previously-cached index
	                // ...in a gzip-friendly way
	                node = parent;
	                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
	                // Defend against cloned attroperties (jQuery gh-1709)

	                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                cache = uniqueCache[type] || [];
	                nodeIndex = cache[0] === dirruns && cache[1];
	                diff = nodeIndex && cache[2];
	                node = nodeIndex && parent.childNodes[nodeIndex];

	                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
	                diff = nodeIndex = 0) || start.pop()) {
	                  // When found, cache indexes on `parent` and break
	                  if (node.nodeType === 1 && ++diff && node === elem) {
	                    uniqueCache[type] = [dirruns, nodeIndex, diff];
	                    break;
	                  }
	                }
	              } else {
	                // Use previously-cached element index if available
	                if (useCache) {
	                  // ...in a gzip-friendly way
	                  node = elem;
	                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
	                  // Defend against cloned attroperties (jQuery gh-1709)

	                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                  cache = uniqueCache[type] || [];
	                  nodeIndex = cache[0] === dirruns && cache[1];
	                  diff = nodeIndex;
	                } // xml :nth-child(...)
	                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


	                if (diff === false) {
	                  // Use the same loop as above to seek `elem` from the start
	                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
	                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
	                      // Cache the index of each encountered element
	                      if (useCache) {
	                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
	                        // Defend against cloned attroperties (jQuery gh-1709)

	                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                        uniqueCache[type] = [dirruns, diff];
	                      }

	                      if (node === elem) {
	                        break;
	                      }
	                    }
	                  }
	                }
	              } // Incorporate the offset, then check against cycle size


	              diff -= last;
	              return diff === first || diff % first === 0 && diff / first >= 0;
	            }
	          };
	        },
	        "PSEUDO": function (pseudo, argument) {
	          // pseudo-class names are case-insensitive
	          // http://www.w3.org/TR/selectors/#pseudo-classes
	          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	          // Remember that setFilters inherits from pseudos
	          var args,
	              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
	          // arguments are needed to create the filter function
	          // just as Sizzle does

	          if (fn[expando]) {
	            return fn(argument);
	          } // But maintain support for old signatures


	          if (fn.length > 1) {
	            args = [pseudo, pseudo, "", argument];
	            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
	              var idx,
	                  matched = fn(seed, argument),
	                  i = matched.length;

	              while (i--) {
	                idx = indexOf(seed, matched[i]);
	                seed[idx] = !(matches[idx] = matched[i]);
	              }
	            }) : function (elem) {
	              return fn(elem, 0, args);
	            };
	          }

	          return fn;
	        }
	      },
	      pseudos: {
	        // Potentially complex pseudos
	        "not": markFunction(function (selector) {
	          // Trim the selector passed to compile
	          // to avoid treating leading and trailing
	          // spaces as combinators
	          var input = [],
	              results = [],
	              matcher = compile(selector.replace(rtrim, "$1"));
	          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
	            var elem,
	                unmatched = matcher(seed, null, xml, []),
	                i = seed.length; // Match elements unmatched by `matcher`

	            while (i--) {
	              if (elem = unmatched[i]) {
	                seed[i] = !(matches[i] = elem);
	              }
	            }
	          }) : function (elem, _context, xml) {
	            input[0] = elem;
	            matcher(input, null, xml, results); // Don't keep the element (issue #299)

	            input[0] = null;
	            return !results.pop();
	          };
	        }),
	        "has": markFunction(function (selector) {
	          return function (elem) {
	            return Sizzle(selector, elem).length > 0;
	          };
	        }),
	        "contains": markFunction(function (text) {
	          text = text.replace(runescape, funescape);
	          return function (elem) {
	            return (elem.textContent || getText(elem)).indexOf(text) > -1;
	          };
	        }),
	        // "Whether an element is represented by a :lang() selector
	        // is based solely on the element's language value
	        // being equal to the identifier C,
	        // or beginning with the identifier C immediately followed by "-".
	        // The matching of C against the element's language value is performed case-insensitively.
	        // The identifier C does not have to be a valid language name."
	        // http://www.w3.org/TR/selectors/#lang-pseudo
	        "lang": markFunction(function (lang) {
	          // lang value must be a valid identifier
	          if (!ridentifier.test(lang || "")) {
	            Sizzle.error("unsupported lang: " + lang);
	          }

	          lang = lang.replace(runescape, funescape).toLowerCase();
	          return function (elem) {
	            var elemLang;

	            do {
	              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
	                elemLang = elemLang.toLowerCase();
	                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
	              }
	            } while ((elem = elem.parentNode) && elem.nodeType === 1);

	            return false;
	          };
	        }),
	        // Miscellaneous
	        "target": function (elem) {
	          var hash = window.location && window.location.hash;
	          return hash && hash.slice(1) === elem.id;
	        },
	        "root": function (elem) {
	          return elem === docElem;
	        },
	        "focus": function (elem) {
	          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	        },
	        // Boolean properties
	        "enabled": createDisabledPseudo(false),
	        "disabled": createDisabledPseudo(true),
	        "checked": function (elem) {
	          // In CSS3, :checked should return both checked and selected elements
	          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	          var nodeName = elem.nodeName.toLowerCase();
	          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
	        },
	        "selected": function (elem) {
	          // Accessing this property makes selected-by-default
	          // options in Safari work properly
	          if (elem.parentNode) {
	            // eslint-disable-next-line no-unused-expressions
	            elem.parentNode.selectedIndex;
	          }

	          return elem.selected === true;
	        },
	        // Contents
	        "empty": function (elem) {
	          // http://www.w3.org/TR/selectors/#empty-pseudo
	          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
	          //   but not by others (comment: 8; processing instruction: 7; etc.)
	          // nodeType < 6 works because attributes (2) do not appear as children
	          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	            if (elem.nodeType < 6) {
	              return false;
	            }
	          }

	          return true;
	        },
	        "parent": function (elem) {
	          return !Expr.pseudos["empty"](elem);
	        },
	        // Element/input types
	        "header": function (elem) {
	          return rheader.test(elem.nodeName);
	        },
	        "input": function (elem) {
	          return rinputs.test(elem.nodeName);
	        },
	        "button": function (elem) {
	          var name = elem.nodeName.toLowerCase();
	          return name === "input" && elem.type === "button" || name === "button";
	        },
	        "text": function (elem) {
	          var attr;
	          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
	          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
	          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
	        },
	        // Position-in-collection
	        "first": createPositionalPseudo(function () {
	          return [0];
	        }),
	        "last": createPositionalPseudo(function (_matchIndexes, length) {
	          return [length - 1];
	        }),
	        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
	          return [argument < 0 ? argument + length : argument];
	        }),
	        "even": createPositionalPseudo(function (matchIndexes, length) {
	          var i = 0;

	          for (; i < length; i += 2) {
	            matchIndexes.push(i);
	          }

	          return matchIndexes;
	        }),
	        "odd": createPositionalPseudo(function (matchIndexes, length) {
	          var i = 1;

	          for (; i < length; i += 2) {
	            matchIndexes.push(i);
	          }

	          return matchIndexes;
	        }),
	        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
	          var i = argument < 0 ? argument + length : argument > length ? length : argument;

	          for (; --i >= 0;) {
	            matchIndexes.push(i);
	          }

	          return matchIndexes;
	        }),
	        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
	          var i = argument < 0 ? argument + length : argument;

	          for (; ++i < length;) {
	            matchIndexes.push(i);
	          }

	          return matchIndexes;
	        })
	      }
	    };
	    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

	    for (i in {
	      radio: true,
	      checkbox: true,
	      file: true,
	      password: true,
	      image: true
	    }) {
	      Expr.pseudos[i] = createInputPseudo(i);
	    }

	    for (i in {
	      submit: true,
	      reset: true
	    }) {
	      Expr.pseudos[i] = createButtonPseudo(i);
	    } // Easy API for creating new setFilters


	    function setFilters() {}

	    setFilters.prototype = Expr.filters = Expr.pseudos;
	    Expr.setFilters = new setFilters();

	    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
	      var matched,
	          match,
	          tokens,
	          type,
	          soFar,
	          groups,
	          preFilters,
	          cached = tokenCache[selector + " "];

	      if (cached) {
	        return parseOnly ? 0 : cached.slice(0);
	      }

	      soFar = selector;
	      groups = [];
	      preFilters = Expr.preFilter;

	      while (soFar) {
	        // Comma and first run
	        if (!matched || (match = rcomma.exec(soFar))) {
	          if (match) {
	            // Don't consume trailing commas as valid
	            soFar = soFar.slice(match[0].length) || soFar;
	          }

	          groups.push(tokens = []);
	        }

	        matched = false; // Combinators

	        if (match = rcombinators.exec(soFar)) {
	          matched = match.shift();
	          tokens.push({
	            value: matched,
	            // Cast descendant combinators to space
	            type: match[0].replace(rtrim, " ")
	          });
	          soFar = soFar.slice(matched.length);
	        } // Filters


	        for (type in Expr.filter) {
	          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
	            matched = match.shift();
	            tokens.push({
	              value: matched,
	              type: type,
	              matches: match
	            });
	            soFar = soFar.slice(matched.length);
	          }
	        }

	        if (!matched) {
	          break;
	        }
	      } // Return the length of the invalid excess
	      // if we're just parsing
	      // Otherwise, throw an error or return tokens


	      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
	      tokenCache(selector, groups).slice(0);
	    };

	    function toSelector(tokens) {
	      var i = 0,
	          len = tokens.length,
	          selector = "";

	      for (; i < len; i++) {
	        selector += tokens[i].value;
	      }

	      return selector;
	    }

	    function addCombinator(matcher, combinator, base) {
	      var dir = combinator.dir,
	          skip = combinator.next,
	          key = skip || dir,
	          checkNonElements = base && key === "parentNode",
	          doneName = done++;
	      return combinator.first ? // Check against closest ancestor/preceding element
	      function (elem, context, xml) {
	        while (elem = elem[dir]) {
	          if (elem.nodeType === 1 || checkNonElements) {
	            return matcher(elem, context, xml);
	          }
	        }

	        return false;
	      } : // Check against all ancestor/preceding elements
	      function (elem, context, xml) {
	        var oldCache,
	            uniqueCache,
	            outerCache,
	            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

	        if (xml) {
	          while (elem = elem[dir]) {
	            if (elem.nodeType === 1 || checkNonElements) {
	              if (matcher(elem, context, xml)) {
	                return true;
	              }
	            }
	          }
	        } else {
	          while (elem = elem[dir]) {
	            if (elem.nodeType === 1 || checkNonElements) {
	              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
	              // Defend against cloned attroperties (jQuery gh-1709)

	              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

	              if (skip && skip === elem.nodeName.toLowerCase()) {
	                elem = elem[dir] || elem;
	              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
	                // Assign to newCache so results back-propagate to previous elements
	                return newCache[2] = oldCache[2];
	              } else {
	                // Reuse newcache so results back-propagate to previous elements
	                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

	                if (newCache[2] = matcher(elem, context, xml)) {
	                  return true;
	                }
	              }
	            }
	          }
	        }

	        return false;
	      };
	    }

	    function elementMatcher(matchers) {
	      return matchers.length > 1 ? function (elem, context, xml) {
	        var i = matchers.length;

	        while (i--) {
	          if (!matchers[i](elem, context, xml)) {
	            return false;
	          }
	        }

	        return true;
	      } : matchers[0];
	    }

	    function multipleContexts(selector, contexts, results) {
	      var i = 0,
	          len = contexts.length;

	      for (; i < len; i++) {
	        Sizzle(selector, contexts[i], results);
	      }

	      return results;
	    }

	    function condense(unmatched, map, filter, context, xml) {
	      var elem,
	          newUnmatched = [],
	          i = 0,
	          len = unmatched.length,
	          mapped = map != null;

	      for (; i < len; i++) {
	        if (elem = unmatched[i]) {
	          if (!filter || filter(elem, context, xml)) {
	            newUnmatched.push(elem);

	            if (mapped) {
	              map.push(i);
	            }
	          }
	        }
	      }

	      return newUnmatched;
	    }

	    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	      if (postFilter && !postFilter[expando]) {
	        postFilter = setMatcher(postFilter);
	      }

	      if (postFinder && !postFinder[expando]) {
	        postFinder = setMatcher(postFinder, postSelector);
	      }

	      return markFunction(function (seed, results, context, xml) {
	        var temp,
	            i,
	            elem,
	            preMap = [],
	            postMap = [],
	            preexisting = results.length,
	            // Get initial elements from seed or context
	        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
	            // Prefilter to get matcher input, preserving a map for seed-results synchronization
	        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
	            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
	        [] : // ...otherwise use results directly
	        results : matcherIn; // Find primary matches

	        if (matcher) {
	          matcher(matcherIn, matcherOut, context, xml);
	        } // Apply postFilter


	        if (postFilter) {
	          temp = condense(matcherOut, postMap);
	          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

	          i = temp.length;

	          while (i--) {
	            if (elem = temp[i]) {
	              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
	            }
	          }
	        }

	        if (seed) {
	          if (postFinder || preFilter) {
	            if (postFinder) {
	              // Get the final matcherOut by condensing this intermediate into postFinder contexts
	              temp = [];
	              i = matcherOut.length;

	              while (i--) {
	                if (elem = matcherOut[i]) {
	                  // Restore matcherIn since elem is not yet a final match
	                  temp.push(matcherIn[i] = elem);
	                }
	              }

	              postFinder(null, matcherOut = [], temp, xml);
	            } // Move matched elements from seed to results to keep them synchronized


	            i = matcherOut.length;

	            while (i--) {
	              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
	                seed[temp] = !(results[temp] = elem);
	              }
	            }
	          } // Add elements to results, through postFinder if defined

	        } else {
	          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

	          if (postFinder) {
	            postFinder(null, results, matcherOut, xml);
	          } else {
	            push.apply(results, matcherOut);
	          }
	        }
	      });
	    }

	    function matcherFromTokens(tokens) {
	      var checkContext,
	          matcher,
	          j,
	          len = tokens.length,
	          leadingRelative = Expr.relative[tokens[0].type],
	          implicitRelative = leadingRelative || Expr.relative[" "],
	          i = leadingRelative ? 1 : 0,
	          // The foundational matcher ensures that elements are reachable from top-level context(s)
	      matchContext = addCombinator(function (elem) {
	        return elem === checkContext;
	      }, implicitRelative, true),
	          matchAnyContext = addCombinator(function (elem) {
	        return indexOf(checkContext, elem) > -1;
	      }, implicitRelative, true),
	          matchers = [function (elem, context, xml) {
	        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

	        checkContext = null;
	        return ret;
	      }];

	      for (; i < len; i++) {
	        if (matcher = Expr.relative[tokens[i].type]) {
	          matchers = [addCombinator(elementMatcher(matchers), matcher)];
	        } else {
	          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

	          if (matcher[expando]) {
	            // Find the next relative operator (if any) for proper handling
	            j = ++i;

	            for (; j < len; j++) {
	              if (Expr.relative[tokens[j].type]) {
	                break;
	              }
	            }

	            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
	            tokens.slice(0, i - 1).concat({
	              value: tokens[i - 2].type === " " ? "*" : ""
	            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
	          }

	          matchers.push(matcher);
	        }
	      }

	      return elementMatcher(matchers);
	    }

	    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
	      var bySet = setMatchers.length > 0,
	          byElement = elementMatchers.length > 0,
	          superMatcher = function (seed, context, xml, results, outermost) {
	        var elem,
	            j,
	            matcher,
	            matchedCount = 0,
	            i = "0",
	            unmatched = seed && [],
	            setMatched = [],
	            contextBackup = outermostContext,
	            // We must always have either seed elements or outermost context
	        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
	            // Use integer dirruns iff this is the outermost matcher
	        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
	            len = elems.length;

	        if (outermost) {
	          // Support: IE 11+, Edge 17 - 18+
	          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	          // two documents; shallow comparisons work.
	          // eslint-disable-next-line eqeqeq
	          outermostContext = context == document || context || outermost;
	        } // Add elements passing elementMatchers directly to results
	        // Support: IE<9, Safari
	        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


	        for (; i !== len && (elem = elems[i]) != null; i++) {
	          if (byElement && elem) {
	            j = 0; // Support: IE 11+, Edge 17 - 18+
	            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	            // two documents; shallow comparisons work.
	            // eslint-disable-next-line eqeqeq

	            if (!context && elem.ownerDocument != document) {
	              setDocument(elem);
	              xml = !documentIsHTML;
	            }

	            while (matcher = elementMatchers[j++]) {
	              if (matcher(elem, context || document, xml)) {
	                results.push(elem);
	                break;
	              }
	            }

	            if (outermost) {
	              dirruns = dirrunsUnique;
	            }
	          } // Track unmatched elements for set filters


	          if (bySet) {
	            // They will have gone through all possible matchers
	            if (elem = !matcher && elem) {
	              matchedCount--;
	            } // Lengthen the array for every element, matched or not


	            if (seed) {
	              unmatched.push(elem);
	            }
	          }
	        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
	        // makes the latter nonnegative.


	        matchedCount += i; // Apply set filters to unmatched elements
	        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
	        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
	        // no element matchers and no seed.
	        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
	        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
	        // numerically zero.

	        if (bySet && i !== matchedCount) {
	          j = 0;

	          while (matcher = setMatchers[j++]) {
	            matcher(unmatched, setMatched, context, xml);
	          }

	          if (seed) {
	            // Reintegrate element matches to eliminate the need for sorting
	            if (matchedCount > 0) {
	              while (i--) {
	                if (!(unmatched[i] || setMatched[i])) {
	                  setMatched[i] = pop.call(results);
	                }
	              }
	            } // Discard index placeholder values to get only actual matches


	            setMatched = condense(setMatched);
	          } // Add matches to results


	          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

	          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
	            Sizzle.uniqueSort(results);
	          }
	        } // Override manipulation of globals by nested matchers


	        if (outermost) {
	          dirruns = dirrunsUnique;
	          outermostContext = contextBackup;
	        }

	        return unmatched;
	      };

	      return bySet ? markFunction(superMatcher) : superMatcher;
	    }

	    compile = Sizzle.compile = function (selector, match
	    /* Internal Use Only */
	    ) {
	      var i,
	          setMatchers = [],
	          elementMatchers = [],
	          cached = compilerCache[selector + " "];

	      if (!cached) {
	        // Generate a function of recursive functions that can be used to check each element
	        if (!match) {
	          match = tokenize(selector);
	        }

	        i = match.length;

	        while (i--) {
	          cached = matcherFromTokens(match[i]);

	          if (cached[expando]) {
	            setMatchers.push(cached);
	          } else {
	            elementMatchers.push(cached);
	          }
	        } // Cache the compiled function


	        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

	        cached.selector = selector;
	      }

	      return cached;
	    };
	    /**
	     * A low-level selection function that works with Sizzle's compiled
	     *  selector functions
	     * @param {String|Function} selector A selector or a pre-compiled
	     *  selector function built with Sizzle.compile
	     * @param {Element} context
	     * @param {Array} [results]
	     * @param {Array} [seed] A set of elements to match against
	     */


	    select = Sizzle.select = function (selector, context, results, seed) {
	      var i,
	          tokens,
	          token,
	          type,
	          find,
	          compiled = typeof selector === "function" && selector,
	          match = !seed && tokenize(selector = compiled.selector || selector);
	      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
	      // (the latter of which guarantees us context)

	      if (match.length === 1) {
	        // Reduce context if the leading compound selector is an ID
	        tokens = match[0] = match[0].slice(0);

	        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
	          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

	          if (!context) {
	            return results; // Precompiled matchers will still verify ancestry, so step up a level
	          } else if (compiled) {
	            context = context.parentNode;
	          }

	          selector = selector.slice(tokens.shift().value.length);
	        } // Fetch a seed set for right-to-left matching


	        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

	        while (i--) {
	          token = tokens[i]; // Abort if we hit a combinator

	          if (Expr.relative[type = token.type]) {
	            break;
	          }

	          if (find = Expr.find[type]) {
	            // Search, expanding context for leading sibling combinators
	            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
	              // If seed is empty or no tokens remain, we can return early
	              tokens.splice(i, 1);
	              selector = seed.length && toSelector(tokens);

	              if (!selector) {
	                push.apply(results, seed);
	                return results;
	              }

	              break;
	            }
	          }
	        }
	      } // Compile and execute a filtering function if one is not provided
	      // Provide `match` to avoid retokenization if we modified the selector above


	      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
	      return results;
	    }; // One-time assignments
	    // Sort stability


	    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
	    // Always assume duplicates if they aren't passed to the comparison function

	    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

	    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	    // Detached nodes confoundingly follow *each other*

	    support.sortDetached = assert(function (el) {
	      // Should return 1, but returns 4 (following)
	      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
	    }); // Support: IE<8
	    // Prevent attribute/property "interpolation"
	    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

	    if (!assert(function (el) {
	      el.innerHTML = "<a href='#'></a>";
	      return el.firstChild.getAttribute("href") === "#";
	    })) {
	      addHandle("type|href|height|width", function (elem, name, isXML) {
	        if (!isXML) {
	          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
	        }
	      });
	    } // Support: IE<9
	    // Use defaultValue in place of getAttribute("value")


	    if (!support.attributes || !assert(function (el) {
	      el.innerHTML = "<input/>";
	      el.firstChild.setAttribute("value", "");
	      return el.firstChild.getAttribute("value") === "";
	    })) {
	      addHandle("value", function (elem, _name, isXML) {
	        if (!isXML && elem.nodeName.toLowerCase() === "input") {
	          return elem.defaultValue;
	        }
	      });
	    } // Support: IE<9
	    // Use getAttributeNode to fetch booleans when getAttribute lies


	    if (!assert(function (el) {
	      return el.getAttribute("disabled") == null;
	    })) {
	      addHandle(booleans, function (elem, name, isXML) {
	        var val;

	        if (!isXML) {
	          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	        }
	      });
	    }

	    return Sizzle;
	  }(window);

	  jQuery.find = Sizzle;
	  jQuery.expr = Sizzle.selectors; // Deprecated

	  jQuery.expr[":"] = jQuery.expr.pseudos;
	  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	  jQuery.text = Sizzle.getText;
	  jQuery.isXMLDoc = Sizzle.isXML;
	  jQuery.contains = Sizzle.contains;
	  jQuery.escapeSelector = Sizzle.escape;

	  var dir = function (elem, dir, until) {
	    var matched = [],
	        truncate = until !== undefined;

	    while ((elem = elem[dir]) && elem.nodeType !== 9) {
	      if (elem.nodeType === 1) {
	        if (truncate && jQuery(elem).is(until)) {
	          break;
	        }

	        matched.push(elem);
	      }
	    }

	    return matched;
	  };

	  var siblings = function (n, elem) {
	    var matched = [];

	    for (; n; n = n.nextSibling) {
	      if (n.nodeType === 1 && n !== elem) {
	        matched.push(n);
	      }
	    }

	    return matched;
	  };

	  var rneedsContext = jQuery.expr.match.needsContext;

	  function nodeName(elem, name) {
	    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	  }
	  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

	  function winnow(elements, qualifier, not) {
	    if (isFunction(qualifier)) {
	      return jQuery.grep(elements, function (elem, i) {
	        return !!qualifier.call(elem, i, elem) !== not;
	      });
	    } // Single element


	    if (qualifier.nodeType) {
	      return jQuery.grep(elements, function (elem) {
	        return elem === qualifier !== not;
	      });
	    } // Arraylike of elements (jQuery, arguments, Array)


	    if (typeof qualifier !== "string") {
	      return jQuery.grep(elements, function (elem) {
	        return indexOf.call(qualifier, elem) > -1 !== not;
	      });
	    } // Filtered directly for both simple and complex selectors


	    return jQuery.filter(qualifier, elements, not);
	  }

	  jQuery.filter = function (expr, elems, not) {
	    var elem = elems[0];

	    if (not) {
	      expr = ":not(" + expr + ")";
	    }

	    if (elems.length === 1 && elem.nodeType === 1) {
	      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
	    }

	    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
	      return elem.nodeType === 1;
	    }));
	  };

	  jQuery.fn.extend({
	    find: function (selector) {
	      var i,
	          ret,
	          len = this.length,
	          self = this;

	      if (typeof selector !== "string") {
	        return this.pushStack(jQuery(selector).filter(function () {
	          for (i = 0; i < len; i++) {
	            if (jQuery.contains(self[i], this)) {
	              return true;
	            }
	          }
	        }));
	      }

	      ret = this.pushStack([]);

	      for (i = 0; i < len; i++) {
	        jQuery.find(selector, self[i], ret);
	      }

	      return len > 1 ? jQuery.uniqueSort(ret) : ret;
	    },
	    filter: function (selector) {
	      return this.pushStack(winnow(this, selector || [], false));
	    },
	    not: function (selector) {
	      return this.pushStack(winnow(this, selector || [], true));
	    },
	    is: function (selector) {
	      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
	      // so $("p:first").is("p:last") won't return true for a doc with two "p".
	      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
	    }
	  }); // Initialize a jQuery object
	  // A central reference to the root jQuery(document)

	  var rootjQuery,
	      // A simple way to check for HTML strings
	  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	  // Strict HTML recognition (#11290: must start with <)
	  // Shortcut simple #id case for speed
	  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	      init = jQuery.fn.init = function (selector, context, root) {
	    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

	    if (!selector) {
	      return this;
	    } // Method init() accepts an alternate rootjQuery
	    // so migrate can support jQuery.sub (gh-2101)


	    root = root || rootjQuery; // Handle HTML strings

	    if (typeof selector === "string") {
	      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
	        // Assume that strings that start and end with <> are HTML and skip the regex check
	        match = [null, selector, null];
	      } else {
	        match = rquickExpr.exec(selector);
	      } // Match html or make sure no context is specified for #id


	      if (match && (match[1] || !context)) {
	        // HANDLE: $(html) -> $(array)
	        if (match[1]) {
	          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
	          // Intentionally let the error be thrown if parseHTML is not present

	          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

	          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
	            for (match in context) {
	              // Properties of context are called as methods if possible
	              if (isFunction(this[match])) {
	                this[match](context[match]); // ...and otherwise set as attributes
	              } else {
	                this.attr(match, context[match]);
	              }
	            }
	          }

	          return this; // HANDLE: $(#id)
	        } else {
	          elem = document.getElementById(match[2]);

	          if (elem) {
	            // Inject the element directly into the jQuery object
	            this[0] = elem;
	            this.length = 1;
	          }

	          return this;
	        } // HANDLE: $(expr, $(...))

	      } else if (!context || context.jquery) {
	        return (context || root).find(selector); // HANDLE: $(expr, context)
	        // (which is just equivalent to: $(context).find(expr)
	      } else {
	        return this.constructor(context).find(selector);
	      } // HANDLE: $(DOMElement)

	    } else if (selector.nodeType) {
	      this[0] = selector;
	      this.length = 1;
	      return this; // HANDLE: $(function)
	      // Shortcut for document ready
	    } else if (isFunction(selector)) {
	      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
	      selector(jQuery);
	    }

	    return jQuery.makeArray(selector, this);
	  }; // Give the init function the jQuery prototype for later instantiation


	  init.prototype = jQuery.fn; // Initialize central reference

	  rootjQuery = jQuery(document);
	  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	      // Methods guaranteed to produce a unique set when starting from a unique set
	  guaranteedUnique = {
	    children: true,
	    contents: true,
	    next: true,
	    prev: true
	  };
	  jQuery.fn.extend({
	    has: function (target) {
	      var targets = jQuery(target, this),
	          l = targets.length;
	      return this.filter(function () {
	        var i = 0;

	        for (; i < l; i++) {
	          if (jQuery.contains(this, targets[i])) {
	            return true;
	          }
	        }
	      });
	    },
	    closest: function (selectors, context) {
	      var cur,
	          i = 0,
	          l = this.length,
	          matched = [],
	          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

	      if (!rneedsContext.test(selectors)) {
	        for (; i < l; i++) {
	          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
	            // Always skip document fragments
	            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
	            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
	              matched.push(cur);
	              break;
	            }
	          }
	        }
	      }

	      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
	    },
	    // Determine the position of an element within the set
	    index: function (elem) {
	      // No argument, return index in parent
	      if (!elem) {
	        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	      } // Index in selector


	      if (typeof elem === "string") {
	        return indexOf.call(jQuery(elem), this[0]);
	      } // Locate the position of the desired element


	      return indexOf.call(this, // If it receives a jQuery object, the first element is used
	      elem.jquery ? elem[0] : elem);
	    },
	    add: function (selector, context) {
	      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
	    },
	    addBack: function (selector) {
	      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
	    }
	  });

	  function sibling(cur, dir) {
	    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

	    return cur;
	  }

	  jQuery.each({
	    parent: function (elem) {
	      var parent = elem.parentNode;
	      return parent && parent.nodeType !== 11 ? parent : null;
	    },
	    parents: function (elem) {
	      return dir(elem, "parentNode");
	    },
	    parentsUntil: function (elem, _i, until) {
	      return dir(elem, "parentNode", until);
	    },
	    next: function (elem) {
	      return sibling(elem, "nextSibling");
	    },
	    prev: function (elem) {
	      return sibling(elem, "previousSibling");
	    },
	    nextAll: function (elem) {
	      return dir(elem, "nextSibling");
	    },
	    prevAll: function (elem) {
	      return dir(elem, "previousSibling");
	    },
	    nextUntil: function (elem, _i, until) {
	      return dir(elem, "nextSibling", until);
	    },
	    prevUntil: function (elem, _i, until) {
	      return dir(elem, "previousSibling", until);
	    },
	    siblings: function (elem) {
	      return siblings((elem.parentNode || {}).firstChild, elem);
	    },
	    children: function (elem) {
	      return siblings(elem.firstChild);
	    },
	    contents: function (elem) {
	      if (elem.contentDocument != null && // Support: IE 11+
	      // <object> elements with no `data` attribute has an object
	      // `contentDocument` with a `null` prototype.
	      getProto(elem.contentDocument)) {
	        return elem.contentDocument;
	      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	      // Treat the template element as a regular one in browsers that
	      // don't support it.


	      if (nodeName(elem, "template")) {
	        elem = elem.content || elem;
	      }

	      return jQuery.merge([], elem.childNodes);
	    }
	  }, function (name, fn) {
	    jQuery.fn[name] = function (until, selector) {
	      var matched = jQuery.map(this, fn, until);

	      if (name.slice(-5) !== "Until") {
	        selector = until;
	      }

	      if (selector && typeof selector === "string") {
	        matched = jQuery.filter(selector, matched);
	      }

	      if (this.length > 1) {
	        // Remove duplicates
	        if (!guaranteedUnique[name]) {
	          jQuery.uniqueSort(matched);
	        } // Reverse order for parents* and prev-derivatives


	        if (rparentsprev.test(name)) {
	          matched.reverse();
	        }
	      }

	      return this.pushStack(matched);
	    };
	  });
	  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

	  function createOptions(options) {
	    var object = {};
	    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
	      object[flag] = true;
	    });
	    return object;
	  }
	  /*
	   * Create a callback list using the following parameters:
	   *
	   *	options: an optional list of space-separated options that will change how
	   *			the callback list behaves or a more traditional option object
	   *
	   * By default a callback list will act like an event callback list and can be
	   * "fired" multiple times.
	   *
	   * Possible options:
	   *
	   *	once:			will ensure the callback list can only be fired once (like a Deferred)
	   *
	   *	memory:			will keep track of previous values and will call any callback added
	   *					after the list has been fired right away with the latest "memorized"
	   *					values (like a Deferred)
	   *
	   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	   *
	   *	stopOnFalse:	interrupt callings when a callback returns false
	   *
	   */


	  jQuery.Callbacks = function (options) {
	    // Convert options from String-formatted to Object-formatted if needed
	    // (we check in cache first)
	    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

	    var // Flag to know if list is currently firing
	    firing,
	        // Last fire value for non-forgettable lists
	    memory,
	        // Flag to know if list was already fired
	    fired,
	        // Flag to prevent firing
	    locked,
	        // Actual callback list
	    list = [],
	        // Queue of execution data for repeatable lists
	    queue = [],
	        // Index of currently firing callback (modified by add/remove as needed)
	    firingIndex = -1,
	        // Fire callbacks
	    fire = function () {
	      // Enforce single-firing
	      locked = locked || options.once; // Execute callbacks for all pending executions,
	      // respecting firingIndex overrides and runtime changes

	      fired = firing = true;

	      for (; queue.length; firingIndex = -1) {
	        memory = queue.shift();

	        while (++firingIndex < list.length) {
	          // Run callback and check for early termination
	          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
	            // Jump to end and forget the data so .add doesn't re-fire
	            firingIndex = list.length;
	            memory = false;
	          }
	        }
	      } // Forget the data if we're done with it


	      if (!options.memory) {
	        memory = false;
	      }

	      firing = false; // Clean up if we're done firing for good

	      if (locked) {
	        // Keep an empty list if we have data for future add calls
	        if (memory) {
	          list = []; // Otherwise, this object is spent
	        } else {
	          list = "";
	        }
	      }
	    },
	        // Actual Callbacks object
	    self = {
	      // Add a callback or a collection of callbacks to the list
	      add: function () {
	        if (list) {
	          // If we have memory from a past run, we should fire after adding
	          if (memory && !firing) {
	            firingIndex = list.length - 1;
	            queue.push(memory);
	          }

	          (function add(args) {
	            jQuery.each(args, function (_, arg) {
	              if (isFunction(arg)) {
	                if (!options.unique || !self.has(arg)) {
	                  list.push(arg);
	                }
	              } else if (arg && arg.length && toType(arg) !== "string") {
	                // Inspect recursively
	                add(arg);
	              }
	            });
	          })(arguments);

	          if (memory && !firing) {
	            fire();
	          }
	        }

	        return this;
	      },
	      // Remove a callback from the list
	      remove: function () {
	        jQuery.each(arguments, function (_, arg) {
	          var index;

	          while ((index = jQuery.inArray(arg, list, index)) > -1) {
	            list.splice(index, 1); // Handle firing indexes

	            if (index <= firingIndex) {
	              firingIndex--;
	            }
	          }
	        });
	        return this;
	      },
	      // Check if a given callback is in the list.
	      // If no argument is given, return whether or not list has callbacks attached.
	      has: function (fn) {
	        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
	      },
	      // Remove all callbacks from the list
	      empty: function () {
	        if (list) {
	          list = [];
	        }

	        return this;
	      },
	      // Disable .fire and .add
	      // Abort any current/pending executions
	      // Clear all callbacks and values
	      disable: function () {
	        locked = queue = [];
	        list = memory = "";
	        return this;
	      },
	      disabled: function () {
	        return !list;
	      },
	      // Disable .fire
	      // Also disable .add unless we have memory (since it would have no effect)
	      // Abort any pending executions
	      lock: function () {
	        locked = queue = [];

	        if (!memory && !firing) {
	          list = memory = "";
	        }

	        return this;
	      },
	      locked: function () {
	        return !!locked;
	      },
	      // Call all callbacks with the given context and arguments
	      fireWith: function (context, args) {
	        if (!locked) {
	          args = args || [];
	          args = [context, args.slice ? args.slice() : args];
	          queue.push(args);

	          if (!firing) {
	            fire();
	          }
	        }

	        return this;
	      },
	      // Call all the callbacks with the given arguments
	      fire: function () {
	        self.fireWith(this, arguments);
	        return this;
	      },
	      // To know if the callbacks have already been called at least once
	      fired: function () {
	        return !!fired;
	      }
	    };

	    return self;
	  };

	  function Identity(v) {
	    return v;
	  }

	  function Thrower(ex) {
	    throw ex;
	  }

	  function adoptValue(value, resolve, reject, noValue) {
	    var method;

	    try {
	      // Check for promise aspect first to privilege synchronous behavior
	      if (value && isFunction(method = value.promise)) {
	        method.call(value).done(resolve).fail(reject); // Other thenables
	      } else if (value && isFunction(method = value.then)) {
	        method.call(value, resolve, reject); // Other non-thenables
	      } else {
	        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
	        // * false: [ value ].slice( 0 ) => resolve( value )
	        // * true: [ value ].slice( 1 ) => resolve()
	        resolve.apply(undefined, [value].slice(noValue));
	      } // For Promises/A+, convert exceptions into rejections
	      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	      // Deferred#then to conditionally suppress rejection.

	    } catch (value) {
	      // Support: Android 4.0 only
	      // Strict mode functions invoked without .call/.apply get global-object context
	      reject.apply(undefined, [value]);
	    }
	  }

	  jQuery.extend({
	    Deferred: function (func) {
	      var tuples = [// action, add listener, callbacks,
	      // ... .then handlers, argument index, [final state]
	      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
	          state = "pending",
	          promise = {
	        state: function () {
	          return state;
	        },
	        always: function () {
	          deferred.done(arguments).fail(arguments);
	          return this;
	        },
	        "catch": function (fn) {
	          return promise.then(null, fn);
	        },
	        // Keep pipe for back-compat
	        pipe: function ()
	        /* fnDone, fnFail, fnProgress */
	        {
	          var fns = arguments;
	          return jQuery.Deferred(function (newDefer) {
	            jQuery.each(tuples, function (_i, tuple) {
	              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
	              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
	              // deferred.done(function() { bind to newDefer or newDefer.resolve })
	              // deferred.fail(function() { bind to newDefer or newDefer.reject })

	              deferred[tuple[1]](function () {
	                var returned = fn && fn.apply(this, arguments);

	                if (returned && isFunction(returned.promise)) {
	                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
	                } else {
	                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
	                }
	              });
	            });
	            fns = null;
	          }).promise();
	        },
	        then: function (onFulfilled, onRejected, onProgress) {
	          var maxDepth = 0;

	          function resolve(depth, deferred, handler, special) {
	            return function () {
	              var that = this,
	                  args = arguments,
	                  mightThrow = function () {
	                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
	                // https://promisesaplus.com/#point-59
	                // Ignore double-resolution attempts

	                if (depth < maxDepth) {
	                  return;
	                }

	                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
	                // https://promisesaplus.com/#point-48

	                if (returned === deferred.promise()) {
	                  throw new TypeError("Thenable self-resolution");
	                } // Support: Promises/A+ sections 2.3.3.1, 3.5
	                // https://promisesaplus.com/#point-54
	                // https://promisesaplus.com/#point-75
	                // Retrieve `then` only once


	                then = returned && ( // Support: Promises/A+ section 2.3.4
	                // https://promisesaplus.com/#point-64
	                // Only check objects and functions for thenability
	                typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

	                if (isFunction(then)) {
	                  // Special processors (notify) just wait for resolution
	                  if (special) {
	                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
	                  } else {
	                    // ...and disregard older resolution values
	                    maxDepth++;
	                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
	                  } // Handle all other returned values

	                } else {
	                  // Only substitute handlers pass on context
	                  // and multiple values (non-spec behavior)
	                  if (handler !== Identity) {
	                    that = undefined;
	                    args = [returned];
	                  } // Process the value(s)
	                  // Default process is resolve


	                  (special || deferred.resolveWith)(that, args);
	                }
	              },
	                  // Only normal processors (resolve) catch and reject exceptions
	              process = special ? mightThrow : function () {
	                try {
	                  mightThrow();
	                } catch (e) {
	                  if (jQuery.Deferred.exceptionHook) {
	                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
	                  } // Support: Promises/A+ section 2.3.3.3.4.1
	                  // https://promisesaplus.com/#point-61
	                  // Ignore post-resolution exceptions


	                  if (depth + 1 >= maxDepth) {
	                    // Only substitute handlers pass on context
	                    // and multiple values (non-spec behavior)
	                    if (handler !== Thrower) {
	                      that = undefined;
	                      args = [e];
	                    }

	                    deferred.rejectWith(that, args);
	                  }
	                }
	              }; // Support: Promises/A+ section 2.3.3.3.1
	              // https://promisesaplus.com/#point-57
	              // Re-resolve promises immediately to dodge false rejection from
	              // subsequent errors


	              if (depth) {
	                process();
	              } else {
	                // Call an optional hook to record the stack, in case of exception
	                // since it's otherwise lost when execution goes async
	                if (jQuery.Deferred.getStackHook) {
	                  process.stackTrace = jQuery.Deferred.getStackHook();
	                }

	                window.setTimeout(process);
	              }
	            };
	          }

	          return jQuery.Deferred(function (newDefer) {
	            // progress_handlers.add( ... )
	            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

	            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

	            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
	          }).promise();
	        },
	        // Get a promise for this deferred
	        // If obj is provided, the promise aspect is added to the object
	        promise: function (obj) {
	          return obj != null ? jQuery.extend(obj, promise) : promise;
	        }
	      },
	          deferred = {}; // Add list-specific methods

	      jQuery.each(tuples, function (i, tuple) {
	        var list = tuple[2],
	            stateString = tuple[5]; // promise.progress = list.add
	        // promise.done = list.add
	        // promise.fail = list.add

	        promise[tuple[1]] = list.add; // Handle state

	        if (stateString) {
	          list.add(function () {
	            // state = "resolved" (i.e., fulfilled)
	            // state = "rejected"
	            state = stateString;
	          }, // rejected_callbacks.disable
	          // fulfilled_callbacks.disable
	          tuples[3 - i][2].disable, // rejected_handlers.disable
	          // fulfilled_handlers.disable
	          tuples[3 - i][3].disable, // progress_callbacks.lock
	          tuples[0][2].lock, // progress_handlers.lock
	          tuples[0][3].lock);
	        } // progress_handlers.fire
	        // fulfilled_handlers.fire
	        // rejected_handlers.fire


	        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
	        // deferred.resolve = function() { deferred.resolveWith(...) }
	        // deferred.reject = function() { deferred.rejectWith(...) }

	        deferred[tuple[0]] = function () {
	          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
	          return this;
	        }; // deferred.notifyWith = list.fireWith
	        // deferred.resolveWith = list.fireWith
	        // deferred.rejectWith = list.fireWith


	        deferred[tuple[0] + "With"] = list.fireWith;
	      }); // Make the deferred a promise

	      promise.promise(deferred); // Call given func if any

	      if (func) {
	        func.call(deferred, deferred);
	      } // All done!


	      return deferred;
	    },
	    // Deferred helper
	    when: function (singleValue) {
	      var // count of uncompleted subordinates
	      remaining = arguments.length,
	          // count of unprocessed arguments
	      i = remaining,
	          // subordinate fulfillment data
	      resolveContexts = Array(i),
	          resolveValues = slice.call(arguments),
	          // the master Deferred
	      master = jQuery.Deferred(),
	          // subordinate callback factory
	      updateFunc = function (i) {
	        return function (value) {
	          resolveContexts[i] = this;
	          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

	          if (! --remaining) {
	            master.resolveWith(resolveContexts, resolveValues);
	          }
	        };
	      }; // Single- and empty arguments are adopted like Promise.resolve


	      if (remaining <= 1) {
	        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

	        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
	          return master.then();
	        }
	      } // Multiple arguments are aggregated like Promise.all array elements


	      while (i--) {
	        adoptValue(resolveValues[i], updateFunc(i), master.reject);
	      }

	      return master.promise();
	    }
	  }); // These usually indicate a programmer mistake during development,
	  // warn about them ASAP rather than swallowing them by default.

	  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	  jQuery.Deferred.exceptionHook = function (error, stack) {
	    // Support: IE 8 - 9 only
	    // Console exists when dev tools are open, which can happen at any time
	    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
	      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
	    }
	  };

	  jQuery.readyException = function (error) {
	    window.setTimeout(function () {
	      throw error;
	    });
	  }; // The deferred used on DOM ready


	  var readyList = jQuery.Deferred();

	  jQuery.fn.ready = function (fn) {
	    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
	    // happens at the time of error handling instead of callback
	    // registration.
	    .catch(function (error) {
	      jQuery.readyException(error);
	    });
	    return this;
	  };

	  jQuery.extend({
	    // Is the DOM ready to be used? Set to true once it occurs.
	    isReady: false,
	    // A counter to track how many items to wait for before
	    // the ready event fires. See #6781
	    readyWait: 1,
	    // Handle when the DOM is ready
	    ready: function (wait) {
	      // Abort if there are pending holds or we're already ready
	      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
	        return;
	      } // Remember that the DOM is ready


	      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

	      if (wait !== true && --jQuery.readyWait > 0) {
	        return;
	      } // If there are functions bound, to execute


	      readyList.resolveWith(document, [jQuery]);
	    }
	  });
	  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

	  function completed() {
	    document.removeEventListener("DOMContentLoaded", completed);
	    window.removeEventListener("load", completed);
	    jQuery.ready();
	  } // Catch cases where $(document).ready() is called
	  // after the browser event has already occurred.
	  // Support: IE <=9 - 10 only
	  // Older IE sometimes signals "interactive" too soon


	  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
	    // Handle it asynchronously to allow scripts the opportunity to delay ready
	    window.setTimeout(jQuery.ready);
	  } else {
	    // Use the handy event callback
	    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

	    window.addEventListener("load", completed);
	  } // Multifunctional method to get and set values of a collection
	  // The value/s can optionally be executed if it's a function


	  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
	    var i = 0,
	        len = elems.length,
	        bulk = key == null; // Sets many values

	    if (toType(key) === "object") {
	      chainable = true;

	      for (i in key) {
	        access(elems, fn, i, key[i], true, emptyGet, raw);
	      } // Sets one value

	    } else if (value !== undefined) {
	      chainable = true;

	      if (!isFunction(value)) {
	        raw = true;
	      }

	      if (bulk) {
	        // Bulk operations run against the entire set
	        if (raw) {
	          fn.call(elems, value);
	          fn = null; // ...except when executing function values
	        } else {
	          bulk = fn;

	          fn = function (elem, _key, value) {
	            return bulk.call(jQuery(elem), value);
	          };
	        }
	      }

	      if (fn) {
	        for (; i < len; i++) {
	          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
	        }
	      }
	    }

	    if (chainable) {
	      return elems;
	    } // Gets


	    if (bulk) {
	      return fn.call(elems);
	    }

	    return len ? fn(elems[0], key) : emptyGet;
	  }; // Matches dashed string for camelizing


	  var rmsPrefix = /^-ms-/,
	      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

	  function fcamelCase(_all, letter) {
	    return letter.toUpperCase();
	  } // Convert dashed to camelCase; used by the css and data modules
	  // Support: IE <=9 - 11, Edge 12 - 15
	  // Microsoft forgot to hump their vendor prefix (#9572)


	  function camelCase(string) {
	    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
	  }

	  var acceptData = function (owner) {
	    // Accepts only:
	    //  - Node
	    //    - Node.ELEMENT_NODE
	    //    - Node.DOCUMENT_NODE
	    //  - Object
	    //    - Any
	    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	  };

	  function Data() {
	    this.expando = jQuery.expando + Data.uid++;
	  }

	  Data.uid = 1;
	  Data.prototype = {
	    cache: function (owner) {
	      // Check if the owner object already has a cache
	      var value = owner[this.expando]; // If not, create one

	      if (!value) {
	        value = {}; // We can accept data for non-element nodes in modern browsers,
	        // but we should not, see #8335.
	        // Always return an empty object.

	        if (acceptData(owner)) {
	          // If it is a node unlikely to be stringify-ed or looped over
	          // use plain assignment
	          if (owner.nodeType) {
	            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
	            // configurable must be true to allow the property to be
	            // deleted when data is removed
	          } else {
	            Object.defineProperty(owner, this.expando, {
	              value: value,
	              configurable: true
	            });
	          }
	        }
	      }

	      return value;
	    },
	    set: function (owner, data, value) {
	      var prop,
	          cache = this.cache(owner); // Handle: [ owner, key, value ] args
	      // Always use camelCase key (gh-2257)

	      if (typeof data === "string") {
	        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
	      } else {
	        // Copy the properties one-by-one to the cache object
	        for (prop in data) {
	          cache[camelCase(prop)] = data[prop];
	        }
	      }

	      return cache;
	    },
	    get: function (owner, key) {
	      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
	      owner[this.expando] && owner[this.expando][camelCase(key)];
	    },
	    access: function (owner, key, value) {
	      // In cases where either:
	      //
	      //   1. No key was specified
	      //   2. A string key was specified, but no value provided
	      //
	      // Take the "read" path and allow the get method to determine
	      // which value to return, respectively either:
	      //
	      //   1. The entire cache object
	      //   2. The data stored at the key
	      //
	      if (key === undefined || key && typeof key === "string" && value === undefined) {
	        return this.get(owner, key);
	      } // When the key is not a string, or both a key and value
	      // are specified, set or extend (existing objects) with either:
	      //
	      //   1. An object of properties
	      //   2. A key and value
	      //


	      this.set(owner, key, value); // Since the "set" path can have two possible entry points
	      // return the expected data based on which path was taken[*]

	      return value !== undefined ? value : key;
	    },
	    remove: function (owner, key) {
	      var i,
	          cache = owner[this.expando];

	      if (cache === undefined) {
	        return;
	      }

	      if (key !== undefined) {
	        // Support array or space separated string of keys
	        if (Array.isArray(key)) {
	          // If key is an array of keys...
	          // We always set camelCase keys, so remove that.
	          key = key.map(camelCase);
	        } else {
	          key = camelCase(key); // If a key with the spaces exists, use it.
	          // Otherwise, create an array by matching non-whitespace

	          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
	        }

	        i = key.length;

	        while (i--) {
	          delete cache[key[i]];
	        }
	      } // Remove the expando if there's no more data


	      if (key === undefined || jQuery.isEmptyObject(cache)) {
	        // Support: Chrome <=35 - 45
	        // Webkit & Blink performance suffers when deleting properties
	        // from DOM nodes, so set to undefined instead
	        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
	        if (owner.nodeType) {
	          owner[this.expando] = undefined;
	        } else {
	          delete owner[this.expando];
	        }
	      }
	    },
	    hasData: function (owner) {
	      var cache = owner[this.expando];
	      return cache !== undefined && !jQuery.isEmptyObject(cache);
	    }
	  };
	  var dataPriv = new Data();
	  var dataUser = new Data(); //	Implementation Summary
	  //
	  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
	  //	2. Improve the module's maintainability by reducing the storage
	  //		paths to a single mechanism.
	  //	3. Use the same single mechanism to support "private" and "user" data.
	  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
	  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	      rmultiDash = /[A-Z]/g;

	  function getData(data) {
	    if (data === "true") {
	      return true;
	    }

	    if (data === "false") {
	      return false;
	    }

	    if (data === "null") {
	      return null;
	    } // Only convert to a number if it doesn't change the string


	    if (data === +data + "") {
	      return +data;
	    }

	    if (rbrace.test(data)) {
	      return JSON.parse(data);
	    }

	    return data;
	  }

	  function dataAttr(elem, key, data) {
	    var name; // If nothing was found internally, try to fetch any
	    // data from the HTML5 data-* attribute

	    if (data === undefined && elem.nodeType === 1) {
	      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
	      data = elem.getAttribute(name);

	      if (typeof data === "string") {
	        try {
	          data = getData(data);
	        } catch (e) {} // Make sure we set the data so it isn't changed later


	        dataUser.set(elem, key, data);
	      } else {
	        data = undefined;
	      }
	    }

	    return data;
	  }

	  jQuery.extend({
	    hasData: function (elem) {
	      return dataUser.hasData(elem) || dataPriv.hasData(elem);
	    },
	    data: function (elem, name, data) {
	      return dataUser.access(elem, name, data);
	    },
	    removeData: function (elem, name) {
	      dataUser.remove(elem, name);
	    },
	    // TODO: Now that all calls to _data and _removeData have been replaced
	    // with direct calls to dataPriv methods, these can be deprecated.
	    _data: function (elem, name, data) {
	      return dataPriv.access(elem, name, data);
	    },
	    _removeData: function (elem, name) {
	      dataPriv.remove(elem, name);
	    }
	  });
	  jQuery.fn.extend({
	    data: function (key, value) {
	      var i,
	          name,
	          data,
	          elem = this[0],
	          attrs = elem && elem.attributes; // Gets all values

	      if (key === undefined) {
	        if (this.length) {
	          data = dataUser.get(elem);

	          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
	            i = attrs.length;

	            while (i--) {
	              // Support: IE 11 only
	              // The attrs elements can be null (#14894)
	              if (attrs[i]) {
	                name = attrs[i].name;

	                if (name.indexOf("data-") === 0) {
	                  name = camelCase(name.slice(5));
	                  dataAttr(elem, name, data[name]);
	                }
	              }
	            }

	            dataPriv.set(elem, "hasDataAttrs", true);
	          }
	        }

	        return data;
	      } // Sets multiple values


	      if (typeof key === "object") {
	        return this.each(function () {
	          dataUser.set(this, key);
	        });
	      }

	      return access(this, function (value) {
	        var data; // The calling jQuery object (element matches) is not empty
	        // (and therefore has an element appears at this[ 0 ]) and the
	        // `value` parameter was not undefined. An empty jQuery object
	        // will result in `undefined` for elem = this[ 0 ] which will
	        // throw an exception if an attempt to read a data cache is made.

	        if (elem && value === undefined) {
	          // Attempt to get data from the cache
	          // The key will always be camelCased in Data
	          data = dataUser.get(elem, key);

	          if (data !== undefined) {
	            return data;
	          } // Attempt to "discover" the data in
	          // HTML5 custom data-* attrs


	          data = dataAttr(elem, key);

	          if (data !== undefined) {
	            return data;
	          } // We tried really hard, but the data doesn't exist.


	          return;
	        } // Set the data...


	        this.each(function () {
	          // We always store the camelCased key
	          dataUser.set(this, key, value);
	        });
	      }, null, value, arguments.length > 1, null, true);
	    },
	    removeData: function (key) {
	      return this.each(function () {
	        dataUser.remove(this, key);
	      });
	    }
	  });
	  jQuery.extend({
	    queue: function (elem, type, data) {
	      var queue;

	      if (elem) {
	        type = (type || "fx") + "queue";
	        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

	        if (data) {
	          if (!queue || Array.isArray(data)) {
	            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
	          } else {
	            queue.push(data);
	          }
	        }

	        return queue || [];
	      }
	    },
	    dequeue: function (elem, type) {
	      type = type || "fx";

	      var queue = jQuery.queue(elem, type),
	          startLength = queue.length,
	          fn = queue.shift(),
	          hooks = jQuery._queueHooks(elem, type),
	          next = function () {
	        jQuery.dequeue(elem, type);
	      }; // If the fx queue is dequeued, always remove the progress sentinel


	      if (fn === "inprogress") {
	        fn = queue.shift();
	        startLength--;
	      }

	      if (fn) {
	        // Add a progress sentinel to prevent the fx queue from being
	        // automatically dequeued
	        if (type === "fx") {
	          queue.unshift("inprogress");
	        } // Clear up the last queue stop function


	        delete hooks.stop;
	        fn.call(elem, next, hooks);
	      }

	      if (!startLength && hooks) {
	        hooks.empty.fire();
	      }
	    },
	    // Not public - generate a queueHooks object, or return the current one
	    _queueHooks: function (elem, type) {
	      var key = type + "queueHooks";
	      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
	        empty: jQuery.Callbacks("once memory").add(function () {
	          dataPriv.remove(elem, [type + "queue", key]);
	        })
	      });
	    }
	  });
	  jQuery.fn.extend({
	    queue: function (type, data) {
	      var setter = 2;

	      if (typeof type !== "string") {
	        data = type;
	        type = "fx";
	        setter--;
	      }

	      if (arguments.length < setter) {
	        return jQuery.queue(this[0], type);
	      }

	      return data === undefined ? this : this.each(function () {
	        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

	        jQuery._queueHooks(this, type);

	        if (type === "fx" && queue[0] !== "inprogress") {
	          jQuery.dequeue(this, type);
	        }
	      });
	    },
	    dequeue: function (type) {
	      return this.each(function () {
	        jQuery.dequeue(this, type);
	      });
	    },
	    clearQueue: function (type) {
	      return this.queue(type || "fx", []);
	    },
	    // Get a promise resolved when queues of a certain type
	    // are emptied (fx is the type by default)
	    promise: function (type, obj) {
	      var tmp,
	          count = 1,
	          defer = jQuery.Deferred(),
	          elements = this,
	          i = this.length,
	          resolve = function () {
	        if (! --count) {
	          defer.resolveWith(elements, [elements]);
	        }
	      };

	      if (typeof type !== "string") {
	        obj = type;
	        type = undefined;
	      }

	      type = type || "fx";

	      while (i--) {
	        tmp = dataPriv.get(elements[i], type + "queueHooks");

	        if (tmp && tmp.empty) {
	          count++;
	          tmp.empty.add(resolve);
	        }
	      }

	      resolve();
	      return defer.promise(obj);
	    }
	  });
	  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
	  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
	  var cssExpand = ["Top", "Right", "Bottom", "Left"];
	  var documentElement = document.documentElement;

	  var isAttached = function (elem) {
	    return jQuery.contains(elem.ownerDocument, elem);
	  },
	      composed = {
	    composed: true
	  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	  // Check attachment across shadow DOM boundaries when possible (gh-3504)
	  // Support: iOS 10.0-10.2 only
	  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	  // leading to errors. We need to check for `getRootNode`.


	  if (documentElement.getRootNode) {
	    isAttached = function (elem) {
	      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
	    };
	  }

	  var isHiddenWithinTree = function (elem, el) {
	    // isHiddenWithinTree might be called from jQuery#filter function;
	    // in that case, element will be second argument
	    elem = el || elem; // Inline style trumps all

	    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
	    // Support: Firefox <=43 - 45
	    // Disconnected elements can have computed display: none, so first confirm that elem is
	    // in the document.
	    isAttached(elem) && jQuery.css(elem, "display") === "none";
	  };

	  function adjustCSS(elem, prop, valueParts, tween) {
	    var adjusted,
	        scale,
	        maxIterations = 20,
	        currentValue = tween ? function () {
	      return tween.cur();
	    } : function () {
	      return jQuery.css(elem, prop, "");
	    },
	        initial = currentValue(),
	        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
	        // Starting value computation is required for potential unit mismatches
	    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

	    if (initialInUnit && initialInUnit[3] !== unit) {
	      // Support: Firefox <=54
	      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
	      initial = initial / 2; // Trust units reported by jQuery.css

	      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

	      initialInUnit = +initial || 1;

	      while (maxIterations--) {
	        // Evaluate and update our best guess (doubling guesses that zero out).
	        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
	        jQuery.style(elem, prop, initialInUnit + unit);

	        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
	          maxIterations = 0;
	        }

	        initialInUnit = initialInUnit / scale;
	      }

	      initialInUnit = initialInUnit * 2;
	      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

	      valueParts = valueParts || [];
	    }

	    if (valueParts) {
	      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

	      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

	      if (tween) {
	        tween.unit = unit;
	        tween.start = initialInUnit;
	        tween.end = adjusted;
	      }
	    }

	    return adjusted;
	  }

	  var defaultDisplayMap = {};

	  function getDefaultDisplay(elem) {
	    var temp,
	        doc = elem.ownerDocument,
	        nodeName = elem.nodeName,
	        display = defaultDisplayMap[nodeName];

	    if (display) {
	      return display;
	    }

	    temp = doc.body.appendChild(doc.createElement(nodeName));
	    display = jQuery.css(temp, "display");
	    temp.parentNode.removeChild(temp);

	    if (display === "none") {
	      display = "block";
	    }

	    defaultDisplayMap[nodeName] = display;
	    return display;
	  }

	  function showHide(elements, show) {
	    var display,
	        elem,
	        values = [],
	        index = 0,
	        length = elements.length; // Determine new display value for elements that need to change

	    for (; index < length; index++) {
	      elem = elements[index];

	      if (!elem.style) {
	        continue;
	      }

	      display = elem.style.display;

	      if (show) {
	        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
	        // check is required in this first loop unless we have a nonempty display value (either
	        // inline or about-to-be-restored)
	        if (display === "none") {
	          values[index] = dataPriv.get(elem, "display") || null;

	          if (!values[index]) {
	            elem.style.display = "";
	          }
	        }

	        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
	          values[index] = getDefaultDisplay(elem);
	        }
	      } else {
	        if (display !== "none") {
	          values[index] = "none"; // Remember what we're overwriting

	          dataPriv.set(elem, "display", display);
	        }
	      }
	    } // Set the display of the elements in a second loop to avoid constant reflow


	    for (index = 0; index < length; index++) {
	      if (values[index] != null) {
	        elements[index].style.display = values[index];
	      }
	    }

	    return elements;
	  }

	  jQuery.fn.extend({
	    show: function () {
	      return showHide(this, true);
	    },
	    hide: function () {
	      return showHide(this);
	    },
	    toggle: function (state) {
	      if (typeof state === "boolean") {
	        return state ? this.show() : this.hide();
	      }

	      return this.each(function () {
	        if (isHiddenWithinTree(this)) {
	          jQuery(this).show();
	        } else {
	          jQuery(this).hide();
	        }
	      });
	    }
	  });
	  var rcheckableType = /^(?:checkbox|radio)$/i;
	  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
	  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

	  (function () {
	    var fragment = document.createDocumentFragment(),
	        div = fragment.appendChild(document.createElement("div")),
	        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
	    // Check state lost if the name is set (#11217)
	    // Support: Windows Web Apps (WWA)
	    // `name` and `type` must use .setAttribute for WWA (#14901)

	    input.setAttribute("type", "radio");
	    input.setAttribute("checked", "checked");
	    input.setAttribute("name", "t");
	    div.appendChild(input); // Support: Android <=4.1 only
	    // Older WebKit doesn't clone checked state correctly in fragments

	    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
	    // Make sure textarea (and checkbox) defaultValue is properly cloned

	    div.innerHTML = "<textarea>x</textarea>";
	    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
	    // IE <=9 replaces <option> tags with their contents when inserted outside of
	    // the select element.

	    div.innerHTML = "<option></option>";
	    support.option = !!div.lastChild;
	  })(); // We have to close these tags to support XHTML (#13200)


	  var wrapMap = {
	    // XHTML parsers do not magically insert elements in the
	    // same way that tag soup parsers do. So we cannot shorten
	    // this by omitting <tbody> or other required elements.
	    thead: [1, "<table>", "</table>"],
	    col: [2, "<table><colgroup>", "</colgroup></table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    _default: [0, "", ""]
	  };
	  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	  wrapMap.th = wrapMap.td; // Support: IE <=9 only

	  if (!support.option) {
	    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
	  }

	  function getAll(context, tag) {
	    // Support: IE <=9 - 11 only
	    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
	    var ret;

	    if (typeof context.getElementsByTagName !== "undefined") {
	      ret = context.getElementsByTagName(tag || "*");
	    } else if (typeof context.querySelectorAll !== "undefined") {
	      ret = context.querySelectorAll(tag || "*");
	    } else {
	      ret = [];
	    }

	    if (tag === undefined || tag && nodeName(context, tag)) {
	      return jQuery.merge([context], ret);
	    }

	    return ret;
	  } // Mark scripts as having already been evaluated


	  function setGlobalEval(elems, refElements) {
	    var i = 0,
	        l = elems.length;

	    for (; i < l; i++) {
	      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
	    }
	  }

	  var rhtml = /<|&#?\w+;/;

	  function buildFragment(elems, context, scripts, selection, ignored) {
	    var elem,
	        tmp,
	        tag,
	        wrap,
	        attached,
	        j,
	        fragment = context.createDocumentFragment(),
	        nodes = [],
	        i = 0,
	        l = elems.length;

	    for (; i < l; i++) {
	      elem = elems[i];

	      if (elem || elem === 0) {
	        // Add nodes directly
	        if (toType(elem) === "object") {
	          // Support: Android <=4.0 only, PhantomJS 1 only
	          // push.apply(_, arraylike) throws on ancient WebKit
	          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
	        } else if (!rhtml.test(elem)) {
	          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
	        } else {
	          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

	          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
	          wrap = wrapMap[tag] || wrapMap._default;
	          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

	          j = wrap[0];

	          while (j--) {
	            tmp = tmp.lastChild;
	          } // Support: Android <=4.0 only, PhantomJS 1 only
	          // push.apply(_, arraylike) throws on ancient WebKit


	          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

	          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

	          tmp.textContent = "";
	        }
	      }
	    } // Remove wrapper from fragment


	    fragment.textContent = "";
	    i = 0;

	    while (elem = nodes[i++]) {
	      // Skip elements already in the context collection (trac-4087)
	      if (selection && jQuery.inArray(elem, selection) > -1) {
	        if (ignored) {
	          ignored.push(elem);
	        }

	        continue;
	      }

	      attached = isAttached(elem); // Append to fragment

	      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

	      if (attached) {
	        setGlobalEval(tmp);
	      } // Capture executables


	      if (scripts) {
	        j = 0;

	        while (elem = tmp[j++]) {
	          if (rscriptType.test(elem.type || "")) {
	            scripts.push(elem);
	          }
	        }
	      }
	    }

	    return fragment;
	  }

	  var rkeyEvent = /^key/,
	      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	  function returnTrue() {
	    return true;
	  }

	  function returnFalse() {
	    return false;
	  } // Support: IE <=9 - 11+
	  // focus() and blur() are asynchronous, except when they are no-op.
	  // So expect focus to be synchronous when the element is already active,
	  // and blur to be synchronous when the element is not already active.
	  // (focus and blur are always synchronous in other supported browsers,
	  // this just defines when we can count on it).


	  function expectSync(elem, type) {
	    return elem === safeActiveElement() === (type === "focus");
	  } // Support: IE <=9 only
	  // Accessing document.activeElement can throw unexpectedly
	  // https://bugs.jquery.com/ticket/13393


	  function safeActiveElement() {
	    try {
	      return document.activeElement;
	    } catch (err) {}
	  }

	  function on(elem, types, selector, data, fn, one) {
	    var origFn, type; // Types can be a map of types/handlers

	    if (typeof types === "object") {
	      // ( types-Object, selector, data )
	      if (typeof selector !== "string") {
	        // ( types-Object, data )
	        data = data || selector;
	        selector = undefined;
	      }

	      for (type in types) {
	        on(elem, type, selector, data, types[type], one);
	      }

	      return elem;
	    }

	    if (data == null && fn == null) {
	      // ( types, fn )
	      fn = selector;
	      data = selector = undefined;
	    } else if (fn == null) {
	      if (typeof selector === "string") {
	        // ( types, selector, fn )
	        fn = data;
	        data = undefined;
	      } else {
	        // ( types, data, fn )
	        fn = data;
	        data = selector;
	        selector = undefined;
	      }
	    }

	    if (fn === false) {
	      fn = returnFalse;
	    } else if (!fn) {
	      return elem;
	    }

	    if (one === 1) {
	      origFn = fn;

	      fn = function (event) {
	        // Can use an empty set, since event contains the info
	        jQuery().off(event);
	        return origFn.apply(this, arguments);
	      }; // Use same guid so caller can remove using origFn


	      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
	    }

	    return elem.each(function () {
	      jQuery.event.add(this, types, fn, data, selector);
	    });
	  }
	  /*
	   * Helper functions for managing events -- not part of the public interface.
	   * Props to Dean Edwards' addEvent library for many of the ideas.
	   */


	  jQuery.event = {
	    global: {},
	    add: function (elem, types, handler, data, selector) {
	      var handleObjIn,
	          eventHandle,
	          tmp,
	          events,
	          t,
	          handleObj,
	          special,
	          handlers,
	          type,
	          namespaces,
	          origType,
	          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

	      if (!acceptData(elem)) {
	        return;
	      } // Caller can pass in an object of custom data in lieu of the handler


	      if (handler.handler) {
	        handleObjIn = handler;
	        handler = handleObjIn.handler;
	        selector = handleObjIn.selector;
	      } // Ensure that invalid selectors throw exceptions at attach time
	      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


	      if (selector) {
	        jQuery.find.matchesSelector(documentElement, selector);
	      } // Make sure that the handler has a unique ID, used to find/remove it later


	      if (!handler.guid) {
	        handler.guid = jQuery.guid++;
	      } // Init the element's event structure and main handler, if this is the first


	      if (!(events = elemData.events)) {
	        events = elemData.events = Object.create(null);
	      }

	      if (!(eventHandle = elemData.handle)) {
	        eventHandle = elemData.handle = function (e) {
	          // Discard the second event of a jQuery.event.trigger() and
	          // when an event is called after a page has unloaded
	          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
	        };
	      } // Handle multiple events separated by a space


	      types = (types || "").match(rnothtmlwhite) || [""];
	      t = types.length;

	      while (t--) {
	        tmp = rtypenamespace.exec(types[t]) || [];
	        type = origType = tmp[1];
	        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

	        if (!type) {
	          continue;
	        } // If event changes its type, use the special event handlers for the changed type


	        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

	        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

	        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

	        handleObj = jQuery.extend({
	          type: type,
	          origType: origType,
	          data: data,
	          handler: handler,
	          guid: handler.guid,
	          selector: selector,
	          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
	          namespace: namespaces.join(".")
	        }, handleObjIn); // Init the event handler queue if we're the first

	        if (!(handlers = events[type])) {
	          handlers = events[type] = [];
	          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

	          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
	            if (elem.addEventListener) {
	              elem.addEventListener(type, eventHandle);
	            }
	          }
	        }

	        if (special.add) {
	          special.add.call(elem, handleObj);

	          if (!handleObj.handler.guid) {
	            handleObj.handler.guid = handler.guid;
	          }
	        } // Add to the element's handler list, delegates in front


	        if (selector) {
	          handlers.splice(handlers.delegateCount++, 0, handleObj);
	        } else {
	          handlers.push(handleObj);
	        } // Keep track of which events have ever been used, for event optimization


	        jQuery.event.global[type] = true;
	      }
	    },
	    // Detach an event or set of events from an element
	    remove: function (elem, types, handler, selector, mappedTypes) {
	      var j,
	          origCount,
	          tmp,
	          events,
	          t,
	          handleObj,
	          special,
	          handlers,
	          type,
	          namespaces,
	          origType,
	          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

	      if (!elemData || !(events = elemData.events)) {
	        return;
	      } // Once for each type.namespace in types; type may be omitted


	      types = (types || "").match(rnothtmlwhite) || [""];
	      t = types.length;

	      while (t--) {
	        tmp = rtypenamespace.exec(types[t]) || [];
	        type = origType = tmp[1];
	        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

	        if (!type) {
	          for (type in events) {
	            jQuery.event.remove(elem, type + types[t], handler, selector, true);
	          }

	          continue;
	        }

	        special = jQuery.event.special[type] || {};
	        type = (selector ? special.delegateType : special.bindType) || type;
	        handlers = events[type] || [];
	        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

	        origCount = j = handlers.length;

	        while (j--) {
	          handleObj = handlers[j];

	          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
	            handlers.splice(j, 1);

	            if (handleObj.selector) {
	              handlers.delegateCount--;
	            }

	            if (special.remove) {
	              special.remove.call(elem, handleObj);
	            }
	          }
	        } // Remove generic event handler if we removed something and no more handlers exist
	        // (avoids potential for endless recursion during removal of special event handlers)


	        if (origCount && !handlers.length) {
	          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
	            jQuery.removeEvent(elem, type, elemData.handle);
	          }

	          delete events[type];
	        }
	      } // Remove data and the expando if it's no longer used


	      if (jQuery.isEmptyObject(events)) {
	        dataPriv.remove(elem, "handle events");
	      }
	    },
	    dispatch: function (nativeEvent) {
	      var i,
	          j,
	          ret,
	          matched,
	          handleObj,
	          handlerQueue,
	          args = new Array(arguments.length),
	          // Make a writable jQuery.Event from the native event object
	      event = jQuery.event.fix(nativeEvent),
	          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
	          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

	      args[0] = event;

	      for (i = 1; i < arguments.length; i++) {
	        args[i] = arguments[i];
	      }

	      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

	      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
	        return;
	      } // Determine handlers


	      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

	      i = 0;

	      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
	        event.currentTarget = matched.elem;
	        j = 0;

	        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
	          // If the event is namespaced, then each handler is only invoked if it is
	          // specially universal or its namespaces are a superset of the event's.
	          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
	            event.handleObj = handleObj;
	            event.data = handleObj.data;
	            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

	            if (ret !== undefined) {
	              if ((event.result = ret) === false) {
	                event.preventDefault();
	                event.stopPropagation();
	              }
	            }
	          }
	        }
	      } // Call the postDispatch hook for the mapped type


	      if (special.postDispatch) {
	        special.postDispatch.call(this, event);
	      }

	      return event.result;
	    },
	    handlers: function (event, handlers) {
	      var i,
	          handleObj,
	          sel,
	          matchedHandlers,
	          matchedSelectors,
	          handlerQueue = [],
	          delegateCount = handlers.delegateCount,
	          cur = event.target; // Find delegate handlers

	      if (delegateCount && // Support: IE <=9
	      // Black-hole SVG <use> instance trees (trac-13180)
	      cur.nodeType && // Support: Firefox <=42
	      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
	      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
	      // Support: IE 11 only
	      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
	      !(event.type === "click" && event.button >= 1)) {
	        for (; cur !== this; cur = cur.parentNode || this) {
	          // Don't check non-elements (#13208)
	          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
	          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
	            matchedHandlers = [];
	            matchedSelectors = {};

	            for (i = 0; i < delegateCount; i++) {
	              handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

	              sel = handleObj.selector + " ";

	              if (matchedSelectors[sel] === undefined) {
	                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
	              }

	              if (matchedSelectors[sel]) {
	                matchedHandlers.push(handleObj);
	              }
	            }

	            if (matchedHandlers.length) {
	              handlerQueue.push({
	                elem: cur,
	                handlers: matchedHandlers
	              });
	            }
	          }
	        }
	      } // Add the remaining (directly-bound) handlers


	      cur = this;

	      if (delegateCount < handlers.length) {
	        handlerQueue.push({
	          elem: cur,
	          handlers: handlers.slice(delegateCount)
	        });
	      }

	      return handlerQueue;
	    },
	    addProp: function (name, hook) {
	      Object.defineProperty(jQuery.Event.prototype, name, {
	        enumerable: true,
	        configurable: true,
	        get: isFunction(hook) ? function () {
	          if (this.originalEvent) {
	            return hook(this.originalEvent);
	          }
	        } : function () {
	          if (this.originalEvent) {
	            return this.originalEvent[name];
	          }
	        },
	        set: function (value) {
	          Object.defineProperty(this, name, {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: value
	          });
	        }
	      });
	    },
	    fix: function (originalEvent) {
	      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
	    },
	    special: {
	      load: {
	        // Prevent triggered image.load events from bubbling to window.load
	        noBubble: true
	      },
	      click: {
	        // Utilize native event to ensure correct state for checkable inputs
	        setup: function (data) {
	          // For mutual compressibility with _default, replace `this` access with a local var.
	          // `|| data` is dead code meant only to preserve the variable through minification.
	          var el = this || data; // Claim the first handler

	          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
	            // dataPriv.set( el, "click", ... )
	            leverageNative(el, "click", returnTrue);
	          } // Return false to allow normal processing in the caller


	          return false;
	        },
	        trigger: function (data) {
	          // For mutual compressibility with _default, replace `this` access with a local var.
	          // `|| data` is dead code meant only to preserve the variable through minification.
	          var el = this || data; // Force setup before triggering a click

	          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
	            leverageNative(el, "click");
	          } // Return non-false to allow normal event-path propagation


	          return true;
	        },
	        // For cross-browser consistency, suppress native .click() on links
	        // Also prevent it if we're currently inside a leveraged native-event stack
	        _default: function (event) {
	          var target = event.target;
	          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
	        }
	      },
	      beforeunload: {
	        postDispatch: function (event) {
	          // Support: Firefox 20+
	          // Firefox doesn't alert if the returnValue field is not set.
	          if (event.result !== undefined && event.originalEvent) {
	            event.originalEvent.returnValue = event.result;
	          }
	        }
	      }
	    }
	  }; // Ensure the presence of an event listener that handles manually-triggered
	  // synthetic events by interrupting progress until reinvoked in response to
	  // *native* events that it fires directly, ensuring that state changes have
	  // already occurred before other listeners are invoked.

	  function leverageNative(el, type, expectSync) {
	    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	    if (!expectSync) {
	      if (dataPriv.get(el, type) === undefined) {
	        jQuery.event.add(el, type, returnTrue);
	      }

	      return;
	    } // Register the controller as a special universal handler for all event namespaces


	    dataPriv.set(el, type, false);
	    jQuery.event.add(el, type, {
	      namespace: false,
	      handler: function (event) {
	        var notAsync,
	            result,
	            saved = dataPriv.get(this, type);

	        if (event.isTrigger & 1 && this[type]) {
	          // Interrupt processing of the outer synthetic .trigger()ed event
	          // Saved data should be false in such cases, but might be a leftover capture object
	          // from an async native handler (gh-4350)
	          if (!saved.length) {
	            // Store arguments for use when handling the inner native event
	            // There will always be at least one argument (an event object), so this array
	            // will not be confused with a leftover capture object.
	            saved = slice.call(arguments);
	            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
	            // Support: IE <=9 - 11+
	            // focus() and blur() are asynchronous

	            notAsync = expectSync(this, type);
	            this[type]();
	            result = dataPriv.get(this, type);

	            if (saved !== result || notAsync) {
	              dataPriv.set(this, type, false);
	            } else {
	              result = {};
	            }

	            if (saved !== result) {
	              // Cancel the outer synthetic event
	              event.stopImmediatePropagation();
	              event.preventDefault();
	              return result.value;
	            } // If this is an inner synthetic event for an event with a bubbling surrogate
	            // (focus or blur), assume that the surrogate already propagated from triggering the
	            // native event and prevent that from happening again here.
	            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
	            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
	            // less bad than duplication.

	          } else if ((jQuery.event.special[type] || {}).delegateType) {
	            event.stopPropagation();
	          } // If this is a native event triggered above, everything is now in order
	          // Fire an inner synthetic event with the original arguments

	        } else if (saved.length) {
	          // ...and capture the result
	          dataPriv.set(this, type, {
	            value: jQuery.event.trigger( // Support: IE <=9 - 11+
	            // Extend with the prototype to reset the above stopImmediatePropagation()
	            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
	          }); // Abort handling of the native event

	          event.stopImmediatePropagation();
	        }
	      }
	    });
	  }

	  jQuery.removeEvent = function (elem, type, handle) {
	    // This "if" is needed for plain objects
	    if (elem.removeEventListener) {
	      elem.removeEventListener(type, handle);
	    }
	  };

	  jQuery.Event = function (src, props) {
	    // Allow instantiation without the 'new' keyword
	    if (!(this instanceof jQuery.Event)) {
	      return new jQuery.Event(src, props);
	    } // Event object


	    if (src && src.type) {
	      this.originalEvent = src;
	      this.type = src.type; // Events bubbling up the document may have been marked as prevented
	      // by a handler lower down the tree; reflect the correct value.

	      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
	      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
	      // Support: Safari <=6 - 7 only
	      // Target should not be a text node (#504, #13143)

	      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
	      this.currentTarget = src.currentTarget;
	      this.relatedTarget = src.relatedTarget; // Event type
	    } else {
	      this.type = src;
	    } // Put explicitly provided properties onto the event object


	    if (props) {
	      jQuery.extend(this, props);
	    } // Create a timestamp if incoming event doesn't have one


	    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

	    this[jQuery.expando] = true;
	  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


	  jQuery.Event.prototype = {
	    constructor: jQuery.Event,
	    isDefaultPrevented: returnFalse,
	    isPropagationStopped: returnFalse,
	    isImmediatePropagationStopped: returnFalse,
	    isSimulated: false,
	    preventDefault: function () {
	      var e = this.originalEvent;
	      this.isDefaultPrevented = returnTrue;

	      if (e && !this.isSimulated) {
	        e.preventDefault();
	      }
	    },
	    stopPropagation: function () {
	      var e = this.originalEvent;
	      this.isPropagationStopped = returnTrue;

	      if (e && !this.isSimulated) {
	        e.stopPropagation();
	      }
	    },
	    stopImmediatePropagation: function () {
	      var e = this.originalEvent;
	      this.isImmediatePropagationStopped = returnTrue;

	      if (e && !this.isSimulated) {
	        e.stopImmediatePropagation();
	      }

	      this.stopPropagation();
	    }
	  }; // Includes all common event props including KeyEvent and MouseEvent specific props

	  jQuery.each({
	    altKey: true,
	    bubbles: true,
	    cancelable: true,
	    changedTouches: true,
	    ctrlKey: true,
	    detail: true,
	    eventPhase: true,
	    metaKey: true,
	    pageX: true,
	    pageY: true,
	    shiftKey: true,
	    view: true,
	    "char": true,
	    code: true,
	    charCode: true,
	    key: true,
	    keyCode: true,
	    button: true,
	    buttons: true,
	    clientX: true,
	    clientY: true,
	    offsetX: true,
	    offsetY: true,
	    pointerId: true,
	    pointerType: true,
	    screenX: true,
	    screenY: true,
	    targetTouches: true,
	    toElement: true,
	    touches: true,
	    which: function (event) {
	      var button = event.button; // Add which for key events

	      if (event.which == null && rkeyEvent.test(event.type)) {
	        return event.charCode != null ? event.charCode : event.keyCode;
	      } // Add which for click: 1 === left; 2 === middle; 3 === right


	      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
	        if (button & 1) {
	          return 1;
	        }

	        if (button & 2) {
	          return 3;
	        }

	        if (button & 4) {
	          return 2;
	        }

	        return 0;
	      }

	      return event.which;
	    }
	  }, jQuery.event.addProp);
	  jQuery.each({
	    focus: "focusin",
	    blur: "focusout"
	  }, function (type, delegateType) {
	    jQuery.event.special[type] = {
	      // Utilize native event if possible so blur/focus sequence is correct
	      setup: function () {
	        // Claim the first handler
	        // dataPriv.set( this, "focus", ... )
	        // dataPriv.set( this, "blur", ... )
	        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

	        return false;
	      },
	      trigger: function () {
	        // Force setup before trigger
	        leverageNative(this, type); // Return non-false to allow normal event-path propagation

	        return true;
	      },
	      delegateType: delegateType
	    };
	  }); // Create mouseenter/leave events using mouseover/out and event-time checks
	  // so that event delegation works in jQuery.
	  // Do the same for pointerenter/pointerleave and pointerover/pointerout
	  //
	  // Support: Safari 7 only
	  // Safari sends mouseenter too often; see:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	  // for the description of the bug (it existed in older Chrome versions as well).

	  jQuery.each({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout",
	    pointerenter: "pointerover",
	    pointerleave: "pointerout"
	  }, function (orig, fix) {
	    jQuery.event.special[orig] = {
	      delegateType: fix,
	      bindType: fix,
	      handle: function (event) {
	        var ret,
	            target = this,
	            related = event.relatedTarget,
	            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
	        // NB: No relatedTarget if the mouse left/entered the browser window

	        if (!related || related !== target && !jQuery.contains(target, related)) {
	          event.type = handleObj.origType;
	          ret = handleObj.handler.apply(this, arguments);
	          event.type = fix;
	        }

	        return ret;
	      }
	    };
	  });
	  jQuery.fn.extend({
	    on: function (types, selector, data, fn) {
	      return on(this, types, selector, data, fn);
	    },
	    one: function (types, selector, data, fn) {
	      return on(this, types, selector, data, fn, 1);
	    },
	    off: function (types, selector, fn) {
	      var handleObj, type;

	      if (types && types.preventDefault && types.handleObj) {
	        // ( event )  dispatched jQuery.Event
	        handleObj = types.handleObj;
	        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
	        return this;
	      }

	      if (typeof types === "object") {
	        // ( types-object [, selector] )
	        for (type in types) {
	          this.off(type, selector, types[type]);
	        }

	        return this;
	      }

	      if (selector === false || typeof selector === "function") {
	        // ( types [, fn] )
	        fn = selector;
	        selector = undefined;
	      }

	      if (fn === false) {
	        fn = returnFalse;
	      }

	      return this.each(function () {
	        jQuery.event.remove(this, types, fn, selector);
	      });
	    }
	  });
	  var // Support: IE <=10 - 11, Edge 12 - 13 only
	  // In IE/Edge using regex groups here causes severe slowdowns.
	  // See https://connect.microsoft.com/IE/feedback/details/1736512/
	  rnoInnerhtml = /<script|<style|<link/i,
	      // checked="checked" or checked
	  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

	  function manipulationTarget(elem, content) {
	    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
	      return jQuery(elem).children("tbody")[0] || elem;
	    }

	    return elem;
	  } // Replace/restore the type attribute of script elements for safe DOM manipulation


	  function disableScript(elem) {
	    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	    return elem;
	  }

	  function restoreScript(elem) {
	    if ((elem.type || "").slice(0, 5) === "true/") {
	      elem.type = elem.type.slice(5);
	    } else {
	      elem.removeAttribute("type");
	    }

	    return elem;
	  }

	  function cloneCopyEvent(src, dest) {
	    var i, l, type, pdataOld, udataOld, udataCur, events;

	    if (dest.nodeType !== 1) {
	      return;
	    } // 1. Copy private data: events, handlers, etc.


	    if (dataPriv.hasData(src)) {
	      pdataOld = dataPriv.get(src);
	      events = pdataOld.events;

	      if (events) {
	        dataPriv.remove(dest, "handle events");

	        for (type in events) {
	          for (i = 0, l = events[type].length; i < l; i++) {
	            jQuery.event.add(dest, type, events[type][i]);
	          }
	        }
	      }
	    } // 2. Copy user data


	    if (dataUser.hasData(src)) {
	      udataOld = dataUser.access(src);
	      udataCur = jQuery.extend({}, udataOld);
	      dataUser.set(dest, udataCur);
	    }
	  } // Fix IE bugs, see support tests


	  function fixInput(src, dest) {
	    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

	    if (nodeName === "input" && rcheckableType.test(src.type)) {
	      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
	    } else if (nodeName === "input" || nodeName === "textarea") {
	      dest.defaultValue = src.defaultValue;
	    }
	  }

	  function domManip(collection, args, callback, ignored) {
	    // Flatten any nested arrays
	    args = flat(args);
	    var fragment,
	        first,
	        scripts,
	        hasScripts,
	        node,
	        doc,
	        i = 0,
	        l = collection.length,
	        iNoClone = l - 1,
	        value = args[0],
	        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

	    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
	      return collection.each(function (index) {
	        var self = collection.eq(index);

	        if (valueIsFunction) {
	          args[0] = value.call(this, index, self.html());
	        }

	        domManip(self, args, callback, ignored);
	      });
	    }

	    if (l) {
	      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
	      first = fragment.firstChild;

	      if (fragment.childNodes.length === 1) {
	        fragment = first;
	      } // Require either new content or an interest in ignored elements to invoke the callback


	      if (first || ignored) {
	        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
	        hasScripts = scripts.length; // Use the original fragment for the last item
	        // instead of the first because it can end up
	        // being emptied incorrectly in certain situations (#8070).

	        for (; i < l; i++) {
	          node = fragment;

	          if (i !== iNoClone) {
	            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

	            if (hasScripts) {
	              // Support: Android <=4.0 only, PhantomJS 1 only
	              // push.apply(_, arraylike) throws on ancient WebKit
	              jQuery.merge(scripts, getAll(node, "script"));
	            }
	          }

	          callback.call(collection[i], node, i);
	        }

	        if (hasScripts) {
	          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

	          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

	          for (i = 0; i < hasScripts; i++) {
	            node = scripts[i];

	            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
	              if (node.src && (node.type || "").toLowerCase() !== "module") {
	                // Optional AJAX dependency, but won't run scripts if not present
	                if (jQuery._evalUrl && !node.noModule) {
	                  jQuery._evalUrl(node.src, {
	                    nonce: node.nonce || node.getAttribute("nonce")
	                  }, doc);
	                }
	              } else {
	                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
	              }
	            }
	          }
	        }
	      }
	    }

	    return collection;
	  }

	  function remove(elem, selector, keepData) {
	    var node,
	        nodes = selector ? jQuery.filter(selector, elem) : elem,
	        i = 0;

	    for (; (node = nodes[i]) != null; i++) {
	      if (!keepData && node.nodeType === 1) {
	        jQuery.cleanData(getAll(node));
	      }

	      if (node.parentNode) {
	        if (keepData && isAttached(node)) {
	          setGlobalEval(getAll(node, "script"));
	        }

	        node.parentNode.removeChild(node);
	      }
	    }

	    return elem;
	  }

	  jQuery.extend({
	    htmlPrefilter: function (html) {
	      return html;
	    },
	    clone: function (elem, dataAndEvents, deepDataAndEvents) {
	      var i,
	          l,
	          srcElements,
	          destElements,
	          clone = elem.cloneNode(true),
	          inPage = isAttached(elem); // Fix IE cloning issues

	      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
	        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
	        destElements = getAll(clone);
	        srcElements = getAll(elem);

	        for (i = 0, l = srcElements.length; i < l; i++) {
	          fixInput(srcElements[i], destElements[i]);
	        }
	      } // Copy the events from the original to the clone


	      if (dataAndEvents) {
	        if (deepDataAndEvents) {
	          srcElements = srcElements || getAll(elem);
	          destElements = destElements || getAll(clone);

	          for (i = 0, l = srcElements.length; i < l; i++) {
	            cloneCopyEvent(srcElements[i], destElements[i]);
	          }
	        } else {
	          cloneCopyEvent(elem, clone);
	        }
	      } // Preserve script evaluation history


	      destElements = getAll(clone, "script");

	      if (destElements.length > 0) {
	        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
	      } // Return the cloned set


	      return clone;
	    },
	    cleanData: function (elems) {
	      var data,
	          elem,
	          type,
	          special = jQuery.event.special,
	          i = 0;

	      for (; (elem = elems[i]) !== undefined; i++) {
	        if (acceptData(elem)) {
	          if (data = elem[dataPriv.expando]) {
	            if (data.events) {
	              for (type in data.events) {
	                if (special[type]) {
	                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
	                } else {
	                  jQuery.removeEvent(elem, type, data.handle);
	                }
	              }
	            } // Support: Chrome <=35 - 45+
	            // Assign undefined instead of using delete, see Data#remove


	            elem[dataPriv.expando] = undefined;
	          }

	          if (elem[dataUser.expando]) {
	            // Support: Chrome <=35 - 45+
	            // Assign undefined instead of using delete, see Data#remove
	            elem[dataUser.expando] = undefined;
	          }
	        }
	      }
	    }
	  });
	  jQuery.fn.extend({
	    detach: function (selector) {
	      return remove(this, selector, true);
	    },
	    remove: function (selector) {
	      return remove(this, selector);
	    },
	    text: function (value) {
	      return access(this, function (value) {
	        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
	          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	            this.textContent = value;
	          }
	        });
	      }, null, value, arguments.length);
	    },
	    append: function () {
	      return domManip(this, arguments, function (elem) {
	        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	          var target = manipulationTarget(this, elem);
	          target.appendChild(elem);
	        }
	      });
	    },
	    prepend: function () {
	      return domManip(this, arguments, function (elem) {
	        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	          var target = manipulationTarget(this, elem);
	          target.insertBefore(elem, target.firstChild);
	        }
	      });
	    },
	    before: function () {
	      return domManip(this, arguments, function (elem) {
	        if (this.parentNode) {
	          this.parentNode.insertBefore(elem, this);
	        }
	      });
	    },
	    after: function () {
	      return domManip(this, arguments, function (elem) {
	        if (this.parentNode) {
	          this.parentNode.insertBefore(elem, this.nextSibling);
	        }
	      });
	    },
	    empty: function () {
	      var elem,
	          i = 0;

	      for (; (elem = this[i]) != null; i++) {
	        if (elem.nodeType === 1) {
	          // Prevent memory leaks
	          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

	          elem.textContent = "";
	        }
	      }

	      return this;
	    },
	    clone: function (dataAndEvents, deepDataAndEvents) {
	      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
	      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	      return this.map(function () {
	        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
	      });
	    },
	    html: function (value) {
	      return access(this, function (value) {
	        var elem = this[0] || {},
	            i = 0,
	            l = this.length;

	        if (value === undefined && elem.nodeType === 1) {
	          return elem.innerHTML;
	        } // See if we can take a shortcut and just use innerHTML


	        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
	          value = jQuery.htmlPrefilter(value);

	          try {
	            for (; i < l; i++) {
	              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

	              if (elem.nodeType === 1) {
	                jQuery.cleanData(getAll(elem, false));
	                elem.innerHTML = value;
	              }
	            }

	            elem = 0; // If using innerHTML throws an exception, use the fallback method
	          } catch (e) {}
	        }

	        if (elem) {
	          this.empty().append(value);
	        }
	      }, null, value, arguments.length);
	    },
	    replaceWith: function () {
	      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

	      return domManip(this, arguments, function (elem) {
	        var parent = this.parentNode;

	        if (jQuery.inArray(this, ignored) < 0) {
	          jQuery.cleanData(getAll(this));

	          if (parent) {
	            parent.replaceChild(elem, this);
	          }
	        } // Force callback invocation

	      }, ignored);
	    }
	  });
	  jQuery.each({
	    appendTo: "append",
	    prependTo: "prepend",
	    insertBefore: "before",
	    insertAfter: "after",
	    replaceAll: "replaceWith"
	  }, function (name, original) {
	    jQuery.fn[name] = function (selector) {
	      var elems,
	          ret = [],
	          insert = jQuery(selector),
	          last = insert.length - 1,
	          i = 0;

	      for (; i <= last; i++) {
	        elems = i === last ? this : this.clone(true);
	        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
	        // .get() because push.apply(_, arraylike) throws on ancient WebKit

	        push.apply(ret, elems.get());
	      }

	      return this.pushStack(ret);
	    };
	  });
	  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	  var getStyles = function (elem) {
	    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
	    // IE throws on elements created in popups
	    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
	    var view = elem.ownerDocument.defaultView;

	    if (!view || !view.opener) {
	      view = window;
	    }

	    return view.getComputedStyle(elem);
	  };

	  var swap = function (elem, options, callback) {
	    var ret,
	        name,
	        old = {}; // Remember the old values, and insert the new ones

	    for (name in options) {
	      old[name] = elem.style[name];
	      elem.style[name] = options[name];
	    }

	    ret = callback.call(elem); // Revert the old values

	    for (name in options) {
	      elem.style[name] = old[name];
	    }

	    return ret;
	  };

	  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

	  (function () {
	    // Executing both pixelPosition & boxSizingReliable tests require only one layout
	    // so they're executed at the same time to save the second computation.
	    function computeStyleTests() {
	      // This is a singleton, we need to execute it only once
	      if (!div) {
	        return;
	      }

	      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
	      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
	      documentElement.appendChild(container).appendChild(div);
	      var divStyle = window.getComputedStyle(div);
	      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

	      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
	      // Some styles come back with percentage values, even though they shouldn't

	      div.style.right = "60%";
	      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
	      // Detect misreporting of content dimensions for box-sizing:border-box elements

	      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
	      // Detect overflow:scroll screwiness (gh-3699)
	      // Support: Chrome <=64
	      // Don't get tricked when zoom affects offsetWidth (gh-4029)

	      div.style.position = "absolute";
	      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
	      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
	      // it will also be a sign that checks already performed

	      div = null;
	    }

	    function roundPixelMeasures(measure) {
	      return Math.round(parseFloat(measure));
	    }

	    var pixelPositionVal,
	        boxSizingReliableVal,
	        scrollboxSizeVal,
	        pixelBoxStylesVal,
	        reliableTrDimensionsVal,
	        reliableMarginLeftVal,
	        container = document.createElement("div"),
	        div = document.createElement("div"); // Finish early in limited (non-browser) environments

	    if (!div.style) {
	      return;
	    } // Support: IE <=9 - 11 only
	    // Style of cloned element affects source element cloned (#8908)


	    div.style.backgroundClip = "content-box";
	    div.cloneNode(true).style.backgroundClip = "";
	    support.clearCloneStyle = div.style.backgroundClip === "content-box";
	    jQuery.extend(support, {
	      boxSizingReliable: function () {
	        computeStyleTests();
	        return boxSizingReliableVal;
	      },
	      pixelBoxStyles: function () {
	        computeStyleTests();
	        return pixelBoxStylesVal;
	      },
	      pixelPosition: function () {
	        computeStyleTests();
	        return pixelPositionVal;
	      },
	      reliableMarginLeft: function () {
	        computeStyleTests();
	        return reliableMarginLeftVal;
	      },
	      scrollboxSize: function () {
	        computeStyleTests();
	        return scrollboxSizeVal;
	      },
	      // Support: IE 9 - 11+, Edge 15 - 18+
	      // IE/Edge misreport `getComputedStyle` of table rows with width/height
	      // set in CSS while `offset*` properties report correct values.
	      // Behavior in IE 9 is more subtle than in newer versions & it passes
	      // some versions of this test; make sure not to make it pass there!
	      reliableTrDimensions: function () {
	        var table, tr, trChild, trStyle;

	        if (reliableTrDimensionsVal == null) {
	          table = document.createElement("table");
	          tr = document.createElement("tr");
	          trChild = document.createElement("div");
	          table.style.cssText = "position:absolute;left:-11111px";
	          tr.style.height = "1px";
	          trChild.style.height = "9px";
	          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
	          trStyle = window.getComputedStyle(tr);
	          reliableTrDimensionsVal = parseInt(trStyle.height) > 3;
	          documentElement.removeChild(table);
	        }

	        return reliableTrDimensionsVal;
	      }
	    });
	  })();

	  function curCSS(elem, name, computed) {
	    var width,
	        minWidth,
	        maxWidth,
	        ret,
	        // Support: Firefox 51+
	    // Retrieving style before computed somehow
	    // fixes an issue with getting wrong values
	    // on detached elements
	    style = elem.style;
	    computed = computed || getStyles(elem); // getPropertyValue is needed for:
	    //   .css('filter') (IE 9 only, #12537)
	    //   .css('--customProperty) (#3144)

	    if (computed) {
	      ret = computed.getPropertyValue(name) || computed[name];

	      if (ret === "" && !isAttached(elem)) {
	        ret = jQuery.style(elem, name);
	      } // A tribute to the "awesome hack by Dean Edwards"
	      // Android Browser returns percentage for some values,
	      // but width seems to be reliably pixels.
	      // This is against the CSSOM draft spec:
	      // https://drafts.csswg.org/cssom/#resolved-values


	      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
	        // Remember the original values
	        width = style.width;
	        minWidth = style.minWidth;
	        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

	        style.minWidth = style.maxWidth = style.width = ret;
	        ret = computed.width; // Revert the changed values

	        style.width = width;
	        style.minWidth = minWidth;
	        style.maxWidth = maxWidth;
	      }
	    }

	    return ret !== undefined ? // Support: IE <=9 - 11 only
	    // IE returns zIndex value as an integer.
	    ret + "" : ret;
	  }

	  function addGetHookIf(conditionFn, hookFn) {
	    // Define the hook, we'll check on the first run if it's really needed.
	    return {
	      get: function () {
	        if (conditionFn()) {
	          // Hook not needed (or it's not possible to use it due
	          // to missing dependency), remove it.
	          delete this.get;
	          return;
	        } // Hook needed; redefine it so that the support test is not executed again.


	        return (this.get = hookFn).apply(this, arguments);
	      }
	    };
	  }

	  var cssPrefixes = ["Webkit", "Moz", "ms"],
	      emptyStyle = document.createElement("div").style,
	      vendorProps = {}; // Return a vendor-prefixed property or undefined

	  function vendorPropName(name) {
	    // Check for vendor prefixed names
	    var capName = name[0].toUpperCase() + name.slice(1),
	        i = cssPrefixes.length;

	    while (i--) {
	      name = cssPrefixes[i] + capName;

	      if (name in emptyStyle) {
	        return name;
	      }
	    }
	  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


	  function finalPropName(name) {
	    var final = jQuery.cssProps[name] || vendorProps[name];

	    if (final) {
	      return final;
	    }

	    if (name in emptyStyle) {
	      return name;
	    }

	    return vendorProps[name] = vendorPropName(name) || name;
	  }

	  var // Swappable if display is none or starts with table
	  // except "table", "table-cell", or "table-caption"
	  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	      rcustomProp = /^--/,
	      cssShow = {
	    position: "absolute",
	    visibility: "hidden",
	    display: "block"
	  },
	      cssNormalTransform = {
	    letterSpacing: "0",
	    fontWeight: "400"
	  };

	  function setPositiveNumber(_elem, value, subtract) {
	    // Any relative (+/-) values have already been
	    // normalized at this point
	    var matches = rcssNum.exec(value);
	    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
	    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	  }

	  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
	    var i = dimension === "width" ? 1 : 0,
	        extra = 0,
	        delta = 0; // Adjustment may not be necessary

	    if (box === (isBorderBox ? "border" : "content")) {
	      return 0;
	    }

	    for (; i < 4; i += 2) {
	      // Both box models exclude margin
	      if (box === "margin") {
	        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
	      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


	      if (!isBorderBox) {
	        // Add padding
	        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

	        if (box !== "padding") {
	          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
	        } else {
	          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
	        // "padding" or "margin"

	      } else {
	        // For "content", subtract padding
	        if (box === "content") {
	          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
	        } // For "content" or "padding", subtract border


	        if (box !== "margin") {
	          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	        }
	      }
	    } // Account for positive content-box scroll gutter when requested by providing computedVal


	    if (!isBorderBox && computedVal >= 0) {
	      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
	      // Assuming integer scroll gutter, subtract the rest and round down
	      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
	      // Use an explicit zero to avoid NaN (gh-3964)
	      )) || 0;
	    }

	    return delta;
	  }

	  function getWidthOrHeight(elem, dimension, extra) {
	    // Start with computed style
	    var styles = getStyles(elem),
	        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
	    // Fake content-box until we know it's needed to know the true value.
	    boxSizingNeeded = !support.boxSizingReliable() || extra,
	        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
	        valueIsBorderBox = isBorderBox,
	        val = curCSS(elem, dimension, styles),
	        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
	    // Return a confounding non-pixel value or feign ignorance, as appropriate.

	    if (rnumnonpx.test(val)) {
	      if (!extra) {
	        return val;
	      }

	      val = "auto";
	    } // Support: IE 9 - 11 only
	    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
	    // In those cases, the computed value can be trusted to be border-box.


	    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
	    // IE/Edge misreport `getComputedStyle` of table rows with width/height
	    // set in CSS while `offset*` properties report correct values.
	    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
	    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
	    // This happens for inline elements with no explicit setting (gh-3571)
	    val === "auto" || // Support: Android <=4.1 - 4.3 only
	    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
	    elem.getClientRects().length) {
	      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
	      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
	      // retrieved value as a content box dimension.

	      valueIsBorderBox = offsetProp in elem;

	      if (valueIsBorderBox) {
	        val = elem[offsetProp];
	      }
	    } // Normalize "" and auto


	    val = parseFloat(val) || 0; // Adjust for the element's box model

	    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
	    val) + "px";
	  }

	  jQuery.extend({
	    // Add in style property hooks for overriding the default
	    // behavior of getting and setting a style property
	    cssHooks: {
	      opacity: {
	        get: function (elem, computed) {
	          if (computed) {
	            // We should always get a number back from opacity
	            var ret = curCSS(elem, "opacity");
	            return ret === "" ? "1" : ret;
	          }
	        }
	      }
	    },
	    // Don't automatically add "px" to these possibly-unitless properties
	    cssNumber: {
	      "animationIterationCount": true,
	      "columnCount": true,
	      "fillOpacity": true,
	      "flexGrow": true,
	      "flexShrink": true,
	      "fontWeight": true,
	      "gridArea": true,
	      "gridColumn": true,
	      "gridColumnEnd": true,
	      "gridColumnStart": true,
	      "gridRow": true,
	      "gridRowEnd": true,
	      "gridRowStart": true,
	      "lineHeight": true,
	      "opacity": true,
	      "order": true,
	      "orphans": true,
	      "widows": true,
	      "zIndex": true,
	      "zoom": true
	    },
	    // Add in properties whose names you wish to fix before
	    // setting or getting the value
	    cssProps: {},
	    // Get and set the style property on a DOM Node
	    style: function (elem, name, value, extra) {
	      // Don't set styles on text and comment nodes
	      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
	        return;
	      } // Make sure that we're working with the right name


	      var ret,
	          type,
	          hooks,
	          origName = camelCase(name),
	          isCustomProp = rcustomProp.test(name),
	          style = elem.style; // Make sure that we're working with the right name. We don't
	      // want to query the value if it is a CSS custom property
	      // since they are user-defined.

	      if (!isCustomProp) {
	        name = finalPropName(origName);
	      } // Gets hook for the prefixed version, then unprefixed version


	      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

	      if (value !== undefined) {
	        type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

	        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
	          value = adjustCSS(elem, name, ret); // Fixes bug #9237

	          type = "number";
	        } // Make sure that null and NaN values aren't set (#7116)


	        if (value == null || value !== value) {
	          return;
	        } // If a number was passed in, add the unit (except for certain CSS properties)
	        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
	        // "px" to a few hardcoded values.


	        if (type === "number" && !isCustomProp) {
	          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
	        } // background-* props affect original clone's values


	        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
	          style[name] = "inherit";
	        } // If a hook was provided, use that value, otherwise just set the specified value


	        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
	          if (isCustomProp) {
	            style.setProperty(name, value);
	          } else {
	            style[name] = value;
	          }
	        }
	      } else {
	        // If a hook was provided get the non-computed value from there
	        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
	          return ret;
	        } // Otherwise just get the value from the style object


	        return style[name];
	      }
	    },
	    css: function (elem, name, extra, styles) {
	      var val,
	          num,
	          hooks,
	          origName = camelCase(name),
	          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
	      // want to modify the value if it is a CSS custom property
	      // since they are user-defined.

	      if (!isCustomProp) {
	        name = finalPropName(origName);
	      } // Try prefixed name followed by the unprefixed name


	      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

	      if (hooks && "get" in hooks) {
	        val = hooks.get(elem, true, extra);
	      } // Otherwise, if a way to get the computed value exists, use that


	      if (val === undefined) {
	        val = curCSS(elem, name, styles);
	      } // Convert "normal" to computed value


	      if (val === "normal" && name in cssNormalTransform) {
	        val = cssNormalTransform[name];
	      } // Make numeric if forced or a qualifier was provided and val looks numeric


	      if (extra === "" || extra) {
	        num = parseFloat(val);
	        return extra === true || isFinite(num) ? num || 0 : val;
	      }

	      return val;
	    }
	  });
	  jQuery.each(["height", "width"], function (_i, dimension) {
	    jQuery.cssHooks[dimension] = {
	      get: function (elem, computed, extra) {
	        if (computed) {
	          // Certain elements can have dimension info if we invisibly show them
	          // but it must have a current display style that would benefit
	          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
	          // Table columns in Safari have non-zero offsetWidth & zero
	          // getBoundingClientRect().width unless display is changed.
	          // Support: IE <=11 only
	          // Running getBoundingClientRect on a disconnected node
	          // in IE throws an error.
	          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
	            return getWidthOrHeight(elem, dimension, extra);
	          }) : getWidthOrHeight(elem, dimension, extra);
	        }
	      },
	      set: function (elem, value, extra) {
	        var matches,
	            styles = getStyles(elem),
	            // Only read styles.position if the test has a chance to fail
	        // to avoid forcing a reflow.
	        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
	            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
	        boxSizingNeeded = scrollboxSizeBuggy || extra,
	            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
	            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
	        // faking a content-box to get border and padding (gh-3699)

	        if (isBorderBox && scrollboxSizeBuggy) {
	          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
	        } // Convert to pixels if value adjustment is needed


	        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
	          elem.style[dimension] = value;
	          value = jQuery.css(elem, dimension);
	        }

	        return setPositiveNumber(elem, value, subtract);
	      }
	    };
	  });
	  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
	    if (computed) {
	      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
	        marginLeft: 0
	      }, function () {
	        return elem.getBoundingClientRect().left;
	      })) + "px";
	    }
	  }); // These hooks are used by animate to expand properties

	  jQuery.each({
	    margin: "",
	    padding: "",
	    border: "Width"
	  }, function (prefix, suffix) {
	    jQuery.cssHooks[prefix + suffix] = {
	      expand: function (value) {
	        var i = 0,
	            expanded = {},
	            // Assumes a single number if not a string
	        parts = typeof value === "string" ? value.split(" ") : [value];

	        for (; i < 4; i++) {
	          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
	        }

	        return expanded;
	      }
	    };

	    if (prefix !== "margin") {
	      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
	    }
	  });
	  jQuery.fn.extend({
	    css: function (name, value) {
	      return access(this, function (elem, name, value) {
	        var styles,
	            len,
	            map = {},
	            i = 0;

	        if (Array.isArray(name)) {
	          styles = getStyles(elem);
	          len = name.length;

	          for (; i < len; i++) {
	            map[name[i]] = jQuery.css(elem, name[i], false, styles);
	          }

	          return map;
	        }

	        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
	      }, name, value, arguments.length > 1);
	    }
	  });

	  function Tween(elem, options, prop, end, easing) {
	    return new Tween.prototype.init(elem, options, prop, end, easing);
	  }

	  jQuery.Tween = Tween;
	  Tween.prototype = {
	    constructor: Tween,
	    init: function (elem, options, prop, end, easing, unit) {
	      this.elem = elem;
	      this.prop = prop;
	      this.easing = easing || jQuery.easing._default;
	      this.options = options;
	      this.start = this.now = this.cur();
	      this.end = end;
	      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
	    },
	    cur: function () {
	      var hooks = Tween.propHooks[this.prop];
	      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
	    },
	    run: function (percent) {
	      var eased,
	          hooks = Tween.propHooks[this.prop];

	      if (this.options.duration) {
	        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
	      } else {
	        this.pos = eased = percent;
	      }

	      this.now = (this.end - this.start) * eased + this.start;

	      if (this.options.step) {
	        this.options.step.call(this.elem, this.now, this);
	      }

	      if (hooks && hooks.set) {
	        hooks.set(this);
	      } else {
	        Tween.propHooks._default.set(this);
	      }

	      return this;
	    }
	  };
	  Tween.prototype.init.prototype = Tween.prototype;
	  Tween.propHooks = {
	    _default: {
	      get: function (tween) {
	        var result; // Use a property on the element directly when it is not a DOM element,
	        // or when there is no matching style property that exists.

	        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
	          return tween.elem[tween.prop];
	        } // Passing an empty string as a 3rd parameter to .css will automatically
	        // attempt a parseFloat and fallback to a string if the parse fails.
	        // Simple values such as "10px" are parsed to Float;
	        // complex values such as "rotate(1rad)" are returned as-is.


	        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

	        return !result || result === "auto" ? 0 : result;
	      },
	      set: function (tween) {
	        // Use step hook for back compat.
	        // Use cssHook if its there.
	        // Use .style if available and use plain properties where available.
	        if (jQuery.fx.step[tween.prop]) {
	          jQuery.fx.step[tween.prop](tween);
	        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
	          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
	        } else {
	          tween.elem[tween.prop] = tween.now;
	        }
	      }
	    }
	  }; // Support: IE <=9 only
	  // Panic based approach to setting things on disconnected nodes

	  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	    set: function (tween) {
	      if (tween.elem.nodeType && tween.elem.parentNode) {
	        tween.elem[tween.prop] = tween.now;
	      }
	    }
	  };
	  jQuery.easing = {
	    linear: function (p) {
	      return p;
	    },
	    swing: function (p) {
	      return 0.5 - Math.cos(p * Math.PI) / 2;
	    },
	    _default: "swing"
	  };
	  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

	  jQuery.fx.step = {};
	  var fxNow,
	      inProgress,
	      rfxtypes = /^(?:toggle|show|hide)$/,
	      rrun = /queueHooks$/;

	  function schedule() {
	    if (inProgress) {
	      if (document.hidden === false && window.requestAnimationFrame) {
	        window.requestAnimationFrame(schedule);
	      } else {
	        window.setTimeout(schedule, jQuery.fx.interval);
	      }

	      jQuery.fx.tick();
	    }
	  } // Animations created synchronously will run synchronously


	  function createFxNow() {
	    window.setTimeout(function () {
	      fxNow = undefined;
	    });
	    return fxNow = Date.now();
	  } // Generate parameters to create a standard animation


	  function genFx(type, includeWidth) {
	    var which,
	        i = 0,
	        attrs = {
	      height: type
	    }; // If we include width, step value is 1 to do all cssExpand values,
	    // otherwise step value is 2 to skip over Left and Right

	    includeWidth = includeWidth ? 1 : 0;

	    for (; i < 4; i += 2 - includeWidth) {
	      which = cssExpand[i];
	      attrs["margin" + which] = attrs["padding" + which] = type;
	    }

	    if (includeWidth) {
	      attrs.opacity = attrs.width = type;
	    }

	    return attrs;
	  }

	  function createTween(value, prop, animation) {
	    var tween,
	        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
	        index = 0,
	        length = collection.length;

	    for (; index < length; index++) {
	      if (tween = collection[index].call(animation, prop, value)) {
	        // We're done with this property
	        return tween;
	      }
	    }
	  }

	  function defaultPrefilter(elem, props, opts) {
	    var prop,
	        value,
	        toggle,
	        hooks,
	        oldfire,
	        propTween,
	        restoreDisplay,
	        display,
	        isBox = "width" in props || "height" in props,
	        anim = this,
	        orig = {},
	        style = elem.style,
	        hidden = elem.nodeType && isHiddenWithinTree(elem),
	        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

	    if (!opts.queue) {
	      hooks = jQuery._queueHooks(elem, "fx");

	      if (hooks.unqueued == null) {
	        hooks.unqueued = 0;
	        oldfire = hooks.empty.fire;

	        hooks.empty.fire = function () {
	          if (!hooks.unqueued) {
	            oldfire();
	          }
	        };
	      }

	      hooks.unqueued++;
	      anim.always(function () {
	        // Ensure the complete handler is called before this completes
	        anim.always(function () {
	          hooks.unqueued--;

	          if (!jQuery.queue(elem, "fx").length) {
	            hooks.empty.fire();
	          }
	        });
	      });
	    } // Detect show/hide animations


	    for (prop in props) {
	      value = props[prop];

	      if (rfxtypes.test(value)) {
	        delete props[prop];
	        toggle = toggle || value === "toggle";

	        if (value === (hidden ? "hide" : "show")) {
	          // Pretend to be hidden if this is a "show" and
	          // there is still data from a stopped show/hide
	          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
	            hidden = true; // Ignore all other no-op show/hide data
	          } else {
	            continue;
	          }
	        }

	        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
	      }
	    } // Bail out if this is a no-op like .hide().hide()


	    propTween = !jQuery.isEmptyObject(props);

	    if (!propTween && jQuery.isEmptyObject(orig)) {
	      return;
	    } // Restrict "overflow" and "display" styles during box animations


	    if (isBox && elem.nodeType === 1) {
	      // Support: IE <=9 - 11, Edge 12 - 15
	      // Record all 3 overflow attributes because IE does not infer the shorthand
	      // from identically-valued overflowX and overflowY and Edge just mirrors
	      // the overflowX value there.
	      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

	      restoreDisplay = dataShow && dataShow.display;

	      if (restoreDisplay == null) {
	        restoreDisplay = dataPriv.get(elem, "display");
	      }

	      display = jQuery.css(elem, "display");

	      if (display === "none") {
	        if (restoreDisplay) {
	          display = restoreDisplay;
	        } else {
	          // Get nonempty value(s) by temporarily forcing visibility
	          showHide([elem], true);
	          restoreDisplay = elem.style.display || restoreDisplay;
	          display = jQuery.css(elem, "display");
	          showHide([elem]);
	        }
	      } // Animate inline elements as inline-block


	      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
	        if (jQuery.css(elem, "float") === "none") {
	          // Restore the original display value at the end of pure show/hide animations
	          if (!propTween) {
	            anim.done(function () {
	              style.display = restoreDisplay;
	            });

	            if (restoreDisplay == null) {
	              display = style.display;
	              restoreDisplay = display === "none" ? "" : display;
	            }
	          }

	          style.display = "inline-block";
	        }
	      }
	    }

	    if (opts.overflow) {
	      style.overflow = "hidden";
	      anim.always(function () {
	        style.overflow = opts.overflow[0];
	        style.overflowX = opts.overflow[1];
	        style.overflowY = opts.overflow[2];
	      });
	    } // Implement show/hide animations


	    propTween = false;

	    for (prop in orig) {
	      // General show/hide setup for this element animation
	      if (!propTween) {
	        if (dataShow) {
	          if ("hidden" in dataShow) {
	            hidden = dataShow.hidden;
	          }
	        } else {
	          dataShow = dataPriv.access(elem, "fxshow", {
	            display: restoreDisplay
	          });
	        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


	        if (toggle) {
	          dataShow.hidden = !hidden;
	        } // Show elements before animating them


	        if (hidden) {
	          showHide([elem], true);
	        }
	        /* eslint-disable no-loop-func */


	        anim.done(function () {
	          /* eslint-enable no-loop-func */
	          // The final step of a "hide" animation is actually hiding the element
	          if (!hidden) {
	            showHide([elem]);
	          }

	          dataPriv.remove(elem, "fxshow");

	          for (prop in orig) {
	            jQuery.style(elem, prop, orig[prop]);
	          }
	        });
	      } // Per-property setup


	      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

	      if (!(prop in dataShow)) {
	        dataShow[prop] = propTween.start;

	        if (hidden) {
	          propTween.end = propTween.start;
	          propTween.start = 0;
	        }
	      }
	    }
	  }

	  function propFilter(props, specialEasing) {
	    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

	    for (index in props) {
	      name = camelCase(index);
	      easing = specialEasing[name];
	      value = props[index];

	      if (Array.isArray(value)) {
	        easing = value[1];
	        value = props[index] = value[0];
	      }

	      if (index !== name) {
	        props[name] = value;
	        delete props[index];
	      }

	      hooks = jQuery.cssHooks[name];

	      if (hooks && "expand" in hooks) {
	        value = hooks.expand(value);
	        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
	        // Reusing 'index' because we have the correct "name"

	        for (index in value) {
	          if (!(index in props)) {
	            props[index] = value[index];
	            specialEasing[index] = easing;
	          }
	        }
	      } else {
	        specialEasing[name] = easing;
	      }
	    }
	  }

	  function Animation(elem, properties, options) {
	    var result,
	        stopped,
	        index = 0,
	        length = Animation.prefilters.length,
	        deferred = jQuery.Deferred().always(function () {
	      // Don't match elem in the :animated selector
	      delete tick.elem;
	    }),
	        tick = function () {
	      if (stopped) {
	        return false;
	      }

	      var currentTime = fxNow || createFxNow(),
	          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
	          // Support: Android 2.3 only
	      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
	      temp = remaining / animation.duration || 0,
	          percent = 1 - temp,
	          index = 0,
	          length = animation.tweens.length;

	      for (; index < length; index++) {
	        animation.tweens[index].run(percent);
	      }

	      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

	      if (percent < 1 && length) {
	        return remaining;
	      } // If this was an empty animation, synthesize a final progress notification


	      if (!length) {
	        deferred.notifyWith(elem, [animation, 1, 0]);
	      } // Resolve the animation and report its conclusion


	      deferred.resolveWith(elem, [animation]);
	      return false;
	    },
	        animation = deferred.promise({
	      elem: elem,
	      props: jQuery.extend({}, properties),
	      opts: jQuery.extend(true, {
	        specialEasing: {},
	        easing: jQuery.easing._default
	      }, options),
	      originalProperties: properties,
	      originalOptions: options,
	      startTime: fxNow || createFxNow(),
	      duration: options.duration,
	      tweens: [],
	      createTween: function (prop, end) {
	        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
	        animation.tweens.push(tween);
	        return tween;
	      },
	      stop: function (gotoEnd) {
	        var index = 0,
	            // If we are going to the end, we want to run all the tweens
	        // otherwise we skip this part
	        length = gotoEnd ? animation.tweens.length : 0;

	        if (stopped) {
	          return this;
	        }

	        stopped = true;

	        for (; index < length; index++) {
	          animation.tweens[index].run(1);
	        } // Resolve when we played the last frame; otherwise, reject


	        if (gotoEnd) {
	          deferred.notifyWith(elem, [animation, 1, 0]);
	          deferred.resolveWith(elem, [animation, gotoEnd]);
	        } else {
	          deferred.rejectWith(elem, [animation, gotoEnd]);
	        }

	        return this;
	      }
	    }),
	        props = animation.props;

	    propFilter(props, animation.opts.specialEasing);

	    for (; index < length; index++) {
	      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

	      if (result) {
	        if (isFunction(result.stop)) {
	          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
	        }

	        return result;
	      }
	    }

	    jQuery.map(props, createTween, animation);

	    if (isFunction(animation.opts.start)) {
	      animation.opts.start.call(elem, animation);
	    } // Attach callbacks from options


	    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	    jQuery.fx.timer(jQuery.extend(tick, {
	      elem: elem,
	      anim: animation,
	      queue: animation.opts.queue
	    }));
	    return animation;
	  }

	  jQuery.Animation = jQuery.extend(Animation, {
	    tweeners: {
	      "*": [function (prop, value) {
	        var tween = this.createTween(prop, value);
	        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
	        return tween;
	      }]
	    },
	    tweener: function (props, callback) {
	      if (isFunction(props)) {
	        callback = props;
	        props = ["*"];
	      } else {
	        props = props.match(rnothtmlwhite);
	      }

	      var prop,
	          index = 0,
	          length = props.length;

	      for (; index < length; index++) {
	        prop = props[index];
	        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
	        Animation.tweeners[prop].unshift(callback);
	      }
	    },
	    prefilters: [defaultPrefilter],
	    prefilter: function (callback, prepend) {
	      if (prepend) {
	        Animation.prefilters.unshift(callback);
	      } else {
	        Animation.prefilters.push(callback);
	      }
	    }
	  });

	  jQuery.speed = function (speed, easing, fn) {
	    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
	      complete: fn || !fn && easing || isFunction(speed) && speed,
	      duration: speed,
	      easing: fn && easing || easing && !isFunction(easing) && easing
	    }; // Go to the end state if fx are off

	    if (jQuery.fx.off) {
	      opt.duration = 0;
	    } else {
	      if (typeof opt.duration !== "number") {
	        if (opt.duration in jQuery.fx.speeds) {
	          opt.duration = jQuery.fx.speeds[opt.duration];
	        } else {
	          opt.duration = jQuery.fx.speeds._default;
	        }
	      }
	    } // Normalize opt.queue - true/undefined/null -> "fx"


	    if (opt.queue == null || opt.queue === true) {
	      opt.queue = "fx";
	    } // Queueing


	    opt.old = opt.complete;

	    opt.complete = function () {
	      if (isFunction(opt.old)) {
	        opt.old.call(this);
	      }

	      if (opt.queue) {
	        jQuery.dequeue(this, opt.queue);
	      }
	    };

	    return opt;
	  };

	  jQuery.fn.extend({
	    fadeTo: function (speed, to, easing, callback) {
	      // Show any hidden elements after setting opacity to 0
	      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
	      .end().animate({
	        opacity: to
	      }, speed, easing, callback);
	    },
	    animate: function (prop, speed, easing, callback) {
	      var empty = jQuery.isEmptyObject(prop),
	          optall = jQuery.speed(speed, easing, callback),
	          doAnimation = function () {
	        // Operate on a copy of prop so per-property easing won't be lost
	        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

	        if (empty || dataPriv.get(this, "finish")) {
	          anim.stop(true);
	        }
	      };

	      doAnimation.finish = doAnimation;
	      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
	    },
	    stop: function (type, clearQueue, gotoEnd) {
	      var stopQueue = function (hooks) {
	        var stop = hooks.stop;
	        delete hooks.stop;
	        stop(gotoEnd);
	      };

	      if (typeof type !== "string") {
	        gotoEnd = clearQueue;
	        clearQueue = type;
	        type = undefined;
	      }

	      if (clearQueue) {
	        this.queue(type || "fx", []);
	      }

	      return this.each(function () {
	        var dequeue = true,
	            index = type != null && type + "queueHooks",
	            timers = jQuery.timers,
	            data = dataPriv.get(this);

	        if (index) {
	          if (data[index] && data[index].stop) {
	            stopQueue(data[index]);
	          }
	        } else {
	          for (index in data) {
	            if (data[index] && data[index].stop && rrun.test(index)) {
	              stopQueue(data[index]);
	            }
	          }
	        }

	        for (index = timers.length; index--;) {
	          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
	            timers[index].anim.stop(gotoEnd);
	            dequeue = false;
	            timers.splice(index, 1);
	          }
	        } // Start the next in the queue if the last step wasn't forced.
	        // Timers currently will call their complete callbacks, which
	        // will dequeue but only if they were gotoEnd.


	        if (dequeue || !gotoEnd) {
	          jQuery.dequeue(this, type);
	        }
	      });
	    },
	    finish: function (type) {
	      if (type !== false) {
	        type = type || "fx";
	      }

	      return this.each(function () {
	        var index,
	            data = dataPriv.get(this),
	            queue = data[type + "queue"],
	            hooks = data[type + "queueHooks"],
	            timers = jQuery.timers,
	            length = queue ? queue.length : 0; // Enable finishing flag on private data

	        data.finish = true; // Empty the queue first

	        jQuery.queue(this, type, []);

	        if (hooks && hooks.stop) {
	          hooks.stop.call(this, true);
	        } // Look for any active animations, and finish them


	        for (index = timers.length; index--;) {
	          if (timers[index].elem === this && timers[index].queue === type) {
	            timers[index].anim.stop(true);
	            timers.splice(index, 1);
	          }
	        } // Look for any animations in the old queue and finish them


	        for (index = 0; index < length; index++) {
	          if (queue[index] && queue[index].finish) {
	            queue[index].finish.call(this);
	          }
	        } // Turn off finishing flag


	        delete data.finish;
	      });
	    }
	  });
	  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
	    var cssFn = jQuery.fn[name];

	    jQuery.fn[name] = function (speed, easing, callback) {
	      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
	    };
	  }); // Generate shortcuts for custom animations

	  jQuery.each({
	    slideDown: genFx("show"),
	    slideUp: genFx("hide"),
	    slideToggle: genFx("toggle"),
	    fadeIn: {
	      opacity: "show"
	    },
	    fadeOut: {
	      opacity: "hide"
	    },
	    fadeToggle: {
	      opacity: "toggle"
	    }
	  }, function (name, props) {
	    jQuery.fn[name] = function (speed, easing, callback) {
	      return this.animate(props, speed, easing, callback);
	    };
	  });
	  jQuery.timers = [];

	  jQuery.fx.tick = function () {
	    var timer,
	        i = 0,
	        timers = jQuery.timers;
	    fxNow = Date.now();

	    for (; i < timers.length; i++) {
	      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

	      if (!timer() && timers[i] === timer) {
	        timers.splice(i--, 1);
	      }
	    }

	    if (!timers.length) {
	      jQuery.fx.stop();
	    }

	    fxNow = undefined;
	  };

	  jQuery.fx.timer = function (timer) {
	    jQuery.timers.push(timer);
	    jQuery.fx.start();
	  };

	  jQuery.fx.interval = 13;

	  jQuery.fx.start = function () {
	    if (inProgress) {
	      return;
	    }

	    inProgress = true;
	    schedule();
	  };

	  jQuery.fx.stop = function () {
	    inProgress = null;
	  };

	  jQuery.fx.speeds = {
	    slow: 600,
	    fast: 200,
	    // Default speed
	    _default: 400
	  }; // Based off of the plugin by Clint Helfers, with permission.
	  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

	  jQuery.fn.delay = function (time, type) {
	    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
	    type = type || "fx";
	    return this.queue(type, function (next, hooks) {
	      var timeout = window.setTimeout(next, time);

	      hooks.stop = function () {
	        window.clearTimeout(timeout);
	      };
	    });
	  };

	  (function () {
	    var input = document.createElement("input"),
	        select = document.createElement("select"),
	        opt = select.appendChild(document.createElement("option"));
	    input.type = "checkbox"; // Support: Android <=4.3 only
	    // Default value for a checkbox should be "on"

	    support.checkOn = input.value !== ""; // Support: IE <=11 only
	    // Must access selectedIndex to make default options select

	    support.optSelected = opt.selected; // Support: IE <=11 only
	    // An input loses its value after becoming a radio

	    input = document.createElement("input");
	    input.value = "t";
	    input.type = "radio";
	    support.radioValue = input.value === "t";
	  })();

	  var boolHook,
	      attrHandle = jQuery.expr.attrHandle;
	  jQuery.fn.extend({
	    attr: function (name, value) {
	      return access(this, jQuery.attr, name, value, arguments.length > 1);
	    },
	    removeAttr: function (name) {
	      return this.each(function () {
	        jQuery.removeAttr(this, name);
	      });
	    }
	  });
	  jQuery.extend({
	    attr: function (elem, name, value) {
	      var ret,
	          hooks,
	          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

	      if (nType === 3 || nType === 8 || nType === 2) {
	        return;
	      } // Fallback to prop when attributes are not supported


	      if (typeof elem.getAttribute === "undefined") {
	        return jQuery.prop(elem, name, value);
	      } // Attribute hooks are determined by the lowercase version
	      // Grab necessary hook if one is defined


	      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
	      }

	      if (value !== undefined) {
	        if (value === null) {
	          jQuery.removeAttr(elem, name);
	          return;
	        }

	        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	          return ret;
	        }

	        elem.setAttribute(name, value + "");
	        return value;
	      }

	      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	        return ret;
	      }

	      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

	      return ret == null ? undefined : ret;
	    },
	    attrHooks: {
	      type: {
	        set: function (elem, value) {
	          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
	            var val = elem.value;
	            elem.setAttribute("type", value);

	            if (val) {
	              elem.value = val;
	            }

	            return value;
	          }
	        }
	      }
	    },
	    removeAttr: function (elem, value) {
	      var name,
	          i = 0,
	          // Attribute names can contain non-HTML whitespace characters
	      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	      attrNames = value && value.match(rnothtmlwhite);

	      if (attrNames && elem.nodeType === 1) {
	        while (name = attrNames[i++]) {
	          elem.removeAttribute(name);
	        }
	      }
	    }
	  }); // Hooks for boolean attributes

	  boolHook = {
	    set: function (elem, value, name) {
	      if (value === false) {
	        // Remove boolean attributes when set to false
	        jQuery.removeAttr(elem, name);
	      } else {
	        elem.setAttribute(name, name);
	      }

	      return name;
	    }
	  };
	  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
	    var getter = attrHandle[name] || jQuery.find.attr;

	    attrHandle[name] = function (elem, name, isXML) {
	      var ret,
	          handle,
	          lowercaseName = name.toLowerCase();

	      if (!isXML) {
	        // Avoid an infinite loop by temporarily removing this function from the getter
	        handle = attrHandle[lowercaseName];
	        attrHandle[lowercaseName] = ret;
	        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
	        attrHandle[lowercaseName] = handle;
	      }

	      return ret;
	    };
	  });
	  var rfocusable = /^(?:input|select|textarea|button)$/i,
	      rclickable = /^(?:a|area)$/i;
	  jQuery.fn.extend({
	    prop: function (name, value) {
	      return access(this, jQuery.prop, name, value, arguments.length > 1);
	    },
	    removeProp: function (name) {
	      return this.each(function () {
	        delete this[jQuery.propFix[name] || name];
	      });
	    }
	  });
	  jQuery.extend({
	    prop: function (elem, name, value) {
	      var ret,
	          hooks,
	          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

	      if (nType === 3 || nType === 8 || nType === 2) {
	        return;
	      }

	      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	        // Fix name and attach hooks
	        name = jQuery.propFix[name] || name;
	        hooks = jQuery.propHooks[name];
	      }

	      if (value !== undefined) {
	        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	          return ret;
	        }

	        return elem[name] = value;
	      }

	      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	        return ret;
	      }

	      return elem[name];
	    },
	    propHooks: {
	      tabIndex: {
	        get: function (elem) {
	          // Support: IE <=9 - 11 only
	          // elem.tabIndex doesn't always return the
	          // correct value when it hasn't been explicitly set
	          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
	          // Use proper attribute retrieval(#12072)
	          var tabindex = jQuery.find.attr(elem, "tabindex");

	          if (tabindex) {
	            return parseInt(tabindex, 10);
	          }

	          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
	            return 0;
	          }

	          return -1;
	        }
	      }
	    },
	    propFix: {
	      "for": "htmlFor",
	      "class": "className"
	    }
	  }); // Support: IE <=11 only
	  // Accessing the selectedIndex property
	  // forces the browser to respect setting selected
	  // on the option
	  // The getter ensures a default option is selected
	  // when in an optgroup
	  // eslint rule "no-unused-expressions" is disabled for this code
	  // since it considers such accessions noop

	  if (!support.optSelected) {
	    jQuery.propHooks.selected = {
	      get: function (elem) {
	        /* eslint no-unused-expressions: "off" */
	        var parent = elem.parentNode;

	        if (parent && parent.parentNode) {
	          parent.parentNode.selectedIndex;
	        }

	        return null;
	      },
	      set: function (elem) {
	        /* eslint no-unused-expressions: "off" */
	        var parent = elem.parentNode;

	        if (parent) {
	          parent.selectedIndex;

	          if (parent.parentNode) {
	            parent.parentNode.selectedIndex;
	          }
	        }
	      }
	    };
	  }

	  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	    jQuery.propFix[this.toLowerCase()] = this;
	  }); // Strip and collapse whitespace according to HTML spec
	  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

	  function stripAndCollapse(value) {
	    var tokens = value.match(rnothtmlwhite) || [];
	    return tokens.join(" ");
	  }

	  function getClass(elem) {
	    return elem.getAttribute && elem.getAttribute("class") || "";
	  }

	  function classesToArray(value) {
	    if (Array.isArray(value)) {
	      return value;
	    }

	    if (typeof value === "string") {
	      return value.match(rnothtmlwhite) || [];
	    }

	    return [];
	  }

	  jQuery.fn.extend({
	    addClass: function (value) {
	      var classes,
	          elem,
	          cur,
	          curValue,
	          clazz,
	          j,
	          finalValue,
	          i = 0;

	      if (isFunction(value)) {
	        return this.each(function (j) {
	          jQuery(this).addClass(value.call(this, j, getClass(this)));
	        });
	      }

	      classes = classesToArray(value);

	      if (classes.length) {
	        while (elem = this[i++]) {
	          curValue = getClass(elem);
	          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

	          if (cur) {
	            j = 0;

	            while (clazz = classes[j++]) {
	              if (cur.indexOf(" " + clazz + " ") < 0) {
	                cur += clazz + " ";
	              }
	            } // Only assign if different to avoid unneeded rendering.


	            finalValue = stripAndCollapse(cur);

	            if (curValue !== finalValue) {
	              elem.setAttribute("class", finalValue);
	            }
	          }
	        }
	      }

	      return this;
	    },
	    removeClass: function (value) {
	      var classes,
	          elem,
	          cur,
	          curValue,
	          clazz,
	          j,
	          finalValue,
	          i = 0;

	      if (isFunction(value)) {
	        return this.each(function (j) {
	          jQuery(this).removeClass(value.call(this, j, getClass(this)));
	        });
	      }

	      if (!arguments.length) {
	        return this.attr("class", "");
	      }

	      classes = classesToArray(value);

	      if (classes.length) {
	        while (elem = this[i++]) {
	          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

	          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

	          if (cur) {
	            j = 0;

	            while (clazz = classes[j++]) {
	              // Remove *all* instances
	              while (cur.indexOf(" " + clazz + " ") > -1) {
	                cur = cur.replace(" " + clazz + " ", " ");
	              }
	            } // Only assign if different to avoid unneeded rendering.


	            finalValue = stripAndCollapse(cur);

	            if (curValue !== finalValue) {
	              elem.setAttribute("class", finalValue);
	            }
	          }
	        }
	      }

	      return this;
	    },
	    toggleClass: function (value, stateVal) {
	      var type = typeof value,
	          isValidValue = type === "string" || Array.isArray(value);

	      if (typeof stateVal === "boolean" && isValidValue) {
	        return stateVal ? this.addClass(value) : this.removeClass(value);
	      }

	      if (isFunction(value)) {
	        return this.each(function (i) {
	          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
	        });
	      }

	      return this.each(function () {
	        var className, i, self, classNames;

	        if (isValidValue) {
	          // Toggle individual class names
	          i = 0;
	          self = jQuery(this);
	          classNames = classesToArray(value);

	          while (className = classNames[i++]) {
	            // Check each className given, space separated list
	            if (self.hasClass(className)) {
	              self.removeClass(className);
	            } else {
	              self.addClass(className);
	            }
	          } // Toggle whole class name

	        } else if (value === undefined || type === "boolean") {
	          className = getClass(this);

	          if (className) {
	            // Store className if set
	            dataPriv.set(this, "__className__", className);
	          } // If the element has a class name or if we're passed `false`,
	          // then remove the whole classname (if there was one, the above saved it).
	          // Otherwise bring back whatever was previously saved (if anything),
	          // falling back to the empty string if nothing was stored.


	          if (this.setAttribute) {
	            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
	          }
	        }
	      });
	    },
	    hasClass: function (selector) {
	      var className,
	          elem,
	          i = 0;
	      className = " " + selector + " ";

	      while (elem = this[i++]) {
	        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
	          return true;
	        }
	      }

	      return false;
	    }
	  });
	  var rreturn = /\r/g;
	  jQuery.fn.extend({
	    val: function (value) {
	      var hooks,
	          ret,
	          valueIsFunction,
	          elem = this[0];

	      if (!arguments.length) {
	        if (elem) {
	          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

	          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
	            return ret;
	          }

	          ret = elem.value; // Handle most common string cases

	          if (typeof ret === "string") {
	            return ret.replace(rreturn, "");
	          } // Handle cases where value is null/undef or number


	          return ret == null ? "" : ret;
	        }

	        return;
	      }

	      valueIsFunction = isFunction(value);
	      return this.each(function (i) {
	        var val;

	        if (this.nodeType !== 1) {
	          return;
	        }

	        if (valueIsFunction) {
	          val = value.call(this, i, jQuery(this).val());
	        } else {
	          val = value;
	        } // Treat null/undefined as ""; convert numbers to string


	        if (val == null) {
	          val = "";
	        } else if (typeof val === "number") {
	          val += "";
	        } else if (Array.isArray(val)) {
	          val = jQuery.map(val, function (value) {
	            return value == null ? "" : value + "";
	          });
	        }

	        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

	        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
	          this.value = val;
	        }
	      });
	    }
	  });
	  jQuery.extend({
	    valHooks: {
	      option: {
	        get: function (elem) {
	          var val = jQuery.find.attr(elem, "value");
	          return val != null ? val : // Support: IE <=10 - 11 only
	          // option.text throws exceptions (#14686, #14858)
	          // Strip and collapse whitespace
	          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
	          stripAndCollapse(jQuery.text(elem));
	        }
	      },
	      select: {
	        get: function (elem) {
	          var value,
	              option,
	              i,
	              options = elem.options,
	              index = elem.selectedIndex,
	              one = elem.type === "select-one",
	              values = one ? null : [],
	              max = one ? index + 1 : options.length;

	          if (index < 0) {
	            i = max;
	          } else {
	            i = one ? index : 0;
	          } // Loop through all the selected options


	          for (; i < max; i++) {
	            option = options[i]; // Support: IE <=9 only
	            // IE8-9 doesn't update selected after form reset (#2551)

	            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
	            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
	              // Get the specific value for the option
	              value = jQuery(option).val(); // We don't need an array for one selects

	              if (one) {
	                return value;
	              } // Multi-Selects return an array


	              values.push(value);
	            }
	          }

	          return values;
	        },
	        set: function (elem, value) {
	          var optionSet,
	              option,
	              options = elem.options,
	              values = jQuery.makeArray(value),
	              i = options.length;

	          while (i--) {
	            option = options[i];
	            /* eslint-disable no-cond-assign */

	            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
	              optionSet = true;
	            }
	            /* eslint-enable no-cond-assign */

	          } // Force browsers to behave consistently when non-matching value is set


	          if (!optionSet) {
	            elem.selectedIndex = -1;
	          }

	          return values;
	        }
	      }
	    }
	  }); // Radios and checkboxes getter/setter

	  jQuery.each(["radio", "checkbox"], function () {
	    jQuery.valHooks[this] = {
	      set: function (elem, value) {
	        if (Array.isArray(value)) {
	          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
	        }
	      }
	    };

	    if (!support.checkOn) {
	      jQuery.valHooks[this].get = function (elem) {
	        return elem.getAttribute("value") === null ? "on" : elem.value;
	      };
	    }
	  }); // Return jQuery for attributes-only inclusion

	  support.focusin = "onfocusin" in window;

	  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	      stopPropagationCallback = function (e) {
	    e.stopPropagation();
	  };

	  jQuery.extend(jQuery.event, {
	    trigger: function (event, data, elem, onlyHandlers) {
	      var i,
	          cur,
	          tmp,
	          bubbleType,
	          ontype,
	          handle,
	          special,
	          lastElement,
	          eventPath = [elem || document],
	          type = hasOwn.call(event, "type") ? event.type : event,
	          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
	      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

	      if (elem.nodeType === 3 || elem.nodeType === 8) {
	        return;
	      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


	      if (rfocusMorph.test(type + jQuery.event.triggered)) {
	        return;
	      }

	      if (type.indexOf(".") > -1) {
	        // Namespaced trigger; create a regexp to match event type in handle()
	        namespaces = type.split(".");
	        type = namespaces.shift();
	        namespaces.sort();
	      }

	      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

	      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

	      event.isTrigger = onlyHandlers ? 2 : 3;
	      event.namespace = namespaces.join(".");
	      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

	      event.result = undefined;

	      if (!event.target) {
	        event.target = elem;
	      } // Clone any incoming data and prepend the event, creating the handler arg list


	      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

	      special = jQuery.event.special[type] || {};

	      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
	        return;
	      } // Determine event propagation path in advance, per W3C events spec (#9951)
	      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


	      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
	        bubbleType = special.delegateType || type;

	        if (!rfocusMorph.test(bubbleType + type)) {
	          cur = cur.parentNode;
	        }

	        for (; cur; cur = cur.parentNode) {
	          eventPath.push(cur);
	          tmp = cur;
	        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


	        if (tmp === (elem.ownerDocument || document)) {
	          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
	        }
	      } // Fire handlers on the event path


	      i = 0;

	      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
	        lastElement = cur;
	        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

	        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

	        if (handle) {
	          handle.apply(cur, data);
	        } // Native handler


	        handle = ontype && cur[ontype];

	        if (handle && handle.apply && acceptData(cur)) {
	          event.result = handle.apply(cur, data);

	          if (event.result === false) {
	            event.preventDefault();
	          }
	        }
	      }

	      event.type = type; // If nobody prevented the default action, do it now

	      if (!onlyHandlers && !event.isDefaultPrevented()) {
	        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
	          // Call a native DOM method on the target with the same name as the event.
	          // Don't do default actions on window, that's where global variables be (#6170)
	          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
	            // Don't re-trigger an onFOO event when we call its FOO() method
	            tmp = elem[ontype];

	            if (tmp) {
	              elem[ontype] = null;
	            } // Prevent re-triggering of the same event, since we already bubbled it above


	            jQuery.event.triggered = type;

	            if (event.isPropagationStopped()) {
	              lastElement.addEventListener(type, stopPropagationCallback);
	            }

	            elem[type]();

	            if (event.isPropagationStopped()) {
	              lastElement.removeEventListener(type, stopPropagationCallback);
	            }

	            jQuery.event.triggered = undefined;

	            if (tmp) {
	              elem[ontype] = tmp;
	            }
	          }
	        }
	      }

	      return event.result;
	    },
	    // Piggyback on a donor event to simulate a different one
	    // Used only for `focus(in | out)` events
	    simulate: function (type, elem, event) {
	      var e = jQuery.extend(new jQuery.Event(), event, {
	        type: type,
	        isSimulated: true
	      });
	      jQuery.event.trigger(e, null, elem);
	    }
	  });
	  jQuery.fn.extend({
	    trigger: function (type, data) {
	      return this.each(function () {
	        jQuery.event.trigger(type, data, this);
	      });
	    },
	    triggerHandler: function (type, data) {
	      var elem = this[0];

	      if (elem) {
	        return jQuery.event.trigger(type, data, elem, true);
	      }
	    }
	  }); // Support: Firefox <=44
	  // Firefox doesn't have focus(in | out) events
	  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	  //
	  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	  // focus(in | out) events fire after focus & blur events,
	  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

	  if (!support.focusin) {
	    jQuery.each({
	      focus: "focusin",
	      blur: "focusout"
	    }, function (orig, fix) {
	      // Attach a single capturing handler on the document while someone wants focusin/focusout
	      var handler = function (event) {
	        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
	      };

	      jQuery.event.special[fix] = {
	        setup: function () {
	          // Handle: regular nodes (via `this.ownerDocument`), window
	          // (via `this.document`) & document (via `this`).
	          var doc = this.ownerDocument || this.document || this,
	              attaches = dataPriv.access(doc, fix);

	          if (!attaches) {
	            doc.addEventListener(orig, handler, true);
	          }

	          dataPriv.access(doc, fix, (attaches || 0) + 1);
	        },
	        teardown: function () {
	          var doc = this.ownerDocument || this.document || this,
	              attaches = dataPriv.access(doc, fix) - 1;

	          if (!attaches) {
	            doc.removeEventListener(orig, handler, true);
	            dataPriv.remove(doc, fix);
	          } else {
	            dataPriv.access(doc, fix, attaches);
	          }
	        }
	      };
	    });
	  }

	  var location = window.location;
	  var nonce = {
	    guid: Date.now()
	  };
	  var rquery = /\?/; // Cross-browser xml parsing

	  jQuery.parseXML = function (data) {
	    var xml;

	    if (!data || typeof data !== "string") {
	      return null;
	    } // Support: IE 9 - 11 only
	    // IE throws on parseFromString with invalid input.


	    try {
	      xml = new window.DOMParser().parseFromString(data, "text/xml");
	    } catch (e) {
	      xml = undefined;
	    }

	    if (!xml || xml.getElementsByTagName("parsererror").length) {
	      jQuery.error("Invalid XML: " + data);
	    }

	    return xml;
	  };

	  var rbracket = /\[\]$/,
	      rCRLF = /\r?\n/g,
	      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	      rsubmittable = /^(?:input|select|textarea|keygen)/i;

	  function buildParams(prefix, obj, traditional, add) {
	    var name;

	    if (Array.isArray(obj)) {
	      // Serialize array item.
	      jQuery.each(obj, function (i, v) {
	        if (traditional || rbracket.test(prefix)) {
	          // Treat each array item as a scalar.
	          add(prefix, v);
	        } else {
	          // Item is non-scalar (array or object), encode its numeric index.
	          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
	        }
	      });
	    } else if (!traditional && toType(obj) === "object") {
	      // Serialize object item.
	      for (name in obj) {
	        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
	      }
	    } else {
	      // Serialize scalar item.
	      add(prefix, obj);
	    }
	  } // Serialize an array of form elements or a set of
	  // key/values into a query string


	  jQuery.param = function (a, traditional) {
	    var prefix,
	        s = [],
	        add = function (key, valueOrFunction) {
	      // If value is a function, invoke it and use its return value
	      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
	      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
	    };

	    if (a == null) {
	      return "";
	    } // If an array was passed in, assume that it is an array of form elements.


	    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
	      // Serialize the form elements
	      jQuery.each(a, function () {
	        add(this.name, this.value);
	      });
	    } else {
	      // If traditional, encode the "old" way (the way 1.3.2 or older
	      // did it), otherwise encode params recursively.
	      for (prefix in a) {
	        buildParams(prefix, a[prefix], traditional, add);
	      }
	    } // Return the resulting serialization


	    return s.join("&");
	  };

	  jQuery.fn.extend({
	    serialize: function () {
	      return jQuery.param(this.serializeArray());
	    },
	    serializeArray: function () {
	      return this.map(function () {
	        // Can add propHook for "elements" to filter or add form elements
	        var elements = jQuery.prop(this, "elements");
	        return elements ? jQuery.makeArray(elements) : this;
	      }).filter(function () {
	        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

	        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
	      }).map(function (_i, elem) {
	        var val = jQuery(this).val();

	        if (val == null) {
	          return null;
	        }

	        if (Array.isArray(val)) {
	          return jQuery.map(val, function (val) {
	            return {
	              name: elem.name,
	              value: val.replace(rCRLF, "\r\n")
	            };
	          });
	        }

	        return {
	          name: elem.name,
	          value: val.replace(rCRLF, "\r\n")
	        };
	      }).get();
	    }
	  });
	  var r20 = /%20/g,
	      rhash = /#.*$/,
	      rantiCache = /([?&])_=[^&]*/,
	      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	      // #7653, #8125, #8152: local protocol detection
	  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	      rnoContent = /^(?:GET|HEAD)$/,
	      rprotocol = /^\/\//,

	  /* Prefilters
	   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	   * 2) These are called:
	   *    - BEFORE asking for a transport
	   *    - AFTER param serialization (s.data is a string if s.processData is true)
	   * 3) key is the dataType
	   * 4) the catchall symbol "*" can be used
	   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	   */
	  prefilters = {},

	  /* Transports bindings
	   * 1) key is the dataType
	   * 2) the catchall symbol "*" can be used
	   * 3) selection will start with transport dataType and THEN go to "*" if needed
	   */
	  transports = {},
	      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	  allTypes = "*/".concat("*"),
	      // Anchor tag for parsing the document origin
	  originAnchor = document.createElement("a");
	  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

	  function addToPrefiltersOrTransports(structure) {
	    // dataTypeExpression is optional and defaults to "*"
	    return function (dataTypeExpression, func) {
	      if (typeof dataTypeExpression !== "string") {
	        func = dataTypeExpression;
	        dataTypeExpression = "*";
	      }

	      var dataType,
	          i = 0,
	          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

	      if (isFunction(func)) {
	        // For each dataType in the dataTypeExpression
	        while (dataType = dataTypes[i++]) {
	          // Prepend if requested
	          if (dataType[0] === "+") {
	            dataType = dataType.slice(1) || "*";
	            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
	          } else {
	            (structure[dataType] = structure[dataType] || []).push(func);
	          }
	        }
	      }
	    };
	  } // Base inspection function for prefilters and transports


	  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
	    var inspected = {},
	        seekingTransport = structure === transports;

	    function inspect(dataType) {
	      var selected;
	      inspected[dataType] = true;
	      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
	        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

	        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
	          options.dataTypes.unshift(dataTypeOrTransport);
	          inspect(dataTypeOrTransport);
	          return false;
	        } else if (seekingTransport) {
	          return !(selected = dataTypeOrTransport);
	        }
	      });
	      return selected;
	    }

	    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	  } // A special extend for ajax options
	  // that takes "flat" options (not to be deep extended)
	  // Fixes #9887


	  function ajaxExtend(target, src) {
	    var key,
	        deep,
	        flatOptions = jQuery.ajaxSettings.flatOptions || {};

	    for (key in src) {
	      if (src[key] !== undefined) {
	        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
	      }
	    }

	    if (deep) {
	      jQuery.extend(true, target, deep);
	    }

	    return target;
	  }
	  /* Handles responses to an ajax request:
	   * - finds the right dataType (mediates between content-type and expected dataType)
	   * - returns the corresponding response
	   */


	  function ajaxHandleResponses(s, jqXHR, responses) {
	    var ct,
	        type,
	        finalDataType,
	        firstDataType,
	        contents = s.contents,
	        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

	    while (dataTypes[0] === "*") {
	      dataTypes.shift();

	      if (ct === undefined) {
	        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
	      }
	    } // Check if we're dealing with a known content-type


	    if (ct) {
	      for (type in contents) {
	        if (contents[type] && contents[type].test(ct)) {
	          dataTypes.unshift(type);
	          break;
	        }
	      }
	    } // Check to see if we have a response for the expected dataType


	    if (dataTypes[0] in responses) {
	      finalDataType = dataTypes[0];
	    } else {
	      // Try convertible dataTypes
	      for (type in responses) {
	        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
	          finalDataType = type;
	          break;
	        }

	        if (!firstDataType) {
	          firstDataType = type;
	        }
	      } // Or just use first one


	      finalDataType = finalDataType || firstDataType;
	    } // If we found a dataType
	    // We add the dataType to the list if needed
	    // and return the corresponding response


	    if (finalDataType) {
	      if (finalDataType !== dataTypes[0]) {
	        dataTypes.unshift(finalDataType);
	      }

	      return responses[finalDataType];
	    }
	  }
	  /* Chain conversions given the request and the original response
	   * Also sets the responseXXX fields on the jqXHR instance
	   */


	  function ajaxConvert(s, response, jqXHR, isSuccess) {
	    var conv2,
	        current,
	        conv,
	        tmp,
	        prev,
	        converters = {},
	        // Work with a copy of dataTypes in case we need to modify it for conversion
	    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

	    if (dataTypes[1]) {
	      for (conv in s.converters) {
	        converters[conv.toLowerCase()] = s.converters[conv];
	      }
	    }

	    current = dataTypes.shift(); // Convert to each sequential dataType

	    while (current) {
	      if (s.responseFields[current]) {
	        jqXHR[s.responseFields[current]] = response;
	      } // Apply the dataFilter if provided


	      if (!prev && isSuccess && s.dataFilter) {
	        response = s.dataFilter(response, s.dataType);
	      }

	      prev = current;
	      current = dataTypes.shift();

	      if (current) {
	        // There's only work to do if current dataType is non-auto
	        if (current === "*") {
	          current = prev; // Convert response if prev dataType is non-auto and differs from current
	        } else if (prev !== "*" && prev !== current) {
	          // Seek a direct converter
	          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

	          if (!conv) {
	            for (conv2 in converters) {
	              // If conv2 outputs current
	              tmp = conv2.split(" ");

	              if (tmp[1] === current) {
	                // If prev can be converted to accepted input
	                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

	                if (conv) {
	                  // Condense equivalence converters
	                  if (conv === true) {
	                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
	                  } else if (converters[conv2] !== true) {
	                    current = tmp[0];
	                    dataTypes.unshift(tmp[1]);
	                  }

	                  break;
	                }
	              }
	            }
	          } // Apply converter (if not an equivalence)


	          if (conv !== true) {
	            // Unless errors are allowed to bubble, catch and return them
	            if (conv && s.throws) {
	              response = conv(response);
	            } else {
	              try {
	                response = conv(response);
	              } catch (e) {
	                return {
	                  state: "parsererror",
	                  error: conv ? e : "No conversion from " + prev + " to " + current
	                };
	              }
	            }
	          }
	        }
	      }
	    }

	    return {
	      state: "success",
	      data: response
	    };
	  }

	  jQuery.extend({
	    // Counter for holding the number of active queries
	    active: 0,
	    // Last-Modified header cache for next request
	    lastModified: {},
	    etag: {},
	    ajaxSettings: {
	      url: location.href,
	      type: "GET",
	      isLocal: rlocalProtocol.test(location.protocol),
	      global: true,
	      processData: true,
	      async: true,
	      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

	      /*
	      timeout: 0,
	      data: null,
	      dataType: null,
	      username: null,
	      password: null,
	      cache: null,
	      throws: false,
	      traditional: false,
	      headers: {},
	      */
	      accepts: {
	        "*": allTypes,
	        text: "text/plain",
	        html: "text/html",
	        xml: "application/xml, text/xml",
	        json: "application/json, text/javascript"
	      },
	      contents: {
	        xml: /\bxml\b/,
	        html: /\bhtml/,
	        json: /\bjson\b/
	      },
	      responseFields: {
	        xml: "responseXML",
	        text: "responseText",
	        json: "responseJSON"
	      },
	      // Data converters
	      // Keys separate source (or catchall "*") and destination types with a single space
	      converters: {
	        // Convert anything to text
	        "* text": String,
	        // Text to html (true = no transformation)
	        "text html": true,
	        // Evaluate text as a json expression
	        "text json": JSON.parse,
	        // Parse text as xml
	        "text xml": jQuery.parseXML
	      },
	      // For options that shouldn't be deep extended:
	      // you can add your own custom options here if
	      // and when you create one that shouldn't be
	      // deep extended (see ajaxExtend)
	      flatOptions: {
	        url: true,
	        context: true
	      }
	    },
	    // Creates a full fledged settings object into target
	    // with both ajaxSettings and settings fields.
	    // If target is omitted, writes into ajaxSettings.
	    ajaxSetup: function (target, settings) {
	      return settings ? // Building a settings object
	      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
	      ajaxExtend(jQuery.ajaxSettings, target);
	    },
	    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
	    ajaxTransport: addToPrefiltersOrTransports(transports),
	    // Main method
	    ajax: function (url, options) {
	      // If url is an object, simulate pre-1.5 signature
	      if (typeof url === "object") {
	        options = url;
	        url = undefined;
	      } // Force options to be an object


	      options = options || {};
	      var transport,
	          // URL without anti-cache param
	      cacheURL,
	          // Response headers
	      responseHeadersString,
	          responseHeaders,
	          // timeout handle
	      timeoutTimer,
	          // Url cleanup var
	      urlAnchor,
	          // Request state (becomes false upon send and true upon completion)
	      completed,
	          // To know if global events are to be dispatched
	      fireGlobals,
	          // Loop variable
	      i,
	          // uncached part of the url
	      uncached,
	          // Create the final options object
	      s = jQuery.ajaxSetup({}, options),
	          // Callbacks context
	      callbackContext = s.context || s,
	          // Context for global events is callbackContext if it is a DOM node or jQuery collection
	      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
	          // Deferreds
	      deferred = jQuery.Deferred(),
	          completeDeferred = jQuery.Callbacks("once memory"),
	          // Status-dependent callbacks
	      statusCode = s.statusCode || {},
	          // Headers (they are sent all at once)
	      requestHeaders = {},
	          requestHeadersNames = {},
	          // Default abort message
	      strAbort = "canceled",
	          // Fake xhr
	      jqXHR = {
	        readyState: 0,
	        // Builds headers hashtable if needed
	        getResponseHeader: function (key) {
	          var match;

	          if (completed) {
	            if (!responseHeaders) {
	              responseHeaders = {};

	              while (match = rheaders.exec(responseHeadersString)) {
	                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
	              }
	            }

	            match = responseHeaders[key.toLowerCase() + " "];
	          }

	          return match == null ? null : match.join(", ");
	        },
	        // Raw string
	        getAllResponseHeaders: function () {
	          return completed ? responseHeadersString : null;
	        },
	        // Caches the header
	        setRequestHeader: function (name, value) {
	          if (completed == null) {
	            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
	            requestHeaders[name] = value;
	          }

	          return this;
	        },
	        // Overrides response content-type header
	        overrideMimeType: function (type) {
	          if (completed == null) {
	            s.mimeType = type;
	          }

	          return this;
	        },
	        // Status-dependent callbacks
	        statusCode: function (map) {
	          var code;

	          if (map) {
	            if (completed) {
	              // Execute the appropriate callbacks
	              jqXHR.always(map[jqXHR.status]);
	            } else {
	              // Lazy-add the new callbacks in a way that preserves old ones
	              for (code in map) {
	                statusCode[code] = [statusCode[code], map[code]];
	              }
	            }
	          }

	          return this;
	        },
	        // Cancel the request
	        abort: function (statusText) {
	          var finalText = statusText || strAbort;

	          if (transport) {
	            transport.abort(finalText);
	          }

	          done(0, finalText);
	          return this;
	        }
	      }; // Attach deferreds

	      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
	      // Handle falsy url in the settings object (#10093: consistency with old signature)
	      // We also use the url parameter if available

	      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

	      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

	      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

	      if (s.crossDomain == null) {
	        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
	        // IE throws exception on accessing the href property if url is malformed,
	        // e.g. http://example.com:80x/

	        try {
	          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
	          // Anchor's host property isn't correctly set when s.url is relative

	          urlAnchor.href = urlAnchor.href;
	          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
	        } catch (e) {
	          // If there is an error parsing the URL, assume it is crossDomain,
	          // it can be rejected by the transport if it is invalid
	          s.crossDomain = true;
	        }
	      } // Convert data if not already a string


	      if (s.data && s.processData && typeof s.data !== "string") {
	        s.data = jQuery.param(s.data, s.traditional);
	      } // Apply prefilters


	      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

	      if (completed) {
	        return jqXHR;
	      } // We can fire global events as of now if asked to
	      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


	      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

	      if (fireGlobals && jQuery.active++ === 0) {
	        jQuery.event.trigger("ajaxStart");
	      } // Uppercase the type


	      s.type = s.type.toUpperCase(); // Determine if request has content

	      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
	      // and/or If-None-Match header later on
	      // Remove hash to simplify url manipulation

	      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

	      if (!s.hasContent) {
	        // Remember the hash so we can put it back
	        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

	        if (s.data && (s.processData || typeof s.data === "string")) {
	          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

	          delete s.data;
	        } // Add or update anti-cache param if needed


	        if (s.cache === false) {
	          cacheURL = cacheURL.replace(rantiCache, "$1");
	          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
	        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


	        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
	      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
	        s.data = s.data.replace(r20, "+");
	      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


	      if (s.ifModified) {
	        if (jQuery.lastModified[cacheURL]) {
	          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
	        }

	        if (jQuery.etag[cacheURL]) {
	          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
	        }
	      } // Set the correct header, if data is being sent


	      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
	        jqXHR.setRequestHeader("Content-Type", s.contentType);
	      } // Set the Accepts header for the server, depending on the dataType


	      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

	      for (i in s.headers) {
	        jqXHR.setRequestHeader(i, s.headers[i]);
	      } // Allow custom headers/mimetypes and early abort


	      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
	        // Abort if not done already and return
	        return jqXHR.abort();
	      } // Aborting is no longer a cancellation


	      strAbort = "abort"; // Install callbacks on deferreds

	      completeDeferred.add(s.complete);
	      jqXHR.done(s.success);
	      jqXHR.fail(s.error); // Get transport

	      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

	      if (!transport) {
	        done(-1, "No Transport");
	      } else {
	        jqXHR.readyState = 1; // Send global event

	        if (fireGlobals) {
	          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
	        } // If request was aborted inside ajaxSend, stop there


	        if (completed) {
	          return jqXHR;
	        } // Timeout


	        if (s.async && s.timeout > 0) {
	          timeoutTimer = window.setTimeout(function () {
	            jqXHR.abort("timeout");
	          }, s.timeout);
	        }

	        try {
	          completed = false;
	          transport.send(requestHeaders, done);
	        } catch (e) {
	          // Rethrow post-completion exceptions
	          if (completed) {
	            throw e;
	          } // Propagate others as results


	          done(-1, e);
	        }
	      } // Callback for when everything is done


	      function done(status, nativeStatusText, responses, headers) {
	        var isSuccess,
	            success,
	            error,
	            response,
	            modified,
	            statusText = nativeStatusText; // Ignore repeat invocations

	        if (completed) {
	          return;
	        }

	        completed = true; // Clear timeout if it exists

	        if (timeoutTimer) {
	          window.clearTimeout(timeoutTimer);
	        } // Dereference transport for early garbage collection
	        // (no matter how long the jqXHR object will be used)


	        transport = undefined; // Cache response headers

	        responseHeadersString = headers || ""; // Set readyState

	        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

	        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

	        if (responses) {
	          response = ajaxHandleResponses(s, jqXHR, responses);
	        } // Use a noop converter for missing script


	        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1) {
	          s.converters["text script"] = function () {};
	        } // Convert no matter what (that way responseXXX fields are always set)


	        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

	        if (isSuccess) {
	          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	          if (s.ifModified) {
	            modified = jqXHR.getResponseHeader("Last-Modified");

	            if (modified) {
	              jQuery.lastModified[cacheURL] = modified;
	            }

	            modified = jqXHR.getResponseHeader("etag");

	            if (modified) {
	              jQuery.etag[cacheURL] = modified;
	            }
	          } // if no content


	          if (status === 204 || s.type === "HEAD") {
	            statusText = "nocontent"; // if not modified
	          } else if (status === 304) {
	            statusText = "notmodified"; // If we have data, let's convert it
	          } else {
	            statusText = response.state;
	            success = response.data;
	            error = response.error;
	            isSuccess = !error;
	          }
	        } else {
	          // Extract error from statusText and normalize for non-aborts
	          error = statusText;

	          if (status || !statusText) {
	            statusText = "error";

	            if (status < 0) {
	              status = 0;
	            }
	          }
	        } // Set data for the fake xhr object


	        jqXHR.status = status;
	        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

	        if (isSuccess) {
	          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
	        } else {
	          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
	        } // Status-dependent callbacks


	        jqXHR.statusCode(statusCode);
	        statusCode = undefined;

	        if (fireGlobals) {
	          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
	        } // Complete


	        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

	        if (fireGlobals) {
	          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

	          if (! --jQuery.active) {
	            jQuery.event.trigger("ajaxStop");
	          }
	        }
	      }

	      return jqXHR;
	    },
	    getJSON: function (url, data, callback) {
	      return jQuery.get(url, data, callback, "json");
	    },
	    getScript: function (url, callback) {
	      return jQuery.get(url, undefined, callback, "script");
	    }
	  });
	  jQuery.each(["get", "post"], function (_i, method) {
	    jQuery[method] = function (url, data, callback, type) {
	      // Shift arguments if data argument was omitted
	      if (isFunction(data)) {
	        type = type || callback;
	        callback = data;
	        data = undefined;
	      } // The url can be an options object (which then must have .url)


	      return jQuery.ajax(jQuery.extend({
	        url: url,
	        type: method,
	        dataType: type,
	        data: data,
	        success: callback
	      }, jQuery.isPlainObject(url) && url));
	    };
	  });
	  jQuery.ajaxPrefilter(function (s) {
	    var i;

	    for (i in s.headers) {
	      if (i.toLowerCase() === "content-type") {
	        s.contentType = s.headers[i] || "";
	      }
	    }
	  });

	  jQuery._evalUrl = function (url, options, doc) {
	    return jQuery.ajax({
	      url: url,
	      // Make this explicit, since user can override this through ajaxSetup (#11264)
	      type: "GET",
	      dataType: "script",
	      cache: true,
	      async: false,
	      global: false,
	      // Only evaluate the response if it is successful (gh-4126)
	      // dataFilter is not invoked for failure responses, so using it instead
	      // of the default converter is kludgy but it works.
	      converters: {
	        "text script": function () {}
	      },
	      dataFilter: function (response) {
	        jQuery.globalEval(response, options, doc);
	      }
	    });
	  };

	  jQuery.fn.extend({
	    wrapAll: function (html) {
	      var wrap;

	      if (this[0]) {
	        if (isFunction(html)) {
	          html = html.call(this[0]);
	        } // The elements to wrap the target around


	        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

	        if (this[0].parentNode) {
	          wrap.insertBefore(this[0]);
	        }

	        wrap.map(function () {
	          var elem = this;

	          while (elem.firstElementChild) {
	            elem = elem.firstElementChild;
	          }

	          return elem;
	        }).append(this);
	      }

	      return this;
	    },
	    wrapInner: function (html) {
	      if (isFunction(html)) {
	        return this.each(function (i) {
	          jQuery(this).wrapInner(html.call(this, i));
	        });
	      }

	      return this.each(function () {
	        var self = jQuery(this),
	            contents = self.contents();

	        if (contents.length) {
	          contents.wrapAll(html);
	        } else {
	          self.append(html);
	        }
	      });
	    },
	    wrap: function (html) {
	      var htmlIsFunction = isFunction(html);
	      return this.each(function (i) {
	        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
	      });
	    },
	    unwrap: function (selector) {
	      this.parent(selector).not("body").each(function () {
	        jQuery(this).replaceWith(this.childNodes);
	      });
	      return this;
	    }
	  });

	  jQuery.expr.pseudos.hidden = function (elem) {
	    return !jQuery.expr.pseudos.visible(elem);
	  };

	  jQuery.expr.pseudos.visible = function (elem) {
	    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	  };

	  jQuery.ajaxSettings.xhr = function () {
	    try {
	      return new window.XMLHttpRequest();
	    } catch (e) {}
	  };

	  var xhrSuccessStatus = {
	    // File protocol always yields status code 0, assume 200
	    0: 200,
	    // Support: IE <=9 only
	    // #1450: sometimes IE returns 1223 when it should be 204
	    1223: 204
	  },
	      xhrSupported = jQuery.ajaxSettings.xhr();
	  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	  support.ajax = xhrSupported = !!xhrSupported;
	  jQuery.ajaxTransport(function (options) {
	    var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

	    if (support.cors || xhrSupported && !options.crossDomain) {
	      return {
	        send: function (headers, complete) {
	          var i,
	              xhr = options.xhr();
	          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

	          if (options.xhrFields) {
	            for (i in options.xhrFields) {
	              xhr[i] = options.xhrFields[i];
	            }
	          } // Override mime type if needed


	          if (options.mimeType && xhr.overrideMimeType) {
	            xhr.overrideMimeType(options.mimeType);
	          } // X-Requested-With header
	          // For cross-domain requests, seeing as conditions for a preflight are
	          // akin to a jigsaw puzzle, we simply never set it to be sure.
	          // (it can always be set on a per-request basis or even using ajaxSetup)
	          // For same-domain requests, won't change header if already provided.


	          if (!options.crossDomain && !headers["X-Requested-With"]) {
	            headers["X-Requested-With"] = "XMLHttpRequest";
	          } // Set headers


	          for (i in headers) {
	            xhr.setRequestHeader(i, headers[i]);
	          } // Callback


	          callback = function (type) {
	            return function () {
	              if (callback) {
	                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

	                if (type === "abort") {
	                  xhr.abort();
	                } else if (type === "error") {
	                  // Support: IE <=9 only
	                  // On a manual native abort, IE9 throws
	                  // errors on any property access that is not readyState
	                  if (typeof xhr.status !== "number") {
	                    complete(0, "error");
	                  } else {
	                    complete( // File: protocol always yields status 0; see #8605, #14207
	                    xhr.status, xhr.statusText);
	                  }
	                } else {
	                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
	                  // IE9 has no XHR2 but throws on binary (trac-11426)
	                  // For XHR2 non-text, let the caller handle it (gh-2498)
	                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
	                    binary: xhr.response
	                  } : {
	                    text: xhr.responseText
	                  }, xhr.getAllResponseHeaders());
	                }
	              }
	            };
	          }; // Listen to events


	          xhr.onload = callback();
	          errorCallback = xhr.onerror = xhr.ontimeout = callback("error"); // Support: IE 9 only
	          // Use onreadystatechange to replace onabort
	          // to handle uncaught aborts

	          if (xhr.onabort !== undefined) {
	            xhr.onabort = errorCallback;
	          } else {
	            xhr.onreadystatechange = function () {
	              // Check readyState before timeout as it changes
	              if (xhr.readyState === 4) {
	                // Allow onerror to be called first,
	                // but that will not handle a native abort
	                // Also, save errorCallback to a variable
	                // as xhr.onerror cannot be accessed
	                window.setTimeout(function () {
	                  if (callback) {
	                    errorCallback();
	                  }
	                });
	              }
	            };
	          } // Create the abort callback


	          callback = callback("abort");

	          try {
	            // Do send the request (this may raise an exception)
	            xhr.send(options.hasContent && options.data || null);
	          } catch (e) {
	            // #14683: Only rethrow if this hasn't been notified as an error yet
	            if (callback) {
	              throw e;
	            }
	          }
	        },
	        abort: function () {
	          if (callback) {
	            callback();
	          }
	        }
	      };
	    }
	  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

	  jQuery.ajaxPrefilter(function (s) {
	    if (s.crossDomain) {
	      s.contents.script = false;
	    }
	  }); // Install script dataType

	  jQuery.ajaxSetup({
	    accepts: {
	      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
	    },
	    contents: {
	      script: /\b(?:java|ecma)script\b/
	    },
	    converters: {
	      "text script": function (text) {
	        jQuery.globalEval(text);
	        return text;
	      }
	    }
	  }); // Handle cache's special case and crossDomain

	  jQuery.ajaxPrefilter("script", function (s) {
	    if (s.cache === undefined) {
	      s.cache = false;
	    }

	    if (s.crossDomain) {
	      s.type = "GET";
	    }
	  }); // Bind script tag hack transport

	  jQuery.ajaxTransport("script", function (s) {
	    // This transport only deals with cross domain or forced-by-attrs requests
	    if (s.crossDomain || s.scriptAttrs) {
	      var script, callback;
	      return {
	        send: function (_, complete) {
	          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
	            charset: s.scriptCharset,
	            src: s.url
	          }).on("load error", callback = function (evt) {
	            script.remove();
	            callback = null;

	            if (evt) {
	              complete(evt.type === "error" ? 404 : 200, evt.type);
	            }
	          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

	          document.head.appendChild(script[0]);
	        },
	        abort: function () {
	          if (callback) {
	            callback();
	          }
	        }
	      };
	    }
	  });
	  var oldCallbacks = [],
	      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

	  jQuery.ajaxSetup({
	    jsonp: "callback",
	    jsonpCallback: function () {
	      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
	      this[callback] = true;
	      return callback;
	    }
	  }); // Detect, normalize options and install callbacks for jsonp requests

	  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
	    var callbackName,
	        overwritten,
	        responseContainer,
	        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

	    if (jsonProp || s.dataTypes[0] === "jsonp") {
	      // Get callback name, remembering preexisting value associated with it
	      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

	      if (jsonProp) {
	        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
	      } else if (s.jsonp !== false) {
	        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
	      } // Use data converter to retrieve json after script execution


	      s.converters["script json"] = function () {
	        if (!responseContainer) {
	          jQuery.error(callbackName + " was not called");
	        }

	        return responseContainer[0];
	      }; // Force json dataType


	      s.dataTypes[0] = "json"; // Install callback

	      overwritten = window[callbackName];

	      window[callbackName] = function () {
	        responseContainer = arguments;
	      }; // Clean-up function (fires after converters)


	      jqXHR.always(function () {
	        // If previous value didn't exist - remove it
	        if (overwritten === undefined) {
	          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
	        } else {
	          window[callbackName] = overwritten;
	        } // Save back as free


	        if (s[callbackName]) {
	          // Make sure that re-using the options doesn't screw things around
	          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

	          oldCallbacks.push(callbackName);
	        } // Call if it was a function and we have a response


	        if (responseContainer && isFunction(overwritten)) {
	          overwritten(responseContainer[0]);
	        }

	        responseContainer = overwritten = undefined;
	      }); // Delegate to script

	      return "script";
	    }
	  }); // Support: Safari 8 only
	  // In Safari 8 documents created via document.implementation.createHTMLDocument
	  // collapse sibling forms: the second one becomes a child of the first one.
	  // Because of that, this security measure has to be disabled in Safari 8.
	  // https://bugs.webkit.org/show_bug.cgi?id=137337

	  support.createHTMLDocument = function () {
	    var body = document.implementation.createHTMLDocument("").body;
	    body.innerHTML = "<form></form><form></form>";
	    return body.childNodes.length === 2;
	  }(); // Argument "data" should be string of html
	  // context (optional): If specified, the fragment will be created in this context,
	  // defaults to document
	  // keepScripts (optional): If true, will include scripts passed in the html string


	  jQuery.parseHTML = function (data, context, keepScripts) {
	    if (typeof data !== "string") {
	      return [];
	    }

	    if (typeof context === "boolean") {
	      keepScripts = context;
	      context = false;
	    }

	    var base, parsed, scripts;

	    if (!context) {
	      // Stop scripts or inline event handlers from being executed immediately
	      // by using document.implementation
	      if (support.createHTMLDocument) {
	        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
	        // so any parsed elements with URLs
	        // are based on the document's URL (gh-2965)

	        base = context.createElement("base");
	        base.href = document.location.href;
	        context.head.appendChild(base);
	      } else {
	        context = document;
	      }
	    }

	    parsed = rsingleTag.exec(data);
	    scripts = !keepScripts && []; // Single tag

	    if (parsed) {
	      return [context.createElement(parsed[1])];
	    }

	    parsed = buildFragment([data], context, scripts);

	    if (scripts && scripts.length) {
	      jQuery(scripts).remove();
	    }

	    return jQuery.merge([], parsed.childNodes);
	  };
	  /**
	   * Load a url into a page
	   */


	  jQuery.fn.load = function (url, params, callback) {
	    var selector,
	        type,
	        response,
	        self = this,
	        off = url.indexOf(" ");

	    if (off > -1) {
	      selector = stripAndCollapse(url.slice(off));
	      url = url.slice(0, off);
	    } // If it's a function


	    if (isFunction(params)) {
	      // We assume that it's the callback
	      callback = params;
	      params = undefined; // Otherwise, build a param string
	    } else if (params && typeof params === "object") {
	      type = "POST";
	    } // If we have elements to modify, make the request


	    if (self.length > 0) {
	      jQuery.ajax({
	        url: url,
	        // If "type" variable is undefined, then "GET" method will be used.
	        // Make value of this field explicit since
	        // user can override it through ajaxSetup method
	        type: type || "GET",
	        dataType: "html",
	        data: params
	      }).done(function (responseText) {
	        // Save response for use in complete callback
	        response = arguments;
	        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
	        // Exclude scripts to avoid IE 'Permission Denied' errors
	        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
	        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
	        // but they are ignored because response was set above.
	        // If it fails, this function gets "jqXHR", "status", "error"
	      }).always(callback && function (jqXHR, status) {
	        self.each(function () {
	          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
	        });
	      });
	    }

	    return this;
	  };

	  jQuery.expr.pseudos.animated = function (elem) {
	    return jQuery.grep(jQuery.timers, function (fn) {
	      return elem === fn.elem;
	    }).length;
	  };

	  jQuery.offset = {
	    setOffset: function (elem, options, i) {
	      var curPosition,
	          curLeft,
	          curCSSTop,
	          curTop,
	          curOffset,
	          curCSSLeft,
	          calculatePosition,
	          position = jQuery.css(elem, "position"),
	          curElem = jQuery(elem),
	          props = {}; // Set position first, in-case top/left are set even on static elem

	      if (position === "static") {
	        elem.style.position = "relative";
	      }

	      curOffset = curElem.offset();
	      curCSSTop = jQuery.css(elem, "top");
	      curCSSLeft = jQuery.css(elem, "left");
	      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
	      // top or left is auto and position is either absolute or fixed

	      if (calculatePosition) {
	        curPosition = curElem.position();
	        curTop = curPosition.top;
	        curLeft = curPosition.left;
	      } else {
	        curTop = parseFloat(curCSSTop) || 0;
	        curLeft = parseFloat(curCSSLeft) || 0;
	      }

	      if (isFunction(options)) {
	        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
	        options = options.call(elem, i, jQuery.extend({}, curOffset));
	      }

	      if (options.top != null) {
	        props.top = options.top - curOffset.top + curTop;
	      }

	      if (options.left != null) {
	        props.left = options.left - curOffset.left + curLeft;
	      }

	      if ("using" in options) {
	        options.using.call(elem, props);
	      } else {
	        if (typeof props.top === "number") {
	          props.top += "px";
	        }

	        if (typeof props.left === "number") {
	          props.left += "px";
	        }

	        curElem.css(props);
	      }
	    }
	  };
	  jQuery.fn.extend({
	    // offset() relates an element's border box to the document origin
	    offset: function (options) {
	      // Preserve chaining for setter
	      if (arguments.length) {
	        return options === undefined ? this : this.each(function (i) {
	          jQuery.offset.setOffset(this, options, i);
	        });
	      }

	      var rect,
	          win,
	          elem = this[0];

	      if (!elem) {
	        return;
	      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
	      // Support: IE <=11 only
	      // Running getBoundingClientRect on a
	      // disconnected node in IE throws an error


	      if (!elem.getClientRects().length) {
	        return {
	          top: 0,
	          left: 0
	        };
	      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


	      rect = elem.getBoundingClientRect();
	      win = elem.ownerDocument.defaultView;
	      return {
	        top: rect.top + win.pageYOffset,
	        left: rect.left + win.pageXOffset
	      };
	    },
	    // position() relates an element's margin box to its offset parent's padding box
	    // This corresponds to the behavior of CSS absolute positioning
	    position: function () {
	      if (!this[0]) {
	        return;
	      }

	      var offsetParent,
	          offset,
	          doc,
	          elem = this[0],
	          parentOffset = {
	        top: 0,
	        left: 0
	      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

	      if (jQuery.css(elem, "position") === "fixed") {
	        // Assume position:fixed implies availability of getBoundingClientRect
	        offset = elem.getBoundingClientRect();
	      } else {
	        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
	        // when a statically positioned element is identified

	        doc = elem.ownerDocument;
	        offsetParent = elem.offsetParent || doc.documentElement;

	        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
	          offsetParent = offsetParent.parentNode;
	        }

	        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
	          // Incorporate borders into its offset, since they are outside its content origin
	          parentOffset = jQuery(offsetParent).offset();
	          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
	          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
	        }
	      } // Subtract parent offsets and element margins


	      return {
	        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
	        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
	      };
	    },
	    // This method will return documentElement in the following cases:
	    // 1) For the element inside the iframe without offsetParent, this method will return
	    //    documentElement of the parent window
	    // 2) For the hidden or detached element
	    // 3) For body or html element, i.e. in case of the html node - it will return itself
	    //
	    // but those exceptions were never presented as a real life use-cases
	    // and might be considered as more preferable results.
	    //
	    // This logic, however, is not guaranteed and can change at any point in the future
	    offsetParent: function () {
	      return this.map(function () {
	        var offsetParent = this.offsetParent;

	        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
	          offsetParent = offsetParent.offsetParent;
	        }

	        return offsetParent || documentElement;
	      });
	    }
	  }); // Create scrollLeft and scrollTop methods

	  jQuery.each({
	    scrollLeft: "pageXOffset",
	    scrollTop: "pageYOffset"
	  }, function (method, prop) {
	    var top = "pageYOffset" === prop;

	    jQuery.fn[method] = function (val) {
	      return access(this, function (elem, method, val) {
	        // Coalesce documents and windows
	        var win;

	        if (isWindow(elem)) {
	          win = elem;
	        } else if (elem.nodeType === 9) {
	          win = elem.defaultView;
	        }

	        if (val === undefined) {
	          return win ? win[prop] : elem[method];
	        }

	        if (win) {
	          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
	        } else {
	          elem[method] = val;
	        }
	      }, method, val, arguments.length);
	    };
	  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
	  // Add the top/left cssHooks using jQuery.fn.position
	  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	  // getComputedStyle returns percent when specified for top/left/bottom/right;
	  // rather than make the css module depend on the offset module, just check for it here

	  jQuery.each(["top", "left"], function (_i, prop) {
	    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
	      if (computed) {
	        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

	        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
	      }
	    });
	  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

	  jQuery.each({
	    Height: "height",
	    Width: "width"
	  }, function (name, type) {
	    jQuery.each({
	      padding: "inner" + name,
	      content: type,
	      "": "outer" + name
	    }, function (defaultExtra, funcName) {
	      // Margin is only for outerHeight, outerWidth
	      jQuery.fn[funcName] = function (margin, value) {
	        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
	            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
	        return access(this, function (elem, type, value) {
	          var doc;

	          if (isWindow(elem)) {
	            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
	            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
	          } // Get document width or height


	          if (elem.nodeType === 9) {
	            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
	            // whichever is greatest

	            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
	          }

	          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
	          jQuery.css(elem, type, extra) : // Set width or height on the element
	          jQuery.style(elem, type, value, extra);
	        }, type, chainable ? margin : undefined, chainable);
	      };
	    });
	  });
	  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
	    jQuery.fn[type] = function (fn) {
	      return this.on(type, fn);
	    };
	  });
	  jQuery.fn.extend({
	    bind: function (types, data, fn) {
	      return this.on(types, null, data, fn);
	    },
	    unbind: function (types, fn) {
	      return this.off(types, null, fn);
	    },
	    delegate: function (selector, types, data, fn) {
	      return this.on(types, selector, data, fn);
	    },
	    undelegate: function (selector, types, fn) {
	      // ( namespace ) or ( selector, types [, fn] )
	      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
	    },
	    hover: function (fnOver, fnOut) {
	      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
	    }
	  });
	  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
	    // Handle event binding
	    jQuery.fn[name] = function (data, fn) {
	      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
	    };
	  }); // Support: Android <=4.0 only
	  // Make sure we trim BOM and NBSP

	  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
	  // arguments.
	  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	  // However, it is not slated for removal any time soon

	  jQuery.proxy = function (fn, context) {
	    var tmp, args, proxy;

	    if (typeof context === "string") {
	      tmp = fn[context];
	      context = fn;
	      fn = tmp;
	    } // Quick check to determine if target is callable, in the spec
	    // this throws a TypeError, but we will just return undefined.


	    if (!isFunction(fn)) {
	      return undefined;
	    } // Simulated bind


	    args = slice.call(arguments, 2);

	    proxy = function () {
	      return fn.apply(context || this, args.concat(slice.call(arguments)));
	    }; // Set the guid of unique handler to the same of original handler, so it can be removed


	    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	    return proxy;
	  };

	  jQuery.holdReady = function (hold) {
	    if (hold) {
	      jQuery.readyWait++;
	    } else {
	      jQuery.ready(true);
	    }
	  };

	  jQuery.isArray = Array.isArray;
	  jQuery.parseJSON = JSON.parse;
	  jQuery.nodeName = nodeName;
	  jQuery.isFunction = isFunction;
	  jQuery.isWindow = isWindow;
	  jQuery.camelCase = camelCase;
	  jQuery.type = toType;
	  jQuery.now = Date.now;

	  jQuery.isNumeric = function (obj) {
	    // As of jQuery 3.0, isNumeric is limited to
	    // strings and numbers (primitives or objects)
	    // that can be coerced to finite numbers (gh-2662)
	    var type = jQuery.type(obj);
	    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    !isNaN(obj - parseFloat(obj));
	  };

	  jQuery.trim = function (text) {
	    return text == null ? "" : (text + "").replace(rtrim, "");
	  }; // Register as a named AMD module, since jQuery can be concatenated with other

	  var // Map over jQuery in case of overwrite
	  _jQuery = window.jQuery,
	      // Map over the $ in case of overwrite
	  _$ = window.$;

	  jQuery.noConflict = function (deep) {
	    if (window.$ === jQuery) {
	      window.$ = _$;
	    }

	    if (deep && window.jQuery === jQuery) {
	      window.jQuery = _jQuery;
	    }

	    return jQuery;
	  }; // Expose jQuery and $ identifiers, even in AMD
	  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	  // and CommonJS for browser emulators (#13566)


	  if (typeof noGlobal === "undefined") {
	    window.jQuery = window.$ = jQuery;
	  }

	  return jQuery;
	});
	});

	var foundation = createCommonjsModule(function (module, exports) {
	(function webpackUniversalModuleDefinition(root,factory){module.exports=factory(jquery);})(window,function(__WEBPACK_EXTERNAL_MODULE_jquery__){return(/******/function(modules){// webpackBootstrap
	/******/ // The module cache
	/******/var installedModules={};/******/ /******/ // The require function
	/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
	/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
	/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
	/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
	/******/module.l=true;/******/ /******/ // Return the exports of the module
	/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
	/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
	/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
	/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{enumerable:true,get:getter});/******/}/******/};/******/ /******/ // define __esModule on exports
	/******/__webpack_require__.r=function(exports){/******/if(typeof Symbol!=='undefined'&&Symbol.toStringTag){/******/Object.defineProperty(exports,Symbol.toStringTag,{value:'Module'});/******/}/******/Object.defineProperty(exports,'__esModule',{value:true});/******/};/******/ /******/ // create a fake namespace object
	/******/ // mode & 1: value is a module id, require it
	/******/ // mode & 2: merge all properties of value into the ns
	/******/ // mode & 4: return value when already ns object
	/******/ // mode & 8|1: behave like require
	/******/__webpack_require__.t=function(value,mode){/******/if(mode&1)value=__webpack_require__(value);/******/if(mode&8)return value;/******/if(mode&4&&typeof value==='object'&&value&&value.__esModule)return value;/******/var ns=Object.create(null);/******/__webpack_require__.r(ns);/******/Object.defineProperty(ns,'default',{enumerable:true,value:value});/******/if(mode&2&&typeof value!='string')for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key];}.bind(null,key));/******/return ns;/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
	/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
	/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
	/******/__webpack_require__.p="";/******/ /******/ /******/ // Load entry module and return exports
	/******/return __webpack_require__(__webpack_require__.s="../../../../../../../tmp/foundation-6.6.3.complete/js/vendor/foundation.js");/******/}(/************************************************************************/ /******/{/***/"../../../../../../../tmp/foundation-6.6.3.complete/js/vendor/foundation.js":/*!**************************************************************!*\
	  !*** /tmp/foundation-6.6.3.complete/js/vendor/foundation.js ***!
	  \**************************************************************/ /*! no exports provided */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/foundation.core */ \"./js/foundation.core.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_abide__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/foundation.abide */ \"./js/foundation.abide.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_accordion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js/foundation.accordion */ \"./js/foundation.accordion.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js/foundation.accordionMenu */ \"./js/foundation.accordionMenu.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_drilldown__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js/foundation.drilldown */ \"./js/foundation.drilldown.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_dropdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./js/foundation.dropdown */ \"./js/foundation.dropdown.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./js/foundation.dropdownMenu */ \"./js/foundation.dropdownMenu.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_equalizer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./js/foundation.equalizer */ \"./js/foundation.equalizer.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_interchange__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./js/foundation.interchange */ \"./js/foundation.interchange.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_magellan__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./js/foundation.magellan */ \"./js/foundation.magellan.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_offcanvas__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./js/foundation.offcanvas */ \"./js/foundation.offcanvas.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_orbit__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./js/foundation.orbit */ \"./js/foundation.orbit.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_responsiveMenu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./js/foundation.responsiveMenu */ \"./js/foundation.responsiveMenu.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_responsiveToggle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./js/foundation.responsiveToggle */ \"./js/foundation.responsiveToggle.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_reveal__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./js/foundation.reveal */ \"./js/foundation.reveal.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_slider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./js/foundation.slider */ \"./js/foundation.slider.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_sticky__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./js/foundation.sticky */ \"./js/foundation.sticky.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_tabs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./js/foundation.tabs */ \"./js/foundation.tabs.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_toggler__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./js/foundation.toggler */ \"./js/foundation.toggler.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_tooltip__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./js/foundation.tooltip */ \"./js/foundation.tooltip.js\");\n/* harmony import */ var _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_responsiveAccordionTabs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./js/foundation.responsiveAccordionTabs */ \"./js/foundation.responsiveAccordionTabs.js\");\n\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].addToJquery(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].MediaQuery = _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"MediaQuery\"];\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a, _var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"]);\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_abide__WEBPACK_IMPORTED_MODULE_4__[\"Abide\"], 'Abide');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_accordion__WEBPACK_IMPORTED_MODULE_5__[\"Accordion\"], 'Accordion');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__[\"AccordionMenu\"], 'AccordionMenu');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_drilldown__WEBPACK_IMPORTED_MODULE_7__[\"Drilldown\"], 'Drilldown');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_dropdown__WEBPACK_IMPORTED_MODULE_8__[\"Dropdown\"], 'Dropdown');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_9__[\"DropdownMenu\"], 'DropdownMenu');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_equalizer__WEBPACK_IMPORTED_MODULE_10__[\"Equalizer\"], 'Equalizer');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_interchange__WEBPACK_IMPORTED_MODULE_11__[\"Interchange\"], 'Interchange');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_magellan__WEBPACK_IMPORTED_MODULE_12__[\"Magellan\"], 'Magellan');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_offcanvas__WEBPACK_IMPORTED_MODULE_13__[\"OffCanvas\"], 'OffCanvas');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_orbit__WEBPACK_IMPORTED_MODULE_14__[\"Orbit\"], 'Orbit');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_responsiveMenu__WEBPACK_IMPORTED_MODULE_15__[\"ResponsiveMenu\"], 'ResponsiveMenu');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_responsiveToggle__WEBPACK_IMPORTED_MODULE_16__[\"ResponsiveToggle\"], 'ResponsiveToggle');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_reveal__WEBPACK_IMPORTED_MODULE_17__[\"Reveal\"], 'Reveal');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_slider__WEBPACK_IMPORTED_MODULE_18__[\"Slider\"], 'Slider');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_sticky__WEBPACK_IMPORTED_MODULE_19__[\"Sticky\"], 'Sticky');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_tabs__WEBPACK_IMPORTED_MODULE_20__[\"Tabs\"], 'Tabs');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_toggler__WEBPACK_IMPORTED_MODULE_21__[\"Toggler\"], 'Toggler');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_tooltip__WEBPACK_IMPORTED_MODULE_22__[\"Tooltip\"], 'Tooltip');\n\n_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_core__WEBPACK_IMPORTED_MODULE_1__[\"Foundation\"].plugin(_var_www_virtual_druf_html_foundation_customizer_daniel_ruf_de_foundation_sites_js_foundation_responsiveAccordionTabs__WEBPACK_IMPORTED_MODULE_23__[\"ResponsiveAccordionTabs\"], 'ResponsiveAccordionTabs');\n\n//# sourceURL=webpack:////tmp/foundation-6.6.3.complete/js/vendor/foundation.js?");/***/},/***/"./js/foundation.abide.js":/*!********************************!*\
	  !*** ./js/foundation.abide.js ***!
	  \********************************/ /*! exports provided: Abide */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Abide\", function() { return Abide; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n/**\n * Abide module.\n * @module foundation.abide\n */\n\nvar Abide =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Abide, _Plugin);\n\n  function Abide() {\n    _classCallCheck(this, Abide);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Abide).apply(this, arguments));\n  }\n\n  _createClass(Abide, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Abide.\n     * @class\n     * @name Abide\n     * @fires Abide#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(true, {}, Abide.defaults, this.$element.data(), options);\n      this.isEnabled = true;\n      this.formnovalidate = null;\n      this.className = 'Abide'; // ie9 back compat\n\n      this._init();\n    }\n    /**\n     * Initializes the Abide plugin and calls functions to get Abide functioning on load.\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var _this2 = this;\n\n      this.$inputs = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.merge( // Consider as input to validate:\n      this.$element.find('input').not('[type=\"submit\"]'), // * all input fields expect submit\n      this.$element.find('textarea, select') // * all textareas and select fields\n      );\n      this.$submits = this.$element.find('[type=\"submit\"]');\n      var $globalErrors = this.$element.find('[data-abide-error]'); // Add a11y attributes to all fields\n\n      if (this.options.a11yAttributes) {\n        this.$inputs.each(function (i, input) {\n          return _this2.addA11yAttributes(jquery__WEBPACK_IMPORTED_MODULE_0___default()(input));\n        });\n        $globalErrors.each(function (i, error) {\n          return _this2.addGlobalErrorA11yAttributes(jquery__WEBPACK_IMPORTED_MODULE_0___default()(error));\n        });\n      }\n\n      this._events();\n    }\n    /**\n     * Initializes events for Abide.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this3 = this;\n\n      this.$element.off('.abide').on('reset.zf.abide', function () {\n        _this3.resetForm();\n      }).on('submit.zf.abide', function () {\n        return _this3.validateForm();\n      });\n      this.$submits.off('click.zf.abide keydown.zf.abide').on('click.zf.abide keydown.zf.abide', function (e) {\n        if (!e.key || e.key === ' ' || e.key === 'Enter') {\n          e.preventDefault();\n          _this3.formnovalidate = e.target.getAttribute('formnovalidate') !== null;\n\n          _this3.$element.submit();\n        }\n      });\n\n      if (this.options.validateOn === 'fieldChange') {\n        this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {\n          _this3.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target));\n        });\n      }\n\n      if (this.options.liveValidate) {\n        this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {\n          _this3.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target));\n        });\n      }\n\n      if (this.options.validateOnBlur) {\n        this.$inputs.off('blur.zf.abide').on('blur.zf.abide', function (e) {\n          _this3.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target));\n        });\n      }\n    }\n    /**\n     * Calls necessary functions to update Abide upon DOM change\n     * @private\n     */\n\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      this._init();\n    }\n    /**\n     * Checks whether the submitted form should be validated or not, consodering formnovalidate and isEnabled\n     * @returns {Boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_validationIsDisabled\",\n    value: function _validationIsDisabled() {\n      if (this.isEnabled === false) {\n        // whole validation disabled\n        return true;\n      } else if (typeof this.formnovalidate === 'boolean') {\n        // triggered by $submit\n        return this.formnovalidate;\n      } // triggered by Enter in non-submit input\n\n\n      return this.$submits.length ? this.$submits[0].getAttribute('formnovalidate') !== null : false;\n    }\n    /**\n     * Enables the whole validation\n     */\n\n  }, {\n    key: \"enableValidation\",\n    value: function enableValidation() {\n      this.isEnabled = true;\n    }\n    /**\n     * Disables the whole validation\n     */\n\n  }, {\n    key: \"disableValidation\",\n    value: function disableValidation() {\n      this.isEnabled = false;\n    }\n    /**\n     * Checks whether or not a form element has the required attribute and if it's checked or not\n     * @param {Object} element - jQuery object to check for required attribute\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n     */\n\n  }, {\n    key: \"requiredCheck\",\n    value: function requiredCheck($el) {\n      if (!$el.attr('required')) return true;\n      var isGood = true;\n\n      switch ($el[0].type) {\n        case 'checkbox':\n          isGood = $el[0].checked;\n          break;\n\n        case 'select':\n        case 'select-one':\n        case 'select-multiple':\n          var opt = $el.find('option:selected');\n          if (!opt.length || !opt.val()) isGood = false;\n          break;\n\n        default:\n          if (!$el.val() || !$el.val().length) isGood = false;\n      }\n\n      return isGood;\n    }\n    /**\n     * Get:\n     * - Based on $el, the first element(s) corresponding to `formErrorSelector` in this order:\n     *   1. The element's direct sibling('s).\n     *   2. The element's parent's children.\n     * - Element(s) with the attribute `[data-form-error-for]` set with the element's id.\n     *\n     * This allows for multiple form errors per input, though if none are found, no form errors will be shown.\n     *\n     * @param {Object} $el - jQuery object to use as reference to find the form error selector.\n     * @param {String[]} [failedValidators] - List of failed validators.\n     * @returns {Object} jQuery object with the selector.\n     */\n\n  }, {\n    key: \"findFormError\",\n    value: function findFormError($el, failedValidators) {\n      var _this4 = this;\n\n      var id = $el.length ? $el[0].id : '';\n      var $error = $el.siblings(this.options.formErrorSelector);\n\n      if (!$error.length) {\n        $error = $el.parent().find(this.options.formErrorSelector);\n      }\n\n      if (id) {\n        $error = $error.add(this.$element.find(\"[data-form-error-for=\\\"\".concat(id, \"\\\"]\")));\n      }\n\n      if (!!failedValidators) {\n        $error = $error.not('[data-form-error-on]');\n        failedValidators.forEach(function (v) {\n          $error = $error.add($el.siblings(\"[data-form-error-on=\\\"\".concat(v, \"\\\"]\")));\n          $error = $error.add(_this4.$element.find(\"[data-form-error-for=\\\"\".concat(id, \"\\\"][data-form-error-on=\\\"\").concat(v, \"\\\"]\")));\n        });\n      }\n\n      return $error;\n    }\n    /**\n     * Get the first element in this order:\n     * 2. The <label> with the attribute `[for=\"someInputId\"]`\n     * 3. The `.closest()` <label>\n     *\n     * @param {Object} $el - jQuery object to check for required attribute\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n     */\n\n  }, {\n    key: \"findLabel\",\n    value: function findLabel($el) {\n      var id = $el[0].id;\n      var $label = this.$element.find(\"label[for=\\\"\".concat(id, \"\\\"]\"));\n\n      if (!$label.length) {\n        return $el.closest('label');\n      }\n\n      return $label;\n    }\n    /**\n     * Get the set of labels associated with a set of radio els in this order\n     * 2. The <label> with the attribute `[for=\"someInputId\"]`\n     * 3. The `.closest()` <label>\n     *\n     * @param {Object} $el - jQuery object to check for required attribute\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n     */\n\n  }, {\n    key: \"findRadioLabels\",\n    value: function findRadioLabels($els) {\n      var _this5 = this;\n\n      var labels = $els.map(function (i, el) {\n        var id = el.id;\n\n        var $label = _this5.$element.find(\"label[for=\\\"\".concat(id, \"\\\"]\"));\n\n        if (!$label.length) {\n          $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).closest('label');\n        }\n\n        return $label[0];\n      });\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(labels);\n    }\n    /**\n     * Get the set of labels associated with a set of checkbox els in this order\n     * 2. The <label> with the attribute `[for=\"someInputId\"]`\n     * 3. The `.closest()` <label>\n     *\n     * @param {Object} $el - jQuery object to check for required attribute\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n     */\n\n  }, {\n    key: \"findCheckboxLabels\",\n    value: function findCheckboxLabels($els) {\n      var _this6 = this;\n\n      var labels = $els.map(function (i, el) {\n        var id = el.id;\n\n        var $label = _this6.$element.find(\"label[for=\\\"\".concat(id, \"\\\"]\"));\n\n        if (!$label.length) {\n          $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).closest('label');\n        }\n\n        return $label[0];\n      });\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(labels);\n    }\n    /**\n     * Adds the CSS error class as specified by the Abide settings to the label, input, and the form\n     * @param {Object} $el - jQuery object to add the class to\n     * @param {String[]} [failedValidators] - List of failed validators.\n     */\n\n  }, {\n    key: \"addErrorClasses\",\n    value: function addErrorClasses($el, failedValidators) {\n      var $label = this.findLabel($el);\n      var $formError = this.findFormError($el, failedValidators);\n\n      if ($label.length) {\n        $label.addClass(this.options.labelErrorClass);\n      }\n\n      if ($formError.length) {\n        $formError.addClass(this.options.formErrorClass);\n      }\n\n      $el.addClass(this.options.inputErrorClass).attr({\n        'data-invalid': '',\n        'aria-invalid': true\n      });\n    }\n    /**\n     * Adds [for] and [role=alert] attributes to all form error targetting $el,\n     * and [aria-describedby] attribute to $el toward the first form error.\n     * @param {Object} $el - jQuery object\n     */\n\n  }, {\n    key: \"addA11yAttributes\",\n    value: function addA11yAttributes($el) {\n      var $errors = this.findFormError($el);\n      var $labels = $errors.filter('label');\n      var $error = $errors.first();\n      if (!$errors.length) return; // Set [aria-describedby] on the input toward the first form error if it is not set\n\n      if (typeof $el.attr('aria-describedby') === 'undefined') {\n        // Get the first error ID or create one\n        var errorId = $error.attr('id');\n\n        if (typeof errorId === 'undefined') {\n          errorId = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'abide-error');\n          $error.attr('id', errorId);\n        }\n\n        $el.attr('aria-describedby', errorId);\n      }\n\n      if ($labels.filter('[for]').length < $labels.length) {\n        // Get the input ID or create one\n        var elemId = $el.attr('id');\n\n        if (typeof elemId === 'undefined') {\n          elemId = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'abide-input');\n          $el.attr('id', elemId);\n        } // For each label targeting $el, set [for] if it is not set.\n\n\n        $labels.each(function (i, label) {\n          var $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(label);\n          if (typeof $label.attr('for') === 'undefined') $label.attr('for', elemId);\n        });\n      } // For each error targeting $el, set [role=alert] if it is not set.\n\n\n      $errors.each(function (i, label) {\n        var $label = jquery__WEBPACK_IMPORTED_MODULE_0___default()(label);\n        if (typeof $label.attr('role') === 'undefined') $label.attr('role', 'alert');\n      }).end();\n    }\n    /**\n     * Adds [aria-live] attribute to the given global form error $el.\n     * @param {Object} $el - jQuery object to add the attribute to\n     */\n\n  }, {\n    key: \"addGlobalErrorA11yAttributes\",\n    value: function addGlobalErrorA11yAttributes($el) {\n      if (typeof $el.attr('aria-live') === 'undefined') $el.attr('aria-live', this.options.a11yErrorLevel);\n    }\n    /**\n     * Remove CSS error classes etc from an entire radio button group\n     * @param {String} groupName - A string that specifies the name of a radio button group\n     *\n     */\n\n  }, {\n    key: \"removeRadioErrorClasses\",\n    value: function removeRadioErrorClasses(groupName) {\n      var $els = this.$element.find(\":radio[name=\\\"\".concat(groupName, \"\\\"]\"));\n      var $labels = this.findRadioLabels($els);\n      var $formErrors = this.findFormError($els);\n\n      if ($labels.length) {\n        $labels.removeClass(this.options.labelErrorClass);\n      }\n\n      if ($formErrors.length) {\n        $formErrors.removeClass(this.options.formErrorClass);\n      }\n\n      $els.removeClass(this.options.inputErrorClass).attr({\n        'data-invalid': null,\n        'aria-invalid': null\n      });\n    }\n    /**\n     * Remove CSS error classes etc from an entire checkbox group\n     * @param {String} groupName - A string that specifies the name of a checkbox group\n     *\n     */\n\n  }, {\n    key: \"removeCheckboxErrorClasses\",\n    value: function removeCheckboxErrorClasses(groupName) {\n      var $els = this.$element.find(\":checkbox[name=\\\"\".concat(groupName, \"\\\"]\"));\n      var $labels = this.findCheckboxLabels($els);\n      var $formErrors = this.findFormError($els);\n\n      if ($labels.length) {\n        $labels.removeClass(this.options.labelErrorClass);\n      }\n\n      if ($formErrors.length) {\n        $formErrors.removeClass(this.options.formErrorClass);\n      }\n\n      $els.removeClass(this.options.inputErrorClass).attr({\n        'data-invalid': null,\n        'aria-invalid': null\n      });\n    }\n    /**\n     * Removes CSS error class as specified by the Abide settings from the label, input, and the form\n     * @param {Object} $el - jQuery object to remove the class from\n     */\n\n  }, {\n    key: \"removeErrorClasses\",\n    value: function removeErrorClasses($el) {\n      // radios need to clear all of the els\n      if ($el[0].type == 'radio') {\n        return this.removeRadioErrorClasses($el.attr('name'));\n      } // checkboxes need to clear all of the els\n      else if ($el[0].type == 'checkbox') {\n          return this.removeCheckboxErrorClasses($el.attr('name'));\n        }\n\n      var $label = this.findLabel($el);\n      var $formError = this.findFormError($el);\n\n      if ($label.length) {\n        $label.removeClass(this.options.labelErrorClass);\n      }\n\n      if ($formError.length) {\n        $formError.removeClass(this.options.formErrorClass);\n      }\n\n      $el.removeClass(this.options.inputErrorClass).attr({\n        'data-invalid': null,\n        'aria-invalid': null\n      });\n    }\n    /**\n     * Goes through a form to find inputs and proceeds to validate them in ways specific to their type.\n     * Ignores inputs with data-abide-ignore, type=\"hidden\" or disabled attributes set\n     * @fires Abide#invalid\n     * @fires Abide#valid\n     * @param {Object} element - jQuery object to validate, should be an HTML input\n     * @returns {Boolean} goodToGo - If the input is valid or not.\n     */\n\n  }, {\n    key: \"validateInput\",\n    value: function validateInput($el) {\n      var _this7 = this;\n\n      var clearRequire = this.requiredCheck($el),\n          validator = $el.attr('data-validator'),\n          failedValidators = [],\n          manageErrorClasses = true; // skip validation if disabled\n\n      if (this._validationIsDisabled()) {\n        return true;\n      } // don't validate ignored inputs or hidden inputs or disabled inputs\n\n\n      if ($el.is('[data-abide-ignore]') || $el.is('[type=\"hidden\"]') || $el.is('[disabled]')) {\n        return true;\n      }\n\n      switch ($el[0].type) {\n        case 'radio':\n          this.validateRadio($el.attr('name')) || failedValidators.push('required');\n          break;\n\n        case 'checkbox':\n          this.validateCheckbox($el.attr('name')) || failedValidators.push('required'); // validateCheckbox() adds/removes error classes\n\n          manageErrorClasses = false;\n          break;\n\n        case 'select':\n        case 'select-one':\n        case 'select-multiple':\n          clearRequire || failedValidators.push('required');\n          break;\n\n        default:\n          clearRequire || failedValidators.push('required');\n          this.validateText($el) || failedValidators.push('pattern');\n      }\n\n      if (validator) {\n        var required = $el.attr('required') ? true : false;\n        validator.split(' ').forEach(function (v) {\n          _this7.options.validators[v]($el, required, $el.parent()) || failedValidators.push(v);\n        });\n      }\n\n      if ($el.attr('data-equalto')) {\n        this.options.validators.equalTo($el) || failedValidators.push('equalTo');\n      }\n\n      var goodToGo = failedValidators.length === 0;\n      var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';\n\n      if (goodToGo) {\n        // Re-validate inputs that depend on this one with equalto\n        var dependentElements = this.$element.find(\"[data-equalto=\\\"\".concat($el.attr('id'), \"\\\"]\"));\n\n        if (dependentElements.length) {\n          var _this = this;\n\n          dependentElements.each(function () {\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val()) {\n              _this.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\n            }\n          });\n        }\n      }\n\n      if (manageErrorClasses) {\n        this.removeErrorClasses($el);\n\n        if (!goodToGo) {\n          this.addErrorClasses($el, failedValidators);\n        }\n      }\n      /**\n       * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`\n       * Trigger includes the DOM element of the input.\n       * @event Abide#valid\n       * @event Abide#invalid\n       */\n\n\n      $el.trigger(message, [$el]);\n      return goodToGo;\n    }\n    /**\n     * Goes through a form and if there are any invalid inputs, it will display the form error element\n     * @returns {Boolean} noError - true if no errors were detected...\n     * @fires Abide#formvalid\n     * @fires Abide#forminvalid\n     */\n\n  }, {\n    key: \"validateForm\",\n    value: function validateForm() {\n      var _this8 = this;\n\n      var acc = [];\n\n      var _this = this;\n\n      var checkboxGroupName; // Remember first form submission to prevent specific checkbox validation (more than one required) until form got initially submitted\n\n      if (!this.initialized) {\n        this.initialized = true;\n      } // skip validation if disabled\n\n\n      if (this._validationIsDisabled()) {\n        this.formnovalidate = null;\n        return true;\n      }\n\n      this.$inputs.each(function () {\n        // Only use one checkbox per group since validateCheckbox() iterates over all associated checkboxes\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)[0].type === 'checkbox') {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('name') === checkboxGroupName) return true;\n          checkboxGroupName = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('name');\n        }\n\n        acc.push(_this.validateInput(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)));\n      });\n      var noError = acc.indexOf(false) === -1;\n      this.$element.find('[data-abide-error]').each(function (i, elem) {\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(elem); // Ensure a11y attributes are set\n\n        if (_this8.options.a11yAttributes) _this8.addGlobalErrorA11yAttributes($elem); // Show or hide the error\n\n        $elem.css('display', noError ? 'none' : 'block');\n      });\n      /**\n       * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.\n       * Trigger includes the element of the form.\n       * @event Abide#formvalid\n       * @event Abide#forminvalid\n       */\n\n      this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);\n      return noError;\n    }\n    /**\n     * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.\n     * @param {Object} $el - jQuery object to validate, should be a text input HTML element\n     * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns\n     * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified\n     */\n\n  }, {\n    key: \"validateText\",\n    value: function validateText($el, pattern) {\n      // A pattern can be passed to this function, or it will be infered from the input's \"pattern\" attribute, or it's \"type\" attribute\n      pattern = pattern || $el.attr('data-pattern') || $el.attr('pattern') || $el.attr('type');\n      var inputText = $el.val();\n      var valid = true;\n\n      if (inputText.length) {\n        // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp\n        if (this.options.patterns.hasOwnProperty(pattern)) {\n          valid = this.options.patterns[pattern].test(inputText);\n        } // If the pattern name isn't also the type attribute of the field, then test it as a regexp\n        else if (pattern !== $el.attr('type')) {\n            valid = new RegExp(pattern).test(inputText);\n          }\n      }\n\n      return valid;\n    }\n    /**\n     * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.\n     * @param {String} groupName - A string that specifies the name of a radio button group\n     * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)\n     */\n\n  }, {\n    key: \"validateRadio\",\n    value: function validateRadio(groupName) {\n      // If at least one radio in the group has the `required` attribute, the group is considered required\n      // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice\n      var $group = this.$element.find(\":radio[name=\\\"\".concat(groupName, \"\\\"]\"));\n      var valid = false,\n          required = false; // For the group to be required, at least one radio needs to be required\n\n      $group.each(function (i, e) {\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).attr('required')) {\n          required = true;\n        }\n      });\n      if (!required) valid = true;\n\n      if (!valid) {\n        // For the group to be valid, at least one radio needs to be checked\n        $group.each(function (i, e) {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).prop('checked')) {\n            valid = true;\n          }\n        });\n      }\n\n      return valid;\n    }\n    /**\n     * Determines whether or a not a checkbox input is valid based on whether or not it is required and checked. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all checkboxes in its group.\n     * @param {String} groupName - A string that specifies the name of a checkbox group\n     * @returns {Boolean} Boolean value depends on whether or not at least one checkbox input has been checked (if it's required)\n     */\n\n  }, {\n    key: \"validateCheckbox\",\n    value: function validateCheckbox(groupName) {\n      var _this9 = this;\n\n      // If at least one checkbox in the group has the `required` attribute, the group is considered required\n      // Per W3C spec, all checkboxes in a group should have `required`, but we're being nice\n      var $group = this.$element.find(\":checkbox[name=\\\"\".concat(groupName, \"\\\"]\"));\n      var valid = false,\n          required = false,\n          minRequired = 1,\n          checked = 0; // For the group to be required, at least one checkbox needs to be required\n\n      $group.each(function (i, e) {\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).attr('required')) {\n          required = true;\n        }\n      });\n      if (!required) valid = true;\n\n      if (!valid) {\n        // Count checked checkboxes within the group\n        // Use data-min-required if available (default: 1)\n        $group.each(function (i, e) {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).prop('checked')) {\n            checked++;\n          }\n\n          if (typeof jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).attr('data-min-required') !== 'undefined') {\n            minRequired = parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e).attr('data-min-required'));\n          }\n        }); // For the group to be valid, the minRequired amount of checkboxes have to be checked\n\n        if (checked >= minRequired) {\n          valid = true;\n        }\n      } // Skip validation if more than 1 checkbox have to be checked AND if the form hasn't got submitted yet (otherwise it will already show an error during the first fill in)\n\n\n      if (this.initialized !== true && minRequired > 1) {\n        return true;\n      } // Refresh error class for all input\n\n\n      $group.each(function (i, e) {\n        if (!valid) {\n          _this9.addErrorClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e), ['required']);\n        } else {\n          _this9.removeErrorClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(e));\n        }\n      });\n      return valid;\n    }\n    /**\n     * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator=\"foo bar baz\"` in a space separated listed.\n     * @param {Object} $el - jQuery input element.\n     * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.\n     * @param {Boolean} required - self explanatory?\n     * @returns {Boolean} - true if validations passed.\n     */\n\n  }, {\n    key: \"matchValidation\",\n    value: function matchValidation($el, validators, required) {\n      var _this10 = this;\n\n      required = required ? true : false;\n      var clear = validators.split(' ').map(function (v) {\n        return _this10.options.validators[v]($el, required, $el.parent());\n      });\n      return clear.indexOf(false) === -1;\n    }\n    /**\n     * Resets form inputs and styles\n     * @fires Abide#formreset\n     */\n\n  }, {\n    key: \"resetForm\",\n    value: function resetForm() {\n      var $form = this.$element,\n          opts = this.options;\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\".\".concat(opts.labelErrorClass), $form).not('small').removeClass(opts.labelErrorClass);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\".\".concat(opts.inputErrorClass), $form).not('small').removeClass(opts.inputErrorClass);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"\".concat(opts.formErrorSelector, \".\").concat(opts.formErrorClass)).removeClass(opts.formErrorClass);\n      $form.find('[data-abide-error]').css('display', 'none');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').attr({\n        'data-invalid': null,\n        'aria-invalid': null\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).attr({\n        'data-invalid': null,\n        'aria-invalid': null\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).attr({\n        'data-invalid': null,\n        'aria-invalid': null\n      });\n      /**\n       * Fires when the form has been reset.\n       * @event Abide#formreset\n       */\n\n      $form.trigger('formreset.zf.abide', [$form]);\n    }\n    /**\n     * Destroys an instance of Abide.\n     * Removes error styles and classes from elements, without resetting their values.\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var _this = this;\n\n      this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');\n      this.$inputs.off('.abide').each(function () {\n        _this.removeErrorClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\n      });\n      this.$submits.off('.abide');\n    }\n  }]);\n\n  return Abide;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n/**\n * Default settings for plugin\n */\n\n\nAbide.defaults = {\n  /**\n   * The default event to validate inputs. Checkboxes and radios validate immediately.\n   * Remove or change this value for manual validation.\n   * @option\n   * @type {?string}\n   * @default 'fieldChange'\n   */\n  validateOn: 'fieldChange',\n\n  /**\n   * Class to be applied to input labels on failed validation.\n   * @option\n   * @type {string}\n   * @default 'is-invalid-label'\n   */\n  labelErrorClass: 'is-invalid-label',\n\n  /**\n   * Class to be applied to inputs on failed validation.\n   * @option\n   * @type {string}\n   * @default 'is-invalid-input'\n   */\n  inputErrorClass: 'is-invalid-input',\n\n  /**\n   * Class selector to use to target Form Errors for show/hide.\n   * @option\n   * @type {string}\n   * @default '.form-error'\n   */\n  formErrorSelector: '.form-error',\n\n  /**\n   * Class added to Form Errors on failed validation.\n   * @option\n   * @type {string}\n   * @default 'is-visible'\n   */\n  formErrorClass: 'is-visible',\n\n  /**\n   * If true, automatically insert when possible:\n   * - `[aria-describedby]` on fields\n   * - `[role=alert]` on form errors and `[for]` on form error labels\n   * - `[aria-live]` on global errors `[data-abide-error]` (see option `a11yErrorLevel`).\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  a11yAttributes: true,\n\n  /**\n   * [aria-live] attribute value to be applied on global errors `[data-abide-error]`.\n   * Options are: 'assertive', 'polite' and 'off'/null\n   * @option\n   * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions\n   * @type {string}\n   * @default 'assertive'\n   */\n  a11yErrorLevel: 'assertive',\n\n  /**\n   * Set to true to validate text inputs on any value change.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  liveValidate: false,\n\n  /**\n   * Set to true to validate inputs on blur.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  validateOnBlur: false,\n  patterns: {\n    alpha: /^[a-zA-Z]+$/,\n    alpha_numeric: /^[a-zA-Z0-9]+$/,\n    integer: /^[-+]?\\d+$/,\n    number: /^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,\n    // amex, visa, diners\n    card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,\n    cvv: /^([0-9]){3,4}$/,\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address\n    email: /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,\n    // From CommonRegexJS (@talyssonoc)\n    // https://github.com/talyssonoc/CommonRegexJS/blob/e2901b9f57222bc14069dc8f0598d5f412555411/lib/commonregex.js#L76\n    // For more restrictive URL Regexs, see https://mathiasbynens.be/demo/url-regex.\n    url: /^((?:(https?|ftps?|file|ssh|sftp):\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\((?:[^\\s()<>]+|(?:\\([^\\s()<>]+\\)))*\\))+(?:\\((?:[^\\s()<>]+|(?:\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:\\'\".,<>?\\xab\\xbb\\u201c\\u201d\\u2018\\u2019]))$/,\n    // abc.de\n    domain: /^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,\n    datetime: /^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,\n    // YYYY-MM-DD\n    date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,\n    // HH:MM:SS\n    time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,\n    dateISO: /^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,\n    // MM/DD/YYYY\n    month_day_year: /^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,\n    // DD/MM/YYYY\n    day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,\n    // #FFF or #FFFFFF\n    color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,\n    // Domain || URL\n    website: {\n      test: function test(text) {\n        return Abide.defaults.patterns['domain'].test(text) || Abide.defaults.patterns['url'].test(text);\n      }\n    }\n  },\n\n  /**\n   * Optional validation functions to be used. `equalTo` being the only default included function.\n   * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:\n   * el : The jQuery element to validate.\n   * required : Boolean value of the required attribute be present or not.\n   * parent : The direct parent of the input.\n   * @option\n   */\n  validators: {\n    equalTo: function equalTo(el, required, parent) {\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(el.attr('data-equalto'))).val() === el.val();\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./js/foundation.abide.js?");/***/},/***/"./js/foundation.accordion.js":/*!************************************!*\
	  !*** ./js/foundation.accordion.js ***!
	  \************************************/ /*! exports provided: Accordion */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Accordion\", function() { return Accordion; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n/**\n * Accordion module.\n * @module foundation.accordion\n * @requires foundation.util.keyboard\n */\n\nvar Accordion =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Accordion, _Plugin);\n\n  function Accordion() {\n    _classCallCheck(this, Accordion);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Accordion).apply(this, arguments));\n  }\n\n  _createClass(Accordion, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of an accordion.\n     * @class\n     * @name Accordion\n     * @fires Accordion#init\n     * @param {jQuery} element - jQuery object to make into an accordion.\n     * @param {Object} options - a plain object with settings to override the default options.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Accordion.defaults, this.$element.data(), options);\n      this.className = 'Accordion'; // ie9 back compat\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].register('Accordion', {\n        'ENTER': 'toggle',\n        'SPACE': 'toggle',\n        'ARROW_DOWN': 'next',\n        'ARROW_UP': 'previous'\n      });\n    }\n    /**\n     * Initializes the accordion by animating the preset active pane(s).\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var _this2 = this;\n\n      this._isInitializing = true;\n      this.$element.attr('role', 'tablist');\n      this.$tabs = this.$element.children('[data-accordion-item]');\n      this.$tabs.attr({\n        'role': 'presentation'\n      });\n      this.$tabs.each(function (idx, el) {\n        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el),\n            $content = $el.children('[data-tab-content]'),\n            id = $content[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'accordion'),\n            linkId = el.id ? \"\".concat(el.id, \"-label\") : \"\".concat(id, \"-label\");\n        $el.find('a:first').attr({\n          'aria-controls': id,\n          'role': 'tab',\n          'id': linkId,\n          'aria-expanded': false,\n          'aria-selected': false\n        });\n        $content.attr({\n          'role': 'tabpanel',\n          'aria-labelledby': linkId,\n          'aria-hidden': true,\n          'id': id\n        });\n      });\n      var $initActive = this.$element.find('.is-active').children('[data-tab-content]');\n\n      if ($initActive.length) {\n        // Save up the initial hash to return to it later when going back in history\n        this._initialAnchor = $initActive.prev('a').attr('href');\n\n        this._openSingleTab($initActive);\n      }\n\n      this._checkDeepLink = function () {\n        var anchor = window.location.hash;\n\n        if (!anchor.length) {\n          // If we are still initializing and there is no anchor, then there is nothing to do\n          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor\n\n          if (_this2._initialAnchor) anchor = _this2._initialAnchor;\n        }\n\n        var $anchor = anchor && jquery__WEBPACK_IMPORTED_MODULE_0___default()(anchor);\n\n        var $link = anchor && _this2.$element.find(\"[href$=\\\"\".concat(anchor, \"\\\"]\")); // Whether the anchor element that has been found is part of this element\n\n\n        var isOwnAnchor = !!($anchor.length && $link.length);\n\n        if (isOwnAnchor) {\n          // If there is an anchor for the hash, open it (if not already active)\n          if ($anchor && $link && $link.length) {\n            if (!$link.parent('[data-accordion-item]').hasClass('is-active')) {\n              _this2._openSingleTab($anchor);\n            }\n          } // Otherwise, close everything\n          else {\n              _this2._closeAllTabs();\n            } // Roll up a little to show the titles\n\n\n          if (_this2.options.deepLinkSmudge) {\n            Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"onLoad\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\n              var offset = _this2.$element.offset();\n\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').animate({\n                scrollTop: offset.top - _this2.options.deepLinkSmudgeOffset\n              }, _this2.options.deepLinkSmudgeDelay);\n            });\n          }\n          /**\n           * Fires when the plugin has deeplinked at pageload\n           * @event Accordion#deeplink\n           */\n\n\n          _this2.$element.trigger('deeplink.zf.accordion', [$link, $anchor]);\n        }\n      }; //use browser to open a tab, if it exists in this tabset\n\n\n      if (this.options.deepLink) {\n        this._checkDeepLink();\n      }\n\n      this._events();\n\n      this._isInitializing = false;\n    }\n    /**\n     * Adds event handlers for items within the accordion.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      this.$tabs.each(function () {\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\n        var $tabContent = $elem.children('[data-tab-content]');\n\n        if ($tabContent.length) {\n          $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {\n            e.preventDefault();\n\n            _this.toggle($tabContent);\n          }).on('keydown.zf.accordion', function (e) {\n            _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].handleKey(e, 'Accordion', {\n              toggle: function toggle() {\n                _this.toggle($tabContent);\n              },\n              next: function next() {\n                var $a = $elem.next().find('a').focus();\n\n                if (!_this.options.multiExpand) {\n                  $a.trigger('click.zf.accordion');\n                }\n              },\n              previous: function previous() {\n                var $a = $elem.prev().find('a').focus();\n\n                if (!_this.options.multiExpand) {\n                  $a.trigger('click.zf.accordion');\n                }\n              },\n              handled: function handled() {\n                e.preventDefault();\n              }\n            });\n          });\n        }\n      });\n\n      if (this.options.deepLink) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('hashchange', this._checkDeepLink);\n      }\n    }\n    /**\n     * Toggles the selected content pane's open/close state.\n     * @param {jQuery} $target - jQuery object of the pane to toggle (`.accordion-content`).\n     * @function\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle($target) {\n      if ($target.closest('[data-accordion]').is('[disabled]')) {\n        console.info('Cannot toggle an accordion that is disabled.');\n        return;\n      }\n\n      if ($target.parent().hasClass('is-active')) {\n        this.up($target);\n      } else {\n        this.down($target);\n      } //either replace or update browser history\n\n\n      if (this.options.deepLink) {\n        var anchor = $target.prev('a').attr('href');\n\n        if (this.options.updateHistory) {\n          history.pushState({}, '', anchor);\n        } else {\n          history.replaceState({}, '', anchor);\n        }\n      }\n    }\n    /**\n     * Opens the accordion tab defined by `$target`.\n     * @param {jQuery} $target - Accordion pane to open (`.accordion-content`).\n     * @fires Accordion#down\n     * @function\n     */\n\n  }, {\n    key: \"down\",\n    value: function down($target) {\n      if ($target.closest('[data-accordion]').is('[disabled]')) {\n        console.info('Cannot call down on an accordion that is disabled.');\n        return;\n      }\n\n      if (this.options.multiExpand) this._openTab($target);else this._openSingleTab($target);\n    }\n    /**\n     * Closes the tab defined by `$target`.\n     * It may be ignored if the Accordion options don't allow it.\n     *\n     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).\n     * @fires Accordion#up\n     * @function\n     */\n\n  }, {\n    key: \"up\",\n    value: function up($target) {\n      if (this.$element.is('[disabled]')) {\n        console.info('Cannot call up on an accordion that is disabled.');\n        return;\n      } // Don't close the item if it is already closed\n\n\n      var $targetItem = $target.parent();\n      if (!$targetItem.hasClass('is-active')) return; // Don't close the item if there is no other active item (unless with `allowAllClosed`)\n\n      var $othersItems = $targetItem.siblings();\n      if (!this.options.allowAllClosed && !$othersItems.hasClass('is-active')) return;\n\n      this._closeTab($target);\n    }\n    /**\n     * Make the tab defined by `$target` the only opened tab, closing all others tabs.\n     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_openSingleTab\",\n    value: function _openSingleTab($target) {\n      // Close all the others active tabs.\n      var $activeContents = this.$element.children('.is-active').children('[data-tab-content]');\n\n      if ($activeContents.length) {\n        this._closeTab($activeContents.not($target));\n      } // Then open the target.\n\n\n      this._openTab($target);\n    }\n    /**\n     * Opens the tab defined by `$target`.\n     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).\n     * @fires Accordion#down\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_openTab\",\n    value: function _openTab($target) {\n      var _this3 = this;\n\n      var $targetItem = $target.parent();\n      var targetContentId = $target.attr('aria-labelledby');\n      $target.attr('aria-hidden', false);\n      $targetItem.addClass('is-active');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(targetContentId)).attr({\n        'aria-expanded': true,\n        'aria-selected': true\n      });\n      $target.finish().slideDown(this.options.slideSpeed, function () {\n        /**\n         * Fires when the tab is done opening.\n         * @event Accordion#down\n         */\n        _this3.$element.trigger('down.zf.accordion', [$target]);\n      });\n    }\n    /**\n     * Closes the tab defined by `$target`.\n     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).\n     * @fires Accordion#up\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_closeTab\",\n    value: function _closeTab($target) {\n      var _this4 = this;\n\n      var $targetItem = $target.parent();\n      var targetContentId = $target.attr('aria-labelledby');\n      $target.attr('aria-hidden', true);\n      $targetItem.removeClass('is-active');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(targetContentId)).attr({\n        'aria-expanded': false,\n        'aria-selected': false\n      });\n      $target.finish().slideUp(this.options.slideSpeed, function () {\n        /**\n         * Fires when the tab is done collapsing up.\n         * @event Accordion#up\n         */\n        _this4.$element.trigger('up.zf.accordion', [$target]);\n      });\n    }\n    /**\n     * Closes all active tabs\n     * @fires Accordion#up\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_closeAllTabs\",\n    value: function _closeAllTabs() {\n      var $activeTabs = this.$element.children('.is-active').children('[data-tab-content]');\n\n      if ($activeTabs.length) {\n        this._closeTab($activeTabs);\n      }\n    }\n    /**\n     * Destroys an instance of an accordion.\n     * @fires Accordion#destroyed\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');\n      this.$element.find('a').off('.zf.accordion');\n\n      if (this.options.deepLink) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('hashchange', this._checkDeepLink);\n      }\n    }\n  }]);\n\n  return Accordion;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n\nAccordion.defaults = {\n  /**\n   * Amount of time to animate the opening of an accordion pane.\n   * @option\n   * @type {number}\n   * @default 250\n   */\n  slideSpeed: 250,\n\n  /**\n   * Allow the accordion to have multiple open panes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  multiExpand: false,\n\n  /**\n   * Allow the accordion to close all panes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  allowAllClosed: false,\n\n  /**\n   * Link the location hash to the open pane.\n   * Set the location hash when the opened pane changes, and open and scroll to the corresponding pane when the location changes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  deepLink: false,\n\n  /**\n   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the accordion panel is visible\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  deepLinkSmudge: false,\n\n  /**\n   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment\n   * @option\n   * @type {number}\n   * @default 300\n   */\n  deepLinkSmudgeDelay: 300,\n\n  /**\n   * If `deepLinkSmudge` is enabled, the offset for scrollToTtop to prevent overlap by a sticky element at the top of the page\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  deepLinkSmudgeOffset: 0,\n\n  /**\n   * If `deepLink` is enabled, update the browser history with the open accordion\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  updateHistory: false\n};\n\n\n//# sourceURL=webpack:///./js/foundation.accordion.js?");/***/},/***/"./js/foundation.accordionMenu.js":/*!****************************************!*\
	  !*** ./js/foundation.accordionMenu.js ***!
	  \****************************************/ /*! exports provided: AccordionMenu */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AccordionMenu\", function() { return AccordionMenu; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.nest */ \"./js/foundation.util.nest.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * AccordionMenu module.\n * @module foundation.accordionMenu\n * @requires foundation.util.keyboard\n * @requires foundation.util.nest\n */\n\nvar AccordionMenu =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(AccordionMenu, _Plugin);\n\n  function AccordionMenu() {\n    _classCallCheck(this, AccordionMenu);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AccordionMenu).apply(this, arguments));\n  }\n\n  _createClass(AccordionMenu, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of an accordion menu.\n     * @class\n     * @name AccordionMenu\n     * @fires AccordionMenu#init\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, AccordionMenu.defaults, this.$element.data(), options);\n      this.className = 'AccordionMenu'; // ie9 back compat\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].register('AccordionMenu', {\n        'ENTER': 'toggle',\n        'SPACE': 'toggle',\n        'ARROW_RIGHT': 'open',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'close',\n        'ESCAPE': 'closeAll'\n      });\n    }\n    /**\n     * Initializes the accordion menu by hiding all nested menus.\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\"Nest\"].Feather(this.$element, 'accordion');\n\n      var _this = this;\n\n      this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');\n\n      this.$element.attr({\n        'role': 'tree',\n        'aria-multiselectable': this.options.multiOpen\n      });\n      this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');\n      this.$menuLinks.each(function () {\n        var linkId = this.id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'acc-menu-link'),\n            $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            $sub = $elem.children('[data-submenu]'),\n            subId = $sub[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'acc-menu'),\n            isActive = $sub.hasClass('is-active');\n\n        if (_this.options.parentLink) {\n          var $anchor = $elem.children('a');\n          $anchor.clone().prependTo($sub).wrap('<li data-is-parent-link class=\"is-submenu-parent-item is-submenu-item is-accordion-submenu-item\"></li>');\n        }\n\n        if (_this.options.submenuToggle) {\n          $elem.addClass('has-submenu-toggle');\n          $elem.children('a').after('<button id=\"' + linkId + '\" class=\"submenu-toggle\" aria-controls=\"' + subId + '\" aria-expanded=\"' + isActive + '\" title=\"' + _this.options.submenuToggleText + '\"><span class=\"submenu-toggle-text\">' + _this.options.submenuToggleText + '</span></button>');\n        } else {\n          $elem.attr({\n            'aria-controls': subId,\n            'aria-expanded': isActive,\n            'id': linkId\n          });\n        }\n\n        $sub.attr({\n          'aria-labelledby': linkId,\n          'aria-hidden': !isActive,\n          'role': 'group',\n          'id': subId\n        });\n      });\n      this.$element.find('li').attr({\n        'role': 'treeitem'\n      });\n      var initPanes = this.$element.find('.is-active');\n\n      if (initPanes.length) {\n        initPanes.each(function () {\n          _this.down(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\n        });\n      }\n\n      this._events();\n    }\n    /**\n     * Adds event handlers for items within the menu.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      this.$element.find('li').each(function () {\n        var $submenu = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('[data-submenu]');\n\n        if ($submenu.length) {\n          if (_this.options.submenuToggle) {\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('.submenu-toggle').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\n              _this.toggle($submenu);\n            });\n          } else {\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\n              e.preventDefault();\n\n              _this.toggle($submenu);\n            });\n          }\n        }\n      }).on('keydown.zf.accordionMenu', function (e) {\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            $elements = $element.parent('ul').children('li'),\n            $prevElement,\n            $nextElement,\n            $target = $element.children('[data-submenu]');\n        $elements.each(function (i) {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\n            $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();\n            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();\n\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('[data-submenu]:visible').length) {\n              // has open sub menu\n              $nextElement = $element.find('li:first-child').find('a').first();\n            }\n\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':first-child')) {\n              // is first element of sub menu\n              $prevElement = $element.parents('li').first().find('a').first();\n            } else if ($prevElement.parents('li').first().children('[data-submenu]:visible').length) {\n              // if previous element has open sub menu\n              $prevElement = $prevElement.parents('li').find('li:last-child').find('a').first();\n            }\n\n            if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':last-child')) {\n              // is last element of sub menu\n              $nextElement = $element.parents('li').first().next('li').find('a').first();\n            }\n\n            return;\n          }\n        });\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].handleKey(e, 'AccordionMenu', {\n          open: function open() {\n            if ($target.is(':hidden')) {\n              _this.down($target);\n\n              $target.find('li').first().find('a').first().focus();\n            }\n          },\n          close: function close() {\n            if ($target.length && !$target.is(':hidden')) {\n              // close active sub of this item\n              _this.up($target);\n            } else if ($element.parent('[data-submenu]').length) {\n              // close currently open sub\n              _this.up($element.parent('[data-submenu]'));\n\n              $element.parents('li').first().find('a').first().focus();\n            }\n          },\n          up: function up() {\n            $prevElement.focus();\n            return true;\n          },\n          down: function down() {\n            $nextElement.focus();\n            return true;\n          },\n          toggle: function toggle() {\n            if (_this.options.submenuToggle) {\n              return false;\n            }\n\n            if ($element.children('[data-submenu]').length) {\n              _this.toggle($element.children('[data-submenu]'));\n\n              return true;\n            }\n          },\n          closeAll: function closeAll() {\n            _this.hideAll();\n          },\n          handled: function handled(preventDefault) {\n            if (preventDefault) {\n              e.preventDefault();\n            }\n          }\n        });\n      }); //.attr('tabindex', 0);\n    }\n    /**\n     * Closes all panes of the menu.\n     * @function\n     */\n\n  }, {\n    key: \"hideAll\",\n    value: function hideAll() {\n      this.up(this.$element.find('[data-submenu]'));\n    }\n    /**\n     * Opens all panes of the menu.\n     * @function\n     */\n\n  }, {\n    key: \"showAll\",\n    value: function showAll() {\n      this.down(this.$element.find('[data-submenu]'));\n    }\n    /**\n     * Toggles the open/close state of a submenu.\n     * @function\n     * @param {jQuery} $target - the submenu to toggle\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle($target) {\n      if (!$target.is(':animated')) {\n        if (!$target.is(':hidden')) {\n          this.up($target);\n        } else {\n          this.down($target);\n        }\n      }\n    }\n    /**\n     * Opens the sub-menu defined by `$target`.\n     * @param {jQuery} $target - Sub-menu to open.\n     * @fires AccordionMenu#down\n     */\n\n  }, {\n    key: \"down\",\n    value: function down($target) {\n      var _this2 = this;\n\n      // If having multiple submenus active is disabled, close all the submenus\n      // that are not parents or children of the targeted submenu.\n      if (!this.options.multiOpen) {\n        // The \"branch\" of the targetted submenu, from the component root to\n        // the active submenus nested in it.\n        var $targetBranch = $target.parentsUntil(this.$element).add($target).add($target.find('.is-active')); // All the active submenus that are not in the branch.\n\n        var $othersActiveSubmenus = this.$element.find('.is-active').not($targetBranch);\n        this.up($othersActiveSubmenus);\n      }\n\n      $target.addClass('is-active').attr({\n        'aria-hidden': false\n      });\n\n      if (this.options.submenuToggle) {\n        $target.prev('.submenu-toggle').attr({\n          'aria-expanded': true\n        });\n      } else {\n        $target.parent('.is-accordion-submenu-parent').attr({\n          'aria-expanded': true\n        });\n      }\n\n      $target.slideDown(this.options.slideSpeed, function () {\n        /**\n         * Fires when the menu is done opening.\n         * @event AccordionMenu#down\n         */\n        _this2.$element.trigger('down.zf.accordionMenu', [$target]);\n      });\n    }\n    /**\n     * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.\n     * @param {jQuery} $target - Sub-menu to close.\n     * @fires AccordionMenu#up\n     */\n\n  }, {\n    key: \"up\",\n    value: function up($target) {\n      var _this3 = this;\n\n      var $submenus = $target.find('[data-submenu]');\n      var $allmenus = $target.add($submenus);\n      $submenus.slideUp(0);\n      $allmenus.removeClass('is-active').attr('aria-hidden', true);\n\n      if (this.options.submenuToggle) {\n        $allmenus.prev('.submenu-toggle').attr('aria-expanded', false);\n      } else {\n        $allmenus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);\n      }\n\n      $target.slideUp(this.options.slideSpeed, function () {\n        /**\n         * Fires when the menu is done collapsing up.\n         * @event AccordionMenu#up\n         */\n        _this3.$element.trigger('up.zf.accordionMenu', [$target]);\n      });\n    }\n    /**\n     * Destroys an instance of accordion menu.\n     * @fires AccordionMenu#destroyed\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.find('[data-submenu]').slideDown(0).css('display', '');\n      this.$element.find('a').off('click.zf.accordionMenu');\n      this.$element.find('[data-is-parent-link]').detach();\n\n      if (this.options.submenuToggle) {\n        this.$element.find('.has-submenu-toggle').removeClass('has-submenu-toggle');\n        this.$element.find('.submenu-toggle').remove();\n      }\n\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\"Nest\"].Burn(this.$element, 'accordion');\n    }\n  }]);\n\n  return AccordionMenu;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\"Plugin\"]);\n\nAccordionMenu.defaults = {\n  /**\n   * Adds the parent link to the submenu.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  parentLink: false,\n\n  /**\n   * Amount of time to animate the opening of a submenu in ms.\n   * @option\n   * @type {number}\n   * @default 250\n   */\n  slideSpeed: 250,\n\n  /**\n   * Adds a separate submenu toggle button. This allows the parent item to have a link.\n   * @option\n   * @example true\n   */\n  submenuToggle: false,\n\n  /**\n   * The text used for the submenu toggle if enabled. This is used for screen readers only.\n   * @option\n   * @example true\n   */\n  submenuToggleText: 'Toggle menu',\n\n  /**\n   * Allow the menu to have multiple open panes.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  multiOpen: true\n};\n\n\n//# sourceURL=webpack:///./js/foundation.accordionMenu.js?");/***/},/***/"./js/foundation.core.js":/*!*******************************!*\
	  !*** ./js/foundation.core.js ***!
	  \*******************************/ /*! exports provided: Foundation */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Foundation\", function() { return Foundation; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\nvar FOUNDATION_VERSION = '6.6.3'; // Global Foundation object\n// This is attached to the window, or used as a module for AMD/Browserify\n\nvar Foundation = {\n  version: FOUNDATION_VERSION,\n\n  /**\n   * Stores initialized plugins.\n   */\n  _plugins: {},\n\n  /**\n   * Stores generated unique ids for plugin instances\n   */\n  _uuids: [],\n\n  /**\n   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\n   * @param {Object} plugin - The constructor of the plugin.\n   */\n  plugin: function plugin(_plugin, name) {\n    // Object key to use when adding to global Foundation object\n    // Examples: Foundation.Reveal, Foundation.OffCanvas\n    var className = name || functionName(_plugin); // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\n    // Examples: data-reveal, data-off-canvas\n\n    var attrName = hyphenate(className); // Add to the Foundation object and the plugins list (for reflowing)\n\n    this._plugins[attrName] = this[className] = _plugin;\n  },\n\n  /**\n   * @function\n   * Populates the _uuids array with pointers to each individual plugin instance.\n   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\n   * Also fires the initialization event for each plugin, consolidating repetitive code.\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n   * @param {String} name - the name of the plugin, passed as a camelCased string.\n   * @fires Plugin#init\n   */\n  registerPlugin: function registerPlugin(plugin, name) {\n    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\n    plugin.uuid = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"GetYoDigits\"])(6, pluginName);\n\n    if (!plugin.$element.attr(\"data-\".concat(pluginName))) {\n      plugin.$element.attr(\"data-\".concat(pluginName), plugin.uuid);\n    }\n\n    if (!plugin.$element.data('zfPlugin')) {\n      plugin.$element.data('zfPlugin', plugin);\n    }\n    /**\n     * Fires when the plugin has initialized.\n     * @event Plugin#init\n     */\n\n\n    plugin.$element.trigger(\"init.zf.\".concat(pluginName));\n\n    this._uuids.push(plugin.uuid);\n\n    return;\n  },\n\n  /**\n   * @function\n   * Removes the plugins uuid from the _uuids array.\n   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\n   * Also fires the destroyed event for the plugin, consolidating repetitive code.\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n   * @fires Plugin#destroyed\n   */\n  unregisterPlugin: function unregisterPlugin(plugin) {\n    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\n\n    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\n\n    plugin.$element.removeAttr(\"data-\".concat(pluginName)).removeData('zfPlugin')\n    /**\n     * Fires when the plugin has been destroyed.\n     * @event Plugin#destroyed\n     */\n    .trigger(\"destroyed.zf.\".concat(pluginName));\n\n    for (var prop in plugin) {\n      plugin[prop] = null; //clean up script to prep for garbage collection.\n    }\n\n    return;\n  },\n\n  /**\n   * @function\n   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\n   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\n   * @default If no argument is passed, reflow all currently active plugins.\n   */\n  reInit: function reInit(plugins) {\n    var isJQ = plugins instanceof jquery__WEBPACK_IMPORTED_MODULE_0___default.a;\n\n    try {\n      if (isJQ) {\n        plugins.each(function () {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('zfPlugin')._init();\n        });\n      } else {\n        var type = _typeof(plugins),\n            _this = this,\n            fns = {\n          'object': function object(plgs) {\n            plgs.forEach(function (p) {\n              p = hyphenate(p);\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-' + p + ']').foundation('_init');\n            });\n          },\n          'string': function string() {\n            plugins = hyphenate(plugins);\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-' + plugins + ']').foundation('_init');\n          },\n          'undefined': function undefined() {\n            this['object'](Object.keys(_this._plugins));\n          }\n        };\n\n        fns[type](plugins);\n      }\n    } catch (err) {\n      console.error(err);\n    } finally {\n      return plugins;\n    }\n  },\n\n  /**\n   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\n   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\n   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\n   */\n  reflow: function reflow(elem, plugins) {\n    // If plugins is undefined, just grab everything\n    if (typeof plugins === 'undefined') {\n      plugins = Object.keys(this._plugins);\n    } // If plugins is a string, convert it to an array with one item\n    else if (typeof plugins === 'string') {\n        plugins = [plugins];\n      }\n\n    var _this = this; // Iterate through each plugin\n\n\n    jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(plugins, function (i, name) {\n      // Get the current plugin\n      var plugin = _this._plugins[name]; // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\n\n      var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(elem).find('[data-' + name + ']').addBack('[data-' + name + ']').filter(function () {\n        return typeof jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(\"zfPlugin\") === 'undefined';\n      }); // For each plugin found, initialize it\n\n      $elem.each(function () {\n        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            opts = {\n          reflow: true\n        };\n\n        if ($el.attr('data-options')) {\n          $el.attr('data-options').split(';').forEach(function (option, _index) {\n            var opt = option.split(':').map(function (el) {\n              return el.trim();\n            });\n            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\n          });\n        }\n\n        try {\n          $el.data('zfPlugin', new plugin(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), opts));\n        } catch (er) {\n          console.error(er);\n        } finally {\n          return;\n        }\n      });\n    });\n  },\n  getFnName: functionName,\n  addToJquery: function addToJquery($) {\n    // TODO: consider not making this a jQuery function\n    // TODO: need way to reflow vs. re-initialize\n\n    /**\n     * The Foundation jQuery method.\n     * @param {String|Array} method - An action to perform on the current jQuery object.\n     */\n    var foundation = function foundation(method) {\n      var type = _typeof(method),\n          $noJS = $('.no-js');\n\n      if ($noJS.length) {\n        $noJS.removeClass('no-js');\n      }\n\n      if (type === 'undefined') {\n        //needs to initialize the Foundation object, or an individual plugin.\n        _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"MediaQuery\"]._init();\n\n        Foundation.reflow(this);\n      } else if (type === 'string') {\n        //an individual method to invoke on a plugin or group of plugins\n        var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\n\n        var plugClass = this.data('zfPlugin'); //determine the class of plugin\n\n        if (typeof plugClass !== 'undefined' && typeof plugClass[method] !== 'undefined') {\n          //make sure both the class and method exist\n          if (this.length === 1) {\n            //if there's only one, call it directly.\n            plugClass[method].apply(plugClass, args);\n          } else {\n            this.each(function (i, el) {\n              //otherwise loop through the jQuery collection and invoke the method on each\n              plugClass[method].apply($(el).data('zfPlugin'), args);\n            });\n          }\n        } else {\n          //error for no class or no method\n          throw new ReferenceError(\"We're sorry, '\" + method + \"' is not an available method for \" + (plugClass ? functionName(plugClass) : 'this element') + '.');\n        }\n      } else {\n        //error for invalid argument type\n        throw new TypeError(\"We're sorry, \".concat(type, \" is not a valid parameter. You must use a string representing the method you wish to invoke.\"));\n      }\n\n      return this;\n    };\n\n    $.fn.foundation = foundation;\n    return $;\n  }\n};\nFoundation.util = {\n  /**\n   * Function for applying a debounce effect to a function call.\n   * @function\n   * @param {Function} func - Function to be called at end of timeout.\n   * @param {Number} delay - Time in ms to delay the call of `func`.\n   * @returns function\n   */\n  throttle: function throttle(func, delay) {\n    var timer = null;\n    return function () {\n      var context = this,\n          args = arguments;\n\n      if (timer === null) {\n        timer = setTimeout(function () {\n          func.apply(context, args);\n          timer = null;\n        }, delay);\n      }\n    };\n  }\n};\nwindow.Foundation = Foundation; // Polyfill for requestAnimationFrame\n\n(function () {\n  if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\n    return new Date().getTime();\n  };\n  var vendors = ['webkit', 'moz'];\n\n  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n    var vp = vendors[i];\n    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\n  }\n\n  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n    var lastTime = 0;\n\n    window.requestAnimationFrame = function (callback) {\n      var now = Date.now();\n      var nextTime = Math.max(lastTime + 16, now);\n      return setTimeout(function () {\n        callback(lastTime = nextTime);\n      }, nextTime - now);\n    };\n\n    window.cancelAnimationFrame = clearTimeout;\n  }\n  /**\n   * Polyfill for performance.now, required by rAF\n   */\n\n\n  if (!window.performance || !window.performance.now) {\n    window.performance = {\n      start: Date.now(),\n      now: function now() {\n        return Date.now() - this.start;\n      }\n    };\n  }\n})();\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function fNOP() {},\n        fBound = function fBound() {\n      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    if (this.prototype) {\n      // native functions don't have a prototype\n      fNOP.prototype = this.prototype;\n    }\n\n    fBound.prototype = new fNOP();\n    return fBound;\n  };\n} // Polyfill to get the name of a function in IE9\n\n\nfunction functionName(fn) {\n  if (typeof Function.prototype.name === 'undefined') {\n    var funcNameRegex = /function\\s([^(]{1,})\\(/;\n    var results = funcNameRegex.exec(fn.toString());\n    return results && results.length > 1 ? results[1].trim() : \"\";\n  } else if (typeof fn.prototype === 'undefined') {\n    return fn.constructor.name;\n  } else {\n    return fn.prototype.constructor.name;\n  }\n}\n\nfunction parseValue(str) {\n  if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);\n  return str;\n} // Convert PascalCase to kebab-case\n// Thank you: http://stackoverflow.com/a/8955580\n\n\nfunction hyphenate(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.core.js?");/***/},/***/"./js/foundation.core.plugin.js":/*!**************************************!*\
	  !*** ./js/foundation.core.plugin.js ***!
	  \**************************************/ /*! exports provided: Plugin */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plugin\", function() { return Plugin; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Abstract class for providing lifecycle hooks. Expect plugins to define AT LEAST\n// {function} _setup (replaces previous constructor),\n// {function} _destroy (replaces previous destroy)\n\nvar Plugin =\n/*#__PURE__*/\nfunction () {\n  function Plugin(element, options) {\n    _classCallCheck(this, Plugin);\n\n    this._setup(element, options);\n\n    var pluginName = getPluginName(this);\n    this.uuid = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"GetYoDigits\"])(6, pluginName);\n\n    if (!this.$element.attr(\"data-\".concat(pluginName))) {\n      this.$element.attr(\"data-\".concat(pluginName), this.uuid);\n    }\n\n    if (!this.$element.data('zfPlugin')) {\n      this.$element.data('zfPlugin', this);\n    }\n    /**\n     * Fires when the plugin has initialized.\n     * @event Plugin#init\n     */\n\n\n    this.$element.trigger(\"init.zf.\".concat(pluginName));\n  }\n\n  _createClass(Plugin, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._destroy();\n\n      var pluginName = getPluginName(this);\n      this.$element.removeAttr(\"data-\".concat(pluginName)).removeData('zfPlugin')\n      /**\n       * Fires when the plugin has been destroyed.\n       * @event Plugin#destroyed\n       */\n      .trigger(\"destroyed.zf.\".concat(pluginName));\n\n      for (var prop in this) {\n        this[prop] = null; //clean up script to prep for garbage collection.\n      }\n    }\n  }]);\n\n  return Plugin;\n}(); // Convert PascalCase to kebab-case\n// Thank you: http://stackoverflow.com/a/8955580\n\n\nfunction hyphenate(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\nfunction getPluginName(obj) {\n  return hyphenate(obj.className);\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.core.plugin.js?");/***/},/***/"./js/foundation.core.utils.js":/*!*************************************!*\
	  !*** ./js/foundation.core.utils.js ***!
	  \*************************************/ /*! exports provided: rtl, GetYoDigits, RegExpEscape, transitionend, onLoad, ignoreMousedisappear */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rtl\", function() { return rtl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetYoDigits\", function() { return GetYoDigits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RegExpEscape\", function() { return RegExpEscape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transitionend\", function() { return transitionend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onLoad\", function() { return onLoad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ignoreMousedisappear\", function() { return ignoreMousedisappear; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n\n // Core Foundation Utilities, utilized in a number of places.\n\n/**\n * Returns a boolean for RTL support\n */\n\nfunction rtl() {\n  return jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').attr('dir') === 'rtl';\n}\n/**\n * returns a random base-36 uid with namespacing\n * @function\n * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\n * @param {String} namespace - name of plugin to be incorporated in uid, optional.\n * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\n * @returns {String} - unique id\n */\n\n\nfunction GetYoDigits() {\n  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n  var namespace = arguments.length > 1 ? arguments[1] : undefined;\n  var str = '';\n  var chars = '0123456789abcdefghijklmnopqrstuvwxyz';\n  var charsLength = chars.length;\n\n  for (var i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * charsLength)];\n  }\n\n  return namespace ? \"\".concat(str, \"-\").concat(namespace) : str;\n}\n/**\n * Escape a string so it can be used as a regexp pattern\n * @function\n * @see https://stackoverflow.com/a/9310752/4317384\n *\n * @param {String} str - string to escape.\n * @returns {String} - escaped string\n */\n\n\nfunction RegExpEscape(str) {\n  return str.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\nfunction transitionend($elem) {\n  var transitions = {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'transitionend',\n    'OTransition': 'otransitionend'\n  };\n  var elem = document.createElement('div'),\n      end;\n\n  for (var transition in transitions) {\n    if (typeof elem.style[transition] !== 'undefined') {\n      end = transitions[transition];\n    }\n  }\n\n  if (end) {\n    return end;\n  } else {\n    setTimeout(function () {\n      $elem.triggerHandler('transitionend', [$elem]);\n    }, 1);\n    return 'transitionend';\n  }\n}\n/**\n * Return an event type to listen for window load.\n *\n * If `$elem` is passed, an event will be triggered on `$elem`. If window is already loaded, the event will still be triggered.\n * If `handler` is passed, attach it to the event on `$elem`.\n * Calling `onLoad` without handler allows you to get the event type that will be triggered before attaching the handler by yourself.\n * @function\n *\n * @param {Object} [] $elem - jQuery element on which the event will be triggered if passed.\n * @param {Function} [] handler - function to attach to the event.\n * @returns {String} - event type that should or will be triggered.\n */\n\n\nfunction onLoad($elem, handler) {\n  var didLoad = document.readyState === 'complete';\n  var eventType = (didLoad ? '_didLoad' : 'load') + '.zf.util.onLoad';\n\n  var cb = function cb() {\n    return $elem.triggerHandler(eventType);\n  };\n\n  if ($elem) {\n    if (handler) $elem.one(eventType, handler);\n    if (didLoad) setTimeout(cb);else jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).one('load', cb);\n  }\n\n  return eventType;\n}\n/**\n * Retuns an handler for the `mouseleave` that ignore disappeared mouses.\n *\n * If the mouse \"disappeared\" from the document (like when going on a browser UI element, See https://git.io/zf-11410),\n * the event is ignored.\n * - If the `ignoreLeaveWindow` is `true`, the event is ignored when the user actually left the window\n *   (like by switching to an other window with [Alt]+[Tab]).\n * - If the `ignoreReappear` is `true`, the event will be ignored when the mouse will reappear later on the document\n *   outside of the element it left.\n *\n * @function\n *\n * @param {Function} [] handler - handler for the filtered `mouseleave` event to watch.\n * @param {Object} [] options - object of options:\n * - {Boolean} [false] ignoreLeaveWindow - also ignore when the user switched windows.\n * - {Boolean} [false] ignoreReappear - also ignore when the mouse reappeared outside of the element it left.\n * @returns {Function} - filtered handler to use to listen on the `mouseleave` event.\n */\n\n\nfunction ignoreMousedisappear(handler) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$ignoreLeaveWindo = _ref.ignoreLeaveWindow,\n      ignoreLeaveWindow = _ref$ignoreLeaveWindo === void 0 ? false : _ref$ignoreLeaveWindo,\n      _ref$ignoreReappear = _ref.ignoreReappear,\n      ignoreReappear = _ref$ignoreReappear === void 0 ? false : _ref$ignoreReappear;\n\n  return function leaveEventHandler(eLeave) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    var callback = handler.bind.apply(handler, [this, eLeave].concat(rest)); // The mouse left: call the given callback if the mouse entered elsewhere\n\n    if (eLeave.relatedTarget !== null) {\n      return callback();\n    } // Otherwise, check if the mouse actually left the window.\n    // In firefox if the user switched between windows, the window sill have the focus by the time\n    // the event is triggered. We have to debounce the event to test this case.\n\n\n    setTimeout(function leaveEventDebouncer() {\n      if (!ignoreLeaveWindow && document.hasFocus && !document.hasFocus()) {\n        return callback();\n      } // Otherwise, wait for the mouse to reeapear outside of the element,\n\n\n      if (!ignoreReappear) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).one('mouseenter', function reenterEventHandler(eReenter) {\n          if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(eLeave.currentTarget).has(eReenter.target).length) {\n            // Fill where the mouse finally entered.\n            eLeave.relatedTarget = eReenter.target;\n            callback();\n          }\n        });\n      }\n    }, 0);\n  };\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.core.utils.js?");/***/},/***/"./js/foundation.drilldown.js":/*!************************************!*\
	  !*** ./js/foundation.drilldown.js ***!
	  \************************************/ /*! exports provided: Drilldown */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Drilldown\", function() { return Drilldown; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.nest */ \"./js/foundation.util.nest.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.box */ \"./js/foundation.util.box.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n/**\n * Drilldown module.\n * @module foundation.drilldown\n * @requires foundation.util.keyboard\n * @requires foundation.util.nest\n * @requires foundation.util.box\n */\n\nvar Drilldown =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Drilldown, _Plugin);\n\n  function Drilldown() {\n    _classCallCheck(this, Drilldown);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Drilldown).apply(this, arguments));\n  }\n\n  _createClass(Drilldown, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of a drilldown menu.\n     * @class\n     * @name Drilldown\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Drilldown.defaults, this.$element.data(), options);\n      this.className = 'Drilldown'; // ie9 back compat\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].register('Drilldown', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'previous',\n        'ESCAPE': 'close',\n        'TAB': 'down',\n        'SHIFT_TAB': 'up'\n      });\n    }\n    /**\n     * Initializes the drilldown by creating jQuery collections of elements\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\"Nest\"].Feather(this.$element, 'drilldown');\n\n      if (this.options.autoApplyClass) {\n        this.$element.addClass('drilldown');\n      }\n\n      this.$element.attr({\n        'role': 'tree',\n        'aria-multiselectable': false\n      });\n      this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');\n      this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]').attr('role', 'group');\n      this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'treeitem').find('a'); // Set the main menu as current by default (unless a submenu is selected)\n      // Used to set the wrapper height when the drilldown is closed/reopened from any (sub)menu\n\n      this.$currentMenu = this.$element;\n      this.$element.attr('data-mutate', this.$element.attr('data-drilldown') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'drilldown'));\n\n      this._prepareMenu();\n\n      this._registerEvents();\n\n      this._keyboardEvents();\n    }\n    /**\n     * prepares drilldown menu by setting attributes to links and elements\n     * sets a min height to prevent content jumping\n     * wraps the element if not already wrapped\n     * @private\n     * @function\n     */\n\n  }, {\n    key: \"_prepareMenu\",\n    value: function _prepareMenu() {\n      var _this = this; // if(!this.options.holdOpen){\n      //   this._menuLinkEvents();\n      // }\n\n\n      this.$submenuAnchors.each(function () {\n        var $link = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\n        var $sub = $link.parent();\n\n        if (_this.options.parentLink) {\n          $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li data-is-parent-link class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"none\"></li>');\n        }\n\n        $link.data('savedHref', $link.attr('href')).removeAttr('href').attr('tabindex', 0);\n        $link.children('[data-submenu]').attr({\n          'aria-hidden': true,\n          'tabindex': 0,\n          'role': 'group'\n        });\n\n        _this._events($link);\n      });\n      this.$submenus.each(function () {\n        var $menu = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            $back = $menu.find('.js-drilldown-back');\n\n        if (!$back.length) {\n          switch (_this.options.backButtonPosition) {\n            case \"bottom\":\n              $menu.append(_this.options.backButton);\n              break;\n\n            case \"top\":\n              $menu.prepend(_this.options.backButton);\n              break;\n\n            default:\n              console.error(\"Unsupported backButtonPosition value '\" + _this.options.backButtonPosition + \"'\");\n          }\n        }\n\n        _this._back($menu);\n      });\n      this.$submenus.addClass('invisible');\n\n      if (!this.options.autoHeight) {\n        this.$submenus.addClass('drilldown-submenu-cover-previous');\n      } // create a wrapper on element if it doesn't exist.\n\n\n      if (!this.$element.parent().hasClass('is-drilldown')) {\n        this.$wrapper = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.wrapper).addClass('is-drilldown');\n        if (this.options.animateHeight) this.$wrapper.addClass('animate-height');\n        this.$element.wrap(this.$wrapper);\n      } // set wrapper\n\n\n      this.$wrapper = this.$element.parent();\n      this.$wrapper.css(this._getMaxDims());\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize() {\n      this.$wrapper.css({\n        'max-width': 'none',\n        'min-height': 'none'\n      }); // _getMaxDims has side effects (boo) but calling it should update all other necessary heights & widths\n\n      this.$wrapper.css(this._getMaxDims());\n    }\n    /**\n     * Adds event handlers to elements in the menu.\n     * @function\n     * @private\n     * @param {jQuery} $elem - the current menu item to add handlers to.\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events($elem) {\n      var _this = this;\n\n      $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {\n          e.preventDefault();\n        } // if(e.target !== e.currentTarget.firstElementChild){\n        //   return false;\n        // }\n\n\n        _this._show($elem.parent('li'));\n\n        if (_this.options.closeOnClick) {\n          var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body');\n          $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {\n            if (e.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(_this.$element[0], e.target)) {\n              return;\n            }\n\n            e.preventDefault();\n\n            _this._hideAll();\n\n            $body.off('.zf.drilldown');\n          });\n        }\n      });\n    }\n    /**\n     * Adds event handlers to the menu element.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      if (this.options.scrollTop) {\n        this._bindHandler = this._scrollTop.bind(this);\n        this.$element.on('open.zf.drilldown hide.zf.drilldown close.zf.drilldown closed.zf.drilldown', this._bindHandler);\n      }\n\n      this.$element.on('mutateme.zf.trigger', this._resize.bind(this));\n    }\n    /**\n     * Scroll to Top of Element or data-scroll-top-element\n     * @function\n     * @fires Drilldown#scrollme\n     */\n\n  }, {\n    key: \"_scrollTop\",\n    value: function _scrollTop() {\n      var _this = this;\n\n      var $scrollTopElement = _this.options.scrollTopElement != '' ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this.options.scrollTopElement) : _this.$element,\n          scrollPos = parseInt($scrollTopElement.offset().top + _this.options.scrollTopOffset, 10);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').stop(true).animate({\n        scrollTop: scrollPos\n      }, _this.options.animationDuration, _this.options.animationEasing, function () {\n        /**\n          * Fires after the menu has scrolled\n          * @event Drilldown#scrollme\n          */\n        if (this === jquery__WEBPACK_IMPORTED_MODULE_0___default()('html')[0]) _this.$element.trigger('scrollme.zf.drilldown');\n      });\n    }\n    /**\n     * Adds keydown event listener to `li`'s in the menu.\n     * @private\n     */\n\n  }, {\n    key: \"_keyboardEvents\",\n    value: function _keyboardEvents() {\n      var _this = this;\n\n      this.$menuItems.add(this.$element.find('.js-drilldown-back > a, .is-submenu-parent-item > a')).on('keydown.zf.drilldown', function (e) {\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            $elements = $element.parent('li').parent('ul').children('li').children('a'),\n            $prevElement,\n            $nextElement;\n        $elements.each(function (i) {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\n            $prevElement = $elements.eq(Math.max(0, i - 1));\n            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\n            return;\n          }\n        });\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].handleKey(e, 'Drilldown', {\n          next: function next() {\n            if ($element.is(_this.$submenuAnchors)) {\n              _this._show($element.parent('li'));\n\n              $element.parent('li').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])($element), function () {\n                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();\n              });\n              return true;\n            }\n          },\n          previous: function previous() {\n            _this._hide($element.parent('li').parent('ul'));\n\n            $element.parent('li').parent('ul').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])($element), function () {\n              setTimeout(function () {\n                $element.parent('li').parent('ul').parent('li').children('a').first().focus();\n              }, 1);\n            });\n            return true;\n          },\n          up: function up() {\n            $prevElement.focus(); // Don't tap focus on first element in root ul\n\n            return !$element.is(_this.$element.find('> li:first-child > a'));\n          },\n          down: function down() {\n            $nextElement.focus(); // Don't tap focus on last element in root ul\n\n            return !$element.is(_this.$element.find('> li:last-child > a'));\n          },\n          close: function close() {\n            // Don't close on element in root ul\n            if (!$element.is(_this.$element.find('> li > a'))) {\n              _this._hide($element.parent().parent());\n\n              $element.parent().parent().siblings('a').focus();\n            }\n          },\n          open: function open() {\n            if (_this.options.parentLink && $element.attr('href')) {\n              // Link with href\n              return false;\n            } else if (!$element.is(_this.$menuItems)) {\n              // not menu item means back button\n              _this._hide($element.parent('li').parent('ul'));\n\n              $element.parent('li').parent('ul').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])($element), function () {\n                setTimeout(function () {\n                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();\n                }, 1);\n              });\n              return true;\n            } else if ($element.is(_this.$submenuAnchors)) {\n              // Sub menu item\n              _this._show($element.parent('li'));\n\n              $element.parent('li').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])($element), function () {\n                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();\n              });\n              return true;\n            }\n          },\n          handled: function handled(preventDefault) {\n            if (preventDefault) {\n              e.preventDefault();\n            }\n          }\n        });\n      }); // end keyboardAccess\n    }\n    /**\n     * Closes all open elements, and returns to root menu.\n     * @function\n     * @fires Drilldown#close\n     * @fires Drilldown#closed\n     */\n\n  }, {\n    key: \"_hideAll\",\n    value: function _hideAll() {\n      var _this2 = this;\n\n      var $elem = this.$element.find('.is-drilldown-submenu.is-active');\n      $elem.addClass('is-closing');\n\n      if (this.options.autoHeight) {\n        var calcHeight = $elem.parent().closest('ul').data('calcHeight');\n        this.$wrapper.css({\n          height: calcHeight\n        });\n      }\n      /**\n       * Fires when the menu is closing.\n       * @event Drilldown#close\n       */\n\n\n      this.$element.trigger('close.zf.drilldown');\n      $elem.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])($elem), function () {\n        $elem.removeClass('is-active is-closing');\n        /**\n         * Fires when the menu is fully closed.\n         * @event Drilldown#closed\n         */\n\n        _this2.$element.trigger('closed.zf.drilldown');\n      });\n    }\n    /**\n     * Adds event listener for each `back` button, and closes open menus.\n     * @function\n     * @fires Drilldown#back\n     * @param {jQuery} $elem - the current sub-menu to add `back` event.\n     */\n\n  }, {\n    key: \"_back\",\n    value: function _back($elem) {\n      var _this = this;\n\n      $elem.off('click.zf.drilldown');\n      $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {\n        // console.log('mouseup on back');\n        _this._hide($elem); // If there is a parent submenu, call show\n\n\n        var parentSubMenu = $elem.parent('li').parent('ul').parent('li');\n\n        if (parentSubMenu.length) {\n          _this._show(parentSubMenu);\n        }\n      });\n    }\n    /**\n     * Adds event listener to menu items w/o submenus to close open menus on click.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_menuLinkEvents\",\n    value: function _menuLinkEvents() {\n      var _this = this;\n\n      this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\n        setTimeout(function () {\n          _this._hideAll();\n        }, 0);\n      });\n    }\n    /**\n     * Sets the CSS classes for submenu to show it.\n     * @function\n     * @private\n     * @param {jQuery} $elem - the target submenu (`ul` tag)\n     * @param {boolean} trigger - trigger drilldown event\n     */\n\n  }, {\n    key: \"_setShowSubMenuClasses\",\n    value: function _setShowSubMenuClasses($elem, trigger) {\n      $elem.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);\n      $elem.parent('li').attr('aria-expanded', true);\n\n      if (trigger === true) {\n        this.$element.trigger('open.zf.drilldown', [$elem]);\n      }\n    }\n    /**\n     * Sets the CSS classes for submenu to hide it.\n     * @function\n     * @private\n     * @param {jQuery} $elem - the target submenu (`ul` tag)\n     * @param {boolean} trigger - trigger drilldown event\n     */\n\n  }, {\n    key: \"_setHideSubMenuClasses\",\n    value: function _setHideSubMenuClasses($elem, trigger) {\n      $elem.removeClass('is-active').addClass('invisible').attr('aria-hidden', true);\n      $elem.parent('li').attr('aria-expanded', false);\n\n      if (trigger === true) {\n        $elem.trigger('hide.zf.drilldown', [$elem]);\n      }\n    }\n    /**\n     * Opens a specific drilldown (sub)menu no matter which (sub)menu in it is currently visible.\n     * Compared to _show() this lets you jump into any submenu without clicking through every submenu on the way to it.\n     * @function\n     * @fires Drilldown#open\n     * @param {jQuery} $elem - the target (sub)menu (`ul` tag)\n     * @param {boolean} autoFocus - if true the first link in the target (sub)menu gets auto focused\n     */\n\n  }, {\n    key: \"_showMenu\",\n    value: function _showMenu($elem, autoFocus) {\n      var _this = this; // Reset drilldown\n\n\n      var $expandedSubmenus = this.$element.find('li[aria-expanded=\"true\"] > ul[data-submenu]');\n      $expandedSubmenus.each(function (index) {\n        _this._setHideSubMenuClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\n      }); // Save the menu as the currently displayed one.\n\n      this.$currentMenu = $elem; // If target menu is root, focus first link & exit\n\n      if ($elem.is('[data-drilldown]')) {\n        if (autoFocus === true) $elem.find('li[role=\"treeitem\"] > a').first().focus();\n        if (this.options.autoHeight) this.$wrapper.css('height', $elem.data('calcHeight'));\n        return;\n      } // Find all submenus on way to root incl. the element itself\n\n\n      var $submenus = $elem.children().first().parentsUntil('[data-drilldown]', '[data-submenu]'); // Open target menu and all submenus on its way to root\n\n      $submenus.each(function (index) {\n        // Update height of first child (target menu) if autoHeight option true\n        if (index === 0 && _this.options.autoHeight) {\n          _this.$wrapper.css('height', jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('calcHeight'));\n        }\n\n        var isLastChild = index == $submenus.length - 1; // Add transitionsend listener to last child (root due to reverse order) to open target menu's first link\n        // Last child makes sure the event gets always triggered even if going through several menus\n\n        if (isLastChild === true) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)), function () {\n            if (autoFocus === true) {\n              $elem.find('li[role=\"treeitem\"] > a').first().focus();\n            }\n          });\n        }\n\n        _this._setShowSubMenuClasses(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), isLastChild);\n      });\n    }\n    /**\n     * Opens a submenu.\n     * @function\n     * @fires Drilldown#open\n     * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.\n     */\n\n  }, {\n    key: \"_show\",\n    value: function _show($elem) {\n      var $submenu = $elem.children('[data-submenu]');\n      $elem.attr('aria-expanded', true);\n      this.$currentMenu = $submenu;\n      $submenu.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);\n\n      if (this.options.autoHeight) {\n        this.$wrapper.css({\n          height: $submenu.data('calcHeight')\n        });\n      }\n      /**\n       * Fires when the submenu has opened.\n       * @event Drilldown#open\n       */\n\n\n      this.$element.trigger('open.zf.drilldown', [$elem]);\n    }\n    /**\n     * Hides a submenu\n     * @function\n     * @fires Drilldown#hide\n     * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.\n     */\n\n  }, {\n    key: \"_hide\",\n    value: function _hide($elem) {\n      if (this.options.autoHeight) this.$wrapper.css({\n        height: $elem.parent().closest('ul').data('calcHeight')\n      });\n\n      var _this = this;\n\n      $elem.parent('li').attr('aria-expanded', false);\n      $elem.attr('aria-hidden', true);\n      $elem.addClass('is-closing').one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"transitionend\"])($elem), function () {\n        $elem.removeClass('is-active is-closing');\n        $elem.blur().addClass('invisible');\n      });\n      /**\n       * Fires when the submenu has closed.\n       * @event Drilldown#hide\n       */\n\n      $elem.trigger('hide.zf.drilldown', [$elem]);\n    }\n    /**\n     * Iterates through the nested menus to calculate the min-height, and max-width for the menu.\n     * Prevents content jumping.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_getMaxDims\",\n    value: function _getMaxDims() {\n      var maxHeight = 0,\n          result = {},\n          _this = this; // Recalculate menu heights and total max height\n\n\n      this.$submenus.add(this.$element).each(function () {\n        var numOfElems = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).children('li').length;\n        var height = _foundation_util_box__WEBPACK_IMPORTED_MODULE_4__[\"Box\"].GetDimensions(this).height;\n        maxHeight = height > maxHeight ? height : maxHeight;\n\n        if (_this.options.autoHeight) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('calcHeight', height);\n        }\n      });\n      if (this.options.autoHeight) result['height'] = this.$currentMenu.data('calcHeight');else result['min-height'] = \"\".concat(maxHeight, \"px\");\n      result['max-width'] = \"\".concat(this.$element[0].getBoundingClientRect().width, \"px\");\n      return result;\n    }\n    /**\n     * Destroys the Drilldown Menu\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (this.options.scrollTop) this.$element.off('.zf.drilldown', this._bindHandler);\n\n      this._hideAll();\n\n      this.$element.off('mutateme.zf.trigger');\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_2__[\"Nest\"].Burn(this.$element, 'drilldown');\n      this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');\n      this.$submenuAnchors.each(function () {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).off('.zf.drilldown');\n      });\n      this.$element.find('[data-is-parent-link]').detach();\n      this.$submenus.removeClass('drilldown-submenu-cover-previous invisible');\n      this.$element.find('a').each(function () {\n        var $link = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\n        $link.removeAttr('tabindex');\n\n        if ($link.data('savedHref')) {\n          $link.attr('href', $link.data('savedHref')).removeData('savedHref');\n        } else {\n          return;\n        }\n      });\n    }\n  }]);\n\n  return Drilldown;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_5__[\"Plugin\"]);\n\nDrilldown.defaults = {\n  /**\n   * Drilldowns depend on styles in order to function properly; in the default build of Foundation these are\n   * on the `drilldown` class. This option auto-applies this class to the drilldown upon initialization.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  autoApplyClass: true,\n\n  /**\n   * Markup used for JS generated back button. Prepended  or appended (see backButtonPosition) to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\\`) if copy and pasting.\n   * @option\n   * @type {string}\n   * @default '<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>'\n   */\n  backButton: '<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>',\n\n  /**\n   * Position the back button either at the top or bottom of drilldown submenus. Can be `'left'` or `'bottom'`.\n   * @option\n   * @type {string}\n   * @default top\n   */\n  backButtonPosition: 'top',\n\n  /**\n   * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\\`) if copy and pasting.\n   * @option\n   * @type {string}\n   * @default '<div></div>'\n   */\n  wrapper: '<div></div>',\n\n  /**\n   * Adds the parent link to the submenu.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  parentLink: false,\n\n  /**\n   * Allow the menu to return to root list on body click.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  closeOnClick: false,\n\n  /**\n   * Allow the menu to auto adjust height.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  autoHeight: false,\n\n  /**\n   * Animate the auto adjust height.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  animateHeight: false,\n\n  /**\n   * Scroll to the top of the menu after opening a submenu or navigating back using the menu back button\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  scrollTop: false,\n\n  /**\n   * String jquery selector (for example 'body') of element to take offset().top from, if empty string the drilldown menu offset().top is taken\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  scrollTopElement: '',\n\n  /**\n   * ScrollTop offset\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  scrollTopOffset: 0,\n\n  /**\n   * Scroll animation duration\n   * @option\n   * @type {number}\n   * @default 500\n   */\n  animationDuration: 500,\n\n  /**\n   * Scroll animation easing. Can be `'swing'` or `'linear'`.\n   * @option\n   * @type {string}\n   * @see {@link https://api.jquery.com/animate|JQuery animate}\n   * @default 'swing'\n   */\n  animationEasing: 'swing' // holdOpen: false\n\n};\n\n\n//# sourceURL=webpack:///./js/foundation.drilldown.js?");/***/},/***/"./js/foundation.dropdown.js":/*!***********************************!*\
	  !*** ./js/foundation.dropdown.js ***!
	  \***********************************/ /*! exports provided: Dropdown */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dropdown\", function() { return Dropdown; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_positionable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.positionable */ \"./js/foundation.positionable.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.touch */ \"./js/foundation.util.touch.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n/**\n * Dropdown module.\n * @module foundation.dropdown\n * @requires foundation.util.keyboard\n * @requires foundation.util.box\n * @requires foundation.util.touch\n * @requires foundation.util.triggers\n */\n\nvar Dropdown =\n/*#__PURE__*/\nfunction (_Positionable) {\n  _inherits(Dropdown, _Positionable);\n\n  function Dropdown() {\n    _classCallCheck(this, Dropdown);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).apply(this, arguments));\n  }\n\n  _createClass(Dropdown, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of a dropdown.\n     * @class\n     * @name Dropdown\n     * @param {jQuery} element - jQuery object to make into a dropdown.\n     *        Object should be of the dropdown panel, rather than its anchor.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Dropdown.defaults, this.$element.data(), options);\n      this.className = 'Dropdown'; // ie9 back compat\n      // Touch and Triggers init are idempotent, just need to make sure they are initialized\n\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_5__[\"Touch\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].register('Dropdown', {\n        'ENTER': 'toggle',\n        'SPACE': 'toggle',\n        'ESCAPE': 'close'\n      });\n    }\n    /**\n     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var $id = this.$element.attr('id');\n      this.$anchors = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-toggle=\\\"\".concat($id, \"\\\"]\")).length ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-toggle=\\\"\".concat($id, \"\\\"]\")) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open=\\\"\".concat($id, \"\\\"]\"));\n      this.$anchors.attr({\n        'aria-controls': $id,\n        'data-is-focus': false,\n        'data-yeti-box': $id,\n        'aria-haspopup': true,\n        'aria-expanded': false\n      });\n\n      this._setCurrentAnchor(this.$anchors.first());\n\n      if (this.options.parentClass) {\n        this.$parent = this.$element.parents('.' + this.options.parentClass);\n      } else {\n        this.$parent = null;\n      } // Set [aria-labelledby] on the Dropdown if it is not set\n\n\n      if (typeof this.$element.attr('aria-labelledby') === 'undefined') {\n        // Get the anchor ID or create one\n        if (typeof this.$currentAnchor.attr('id') === 'undefined') {\n          this.$currentAnchor.attr('id', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'dd-anchor'));\n        }\n\n        this.$element.attr('aria-labelledby', this.$currentAnchor.attr('id'));\n      }\n\n      this.$element.attr({\n        'aria-hidden': 'true',\n        'data-yeti-box': $id,\n        'data-resize': $id\n      });\n\n      _get(_getPrototypeOf(Dropdown.prototype), \"_init\", this).call(this);\n\n      this._events();\n    }\n  }, {\n    key: \"_getDefaultPosition\",\n    value: function _getDefaultPosition() {\n      // handle legacy classnames\n      var position = this.$element[0].className.match(/(top|left|right|bottom)/g);\n\n      if (position) {\n        return position[0];\n      } else {\n        return 'bottom';\n      }\n    }\n  }, {\n    key: \"_getDefaultAlignment\",\n    value: function _getDefaultAlignment() {\n      // handle legacy float approach\n      var horizontalPosition = /float-(\\S+)/.exec(this.$currentAnchor.attr('class'));\n\n      if (horizontalPosition) {\n        return horizontalPosition[1];\n      }\n\n      return _get(_getPrototypeOf(Dropdown.prototype), \"_getDefaultAlignment\", this).call(this);\n    }\n    /**\n     * Sets the position and orientation of the dropdown pane, checks for collisions if allow-overlap is not true.\n     * Recursively calls itself if a collision is detected, with a new position class.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition() {\n      this.$element.removeClass(\"has-position-\".concat(this.position, \" has-alignment-\").concat(this.alignment));\n\n      _get(_getPrototypeOf(Dropdown.prototype), \"_setPosition\", this).call(this, this.$currentAnchor, this.$element, this.$parent);\n\n      this.$element.addClass(\"has-position-\".concat(this.position, \" has-alignment-\").concat(this.alignment));\n    }\n    /**\n     * Make it a current anchor.\n     * Current anchor as the reference for the position of Dropdown panes.\n     * @param {HTML} el - DOM element of the anchor.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_setCurrentAnchor\",\n    value: function _setCurrentAnchor(el) {\n      this.$currentAnchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);\n    }\n    /**\n     * Adds event listeners to the element utilizing the triggers utility library.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this,\n          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined';\n\n      this.$element.on({\n        'open.zf.trigger': this.open.bind(this),\n        'close.zf.trigger': this.close.bind(this),\n        'toggle.zf.trigger': this.toggle.bind(this),\n        'resizeme.zf.trigger': this._setPosition.bind(this)\n      });\n      this.$anchors.off('click.zf.trigger').on('click.zf.trigger', function (e) {\n        _this._setCurrentAnchor(this);\n\n        if ( // if forceFollow false, always prevent default action\n        _this.options.forceFollow === false || // if forceFollow true and hover option true, only prevent default action on 1st click\n        // on 2nd click (dropown opened) the default action (e.g. follow a href) gets executed\n        hasTouch && _this.options.hover && _this.$element.hasClass('is-open') === false) {\n          e.preventDefault();\n        }\n      });\n\n      if (this.options.hover) {\n        this.$anchors.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\n          _this._setCurrentAnchor(this);\n\n          var bodyData = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').data();\n\n          if (typeof bodyData.whatinput === 'undefined' || bodyData.whatinput === 'mouse') {\n            clearTimeout(_this.timeout);\n            _this.timeout = setTimeout(function () {\n              _this.open();\n\n              _this.$anchors.data('hover', true);\n            }, _this.options.hoverDelay);\n          }\n        }).on('mouseleave.zf.dropdown', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"ignoreMousedisappear\"])(function () {\n          clearTimeout(_this.timeout);\n          _this.timeout = setTimeout(function () {\n            _this.close();\n\n            _this.$anchors.data('hover', false);\n          }, _this.options.hoverDelay);\n        }));\n\n        if (this.options.hoverPane) {\n          this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\n            clearTimeout(_this.timeout);\n          }).on('mouseleave.zf.dropdown', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"ignoreMousedisappear\"])(function () {\n            clearTimeout(_this.timeout);\n            _this.timeout = setTimeout(function () {\n              _this.close();\n\n              _this.$anchors.data('hover', false);\n            }, _this.options.hoverDelay);\n          }));\n        }\n      }\n\n      this.$anchors.add(this.$element).on('keydown.zf.dropdown', function (e) {\n        var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            visibleFocusableElements = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].findFocusable(_this.$element);\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].handleKey(e, 'Dropdown', {\n          open: function open() {\n            if ($target.is(_this.$anchors) && !$target.is('input, textarea')) {\n              _this.open();\n\n              _this.$element.attr('tabindex', -1).focus();\n\n              e.preventDefault();\n            }\n          },\n          close: function close() {\n            _this.close();\n\n            _this.$anchors.focus();\n          }\n        });\n      });\n    }\n    /**\n     * Adds an event handler to the body to close any dropdowns on a click.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_addBodyHandler\",\n    value: function _addBodyHandler() {\n      var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).not(this.$element),\n          _this = this;\n\n      $body.off('click.zf.dropdown tap.zf.dropdown').on('click.zf.dropdown tap.zf.dropdown', function (e) {\n        if (_this.$anchors.is(e.target) || _this.$anchors.find(e.target).length) {\n          return;\n        }\n\n        if (_this.$element.is(e.target) || _this.$element.find(e.target).length) {\n          return;\n        }\n\n        _this.close();\n\n        $body.off('click.zf.dropdown tap.zf.dropdown');\n      });\n    }\n    /**\n     * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.\n     * @function\n     * @fires Dropdown#closeme\n     * @fires Dropdown#show\n     */\n\n  }, {\n    key: \"open\",\n    value: function open() {\n      // var _this = this;\n\n      /**\n       * Fires to close other open dropdowns, typically when dropdown is opening\n       * @event Dropdown#closeme\n       */\n      this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));\n      this.$anchors.addClass('hover').attr({\n        'aria-expanded': true\n      }); // this.$element/*.show()*/;\n\n      this.$element.addClass('is-opening');\n\n      this._setPosition();\n\n      this.$element.removeClass('is-opening').addClass('is-open').attr({\n        'aria-hidden': false\n      });\n\n      if (this.options.autoFocus) {\n        var $focusable = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].findFocusable(this.$element);\n\n        if ($focusable.length) {\n          $focusable.eq(0).focus();\n        }\n      }\n\n      if (this.options.closeOnClick) {\n        this._addBodyHandler();\n      }\n\n      if (this.options.trapFocus) {\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].trapFocus(this.$element);\n      }\n      /**\n       * Fires once the dropdown is visible.\n       * @event Dropdown#show\n       */\n\n\n      this.$element.trigger('show.zf.dropdown', [this.$element]);\n    }\n    /**\n     * Closes the open dropdown pane.\n     * @function\n     * @fires Dropdown#hide\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (!this.$element.hasClass('is-open')) {\n        return false;\n      }\n\n      this.$element.removeClass('is-open').attr({\n        'aria-hidden': true\n      });\n      this.$anchors.removeClass('hover').attr('aria-expanded', false);\n      /**\n       * Fires once the dropdown is no longer visible.\n       * @event Dropdown#hide\n       */\n\n      this.$element.trigger('hide.zf.dropdown', [this.$element]);\n\n      if (this.options.trapFocus) {\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].releaseFocus(this.$element);\n      }\n    }\n    /**\n     * Toggles the dropdown pane's visibility.\n     * @function\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (this.$element.hasClass('is-open')) {\n        if (this.$anchors.data('hover')) return;\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    /**\n     * Destroys the dropdown.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.off('.zf.trigger').hide();\n      this.$anchors.off('.zf.dropdown');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).off('click.zf.dropdown tap.zf.dropdown');\n    }\n  }]);\n\n  return Dropdown;\n}(_foundation_positionable__WEBPACK_IMPORTED_MODULE_3__[\"Positionable\"]);\n\nDropdown.defaults = {\n  /**\n   * Class that designates bounding container of Dropdown (default: window)\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  parentClass: null,\n\n  /**\n   * Amount of time to delay opening a submenu on hover event.\n   * @option\n   * @type {number}\n   * @default 250\n   */\n  hoverDelay: 250,\n\n  /**\n   * Allow submenus to open on hover events\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  hover: false,\n\n  /**\n   * Don't close dropdown when hovering over dropdown pane\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  hoverPane: false,\n\n  /**\n   * Number of pixels between the dropdown pane and the triggering element on open.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  vOffset: 0,\n\n  /**\n   * Number of pixels between the dropdown pane and the triggering element on open.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  hOffset: 0,\n\n  /**\n   * Position of dropdown. Can be left, right, bottom, top, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  position: 'auto',\n\n  /**\n   * Alignment of dropdown relative to anchor. Can be left, right, bottom, top, center, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  alignment: 'auto',\n\n  /**\n   * Allow overlap of container/window. If false, dropdown will first try to position as defined by data-position and data-alignment, but reposition if it would cause an overflow.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  allowOverlap: false,\n\n  /**\n   * Allow overlap of only the bottom of the container. This is the most common\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\n   * screen but not otherwise influence or break out of the container.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  allowBottomOverlap: true,\n\n  /**\n   * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  trapFocus: false,\n\n  /**\n   * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  autoFocus: false,\n\n  /**\n   * Allows a click on the body to close the dropdown.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  closeOnClick: false,\n\n  /**\n   * If true the default action of the toggle (e.g. follow a link with href) gets executed on click. If hover option is also true the default action gets prevented on first click for mobile / touch devices and executed on second click.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  forceFollow: true\n};\n\n\n//# sourceURL=webpack:///./js/foundation.dropdown.js?");/***/},/***/"./js/foundation.dropdownMenu.js":/*!***************************************!*\
	  !*** ./js/foundation.dropdownMenu.js ***!
	  \***************************************/ /*! exports provided: DropdownMenu */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DropdownMenu\", function() { return DropdownMenu; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_nest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.nest */ \"./js/foundation.util.nest.js\");\n/* harmony import */ var _foundation_util_box__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.box */ \"./js/foundation.util.box.js\");\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.util.touch */ \"./js/foundation.util.touch.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n/**\n * DropdownMenu module.\n * @module foundation.dropdownMenu\n * @requires foundation.util.keyboard\n * @requires foundation.util.box\n * @requires foundation.util.nest\n * @requires foundation.util.touch\n */\n\nvar DropdownMenu =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(DropdownMenu, _Plugin);\n\n  function DropdownMenu() {\n    _classCallCheck(this, DropdownMenu);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DropdownMenu).apply(this, arguments));\n  }\n\n  _createClass(DropdownMenu, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of DropdownMenu.\n     * @class\n     * @name DropdownMenu\n     * @fires DropdownMenu#init\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, DropdownMenu.defaults, this.$element.data(), options);\n      this.className = 'DropdownMenu'; // ie9 back compat\n\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_6__[\"Touch\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a); // Touch init is idempotent, we just need to make sure it's initialied.\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].register('DropdownMenu', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'previous',\n        'ESCAPE': 'close'\n      });\n    }\n    /**\n     * Initializes the plugin, and calls _prepareMenu\n     * @private\n     * @function\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_4__[\"Nest\"].Feather(this.$element, 'dropdown');\n      var subs = this.$element.find('li.is-dropdown-submenu-parent');\n      this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\n      this.$menuItems = this.$element.find('li[role=\"none\"]');\n      this.$tabs = this.$element.children('li[role=\"none\"]');\n      this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\n\n      if (this.options.alignment === 'auto') {\n        if (this.$element.hasClass(this.options.rightClass) || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"rtl\"])() || this.$element.parents('.top-bar-right').is('*')) {\n          this.options.alignment = 'right';\n          subs.addClass('opens-left');\n        } else {\n          this.options.alignment = 'left';\n          subs.addClass('opens-right');\n        }\n      } else {\n        if (this.options.alignment === 'right') {\n          subs.addClass('opens-left');\n        } else {\n          subs.addClass('opens-right');\n        }\n      }\n\n      this.changed = false;\n\n      this._events();\n    }\n  }, {\n    key: \"_isVertical\",\n    value: function _isVertical() {\n      return this.$tabs.css('display') === 'block' || this.$element.css('flex-direction') === 'column';\n    }\n  }, {\n    key: \"_isRtl\",\n    value: function _isRtl() {\n      return this.$element.hasClass('align-right') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"rtl\"])() && !this.$element.hasClass('align-left');\n    }\n    /**\n     * Adds event listeners to elements within the menu\n     * @private\n     * @function\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this,\n          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',\n          parClass = 'is-dropdown-submenu-parent'; // used for onClick and in the keyboard handlers\n\n\n      var handleClickFn = function handleClickFn(e) {\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parentsUntil('ul', \".\".concat(parClass)),\n            hasSub = $elem.hasClass(parClass),\n            hasClicked = $elem.attr('data-is-click') === 'true',\n            $sub = $elem.children('.is-dropdown-submenu');\n\n        if (hasSub) {\n          if (hasClicked) {\n            if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {\n              return;\n            }\n\n            e.stopImmediatePropagation();\n            e.preventDefault();\n\n            _this._hide($elem);\n          } else {\n            e.stopImmediatePropagation();\n            e.preventDefault();\n\n            _this._show($sub);\n\n            $elem.add($elem.parentsUntil(_this.$element, \".\".concat(parClass))).attr('data-is-click', true);\n          }\n        }\n      };\n\n      if (this.options.clickOpen || hasTouch) {\n        this.$menuItems.on('click.zf.dropdownMenu touchstart.zf.dropdownMenu', handleClickFn);\n      } // Handle Leaf element Clicks\n\n\n      if (_this.options.closeOnClickInside) {\n        this.$menuItems.on('click.zf.dropdownMenu', function (e) {\n          var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n              hasSub = $elem.hasClass(parClass);\n\n          if (!hasSub) {\n            _this._hide();\n          }\n        });\n      }\n\n      if (!this.options.disableHover) {\n        this.$menuItems.on('mouseenter.zf.dropdownMenu', function (e) {\n          var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n              hasSub = $elem.hasClass(parClass);\n\n          if (hasSub) {\n            clearTimeout($elem.data('_delay'));\n            $elem.data('_delay', setTimeout(function () {\n              _this._show($elem.children('.is-dropdown-submenu'));\n            }, _this.options.hoverDelay));\n          }\n        }).on('mouseleave.zf.dropdownMenu', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"ignoreMousedisappear\"])(function (e) {\n          var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n              hasSub = $elem.hasClass(parClass);\n\n          if (hasSub && _this.options.autoclose) {\n            if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {\n              return false;\n            }\n\n            clearTimeout($elem.data('_delay'));\n            $elem.data('_delay', setTimeout(function () {\n              _this._hide($elem);\n            }, _this.options.closingTime));\n          }\n        }));\n      }\n\n      this.$menuItems.on('keydown.zf.dropdownMenu', function (e) {\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).parentsUntil('ul', '[role=\"none\"]'),\n            isTab = _this.$tabs.index($element) > -1,\n            $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\n            $prevElement,\n            $nextElement;\n        $elements.each(function (i) {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\n            $prevElement = $elements.eq(i - 1);\n            $nextElement = $elements.eq(i + 1);\n            return;\n          }\n        });\n\n        var nextSibling = function nextSibling() {\n          $nextElement.children('a:first').focus();\n          e.preventDefault();\n        },\n            prevSibling = function prevSibling() {\n          $prevElement.children('a:first').focus();\n          e.preventDefault();\n        },\n            openSub = function openSub() {\n          var $sub = $element.children('ul.is-dropdown-submenu');\n\n          if ($sub.length) {\n            _this._show($sub);\n\n            $element.find('li > a:first').focus();\n            e.preventDefault();\n          } else {\n            return;\n          }\n        },\n            closeSub = function closeSub() {\n          //if ($element.is(':first-child')) {\n          var close = $element.parent('ul').parent('li');\n          close.children('a:first').focus();\n\n          _this._hide(close);\n\n          e.preventDefault(); //}\n        };\n\n        var functions = {\n          open: openSub,\n          close: function close() {\n            _this._hide(_this.$element);\n\n            _this.$menuItems.eq(0).children('a').focus(); // focus to first element\n\n\n            e.preventDefault();\n          }\n        };\n\n        if (isTab) {\n          if (_this._isVertical()) {\n            // vertical menu\n            if (_this._isRtl()) {\n              // right aligned\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\n                down: nextSibling,\n                up: prevSibling,\n                next: closeSub,\n                previous: openSub\n              });\n            } else {\n              // left aligned\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\n                down: nextSibling,\n                up: prevSibling,\n                next: openSub,\n                previous: closeSub\n              });\n            }\n          } else {\n            // horizontal menu\n            if (_this._isRtl()) {\n              // right aligned\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\n                next: prevSibling,\n                previous: nextSibling,\n                down: openSub,\n                up: closeSub\n              });\n            } else {\n              // left aligned\n              jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\n                next: nextSibling,\n                previous: prevSibling,\n                down: openSub,\n                up: closeSub\n              });\n            }\n          }\n        } else {\n          // not tabs -> one sub\n          if (_this._isRtl()) {\n            // right aligned\n            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\n              next: closeSub,\n              previous: openSub,\n              down: nextSibling,\n              up: prevSibling\n            });\n          } else {\n            // left aligned\n            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend(functions, {\n              next: openSub,\n              previous: closeSub,\n              down: nextSibling,\n              up: prevSibling\n            });\n          }\n        }\n\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].handleKey(e, 'DropdownMenu', functions);\n      });\n    }\n    /**\n     * Adds an event handler to the body to close any dropdowns on a click.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_addBodyHandler\",\n    value: function _addBodyHandler() {\n      var _this2 = this;\n\n      var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body);\n\n      this._removeBodyHandler();\n\n      $body.on('click.zf.dropdownMenu tap.zf.dropdownMenu', function (e) {\n        var isItself = !!jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).closest(_this2.$element).length;\n        if (isItself) return;\n\n        _this2._hide();\n\n        _this2._removeBodyHandler();\n      });\n    }\n    /**\n     * Remove the body event handler. See `_addBodyHandler`.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_removeBodyHandler\",\n    value: function _removeBodyHandler() {\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).off('click.zf.dropdownMenu tap.zf.dropdownMenu');\n    }\n    /**\n     * Opens a dropdown pane, and checks for collisions first.\n     * @param {jQuery} $sub - ul element that is a submenu to show\n     * @function\n     * @private\n     * @fires DropdownMenu#show\n     */\n\n  }, {\n    key: \"_show\",\n    value: function _show($sub) {\n      var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {\n        return jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).find($sub).length > 0;\n      }));\n      var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\n\n      this._hide($sibs, idx);\n\n      $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');\n      var clear = _foundation_util_box__WEBPACK_IMPORTED_MODULE_5__[\"Box\"].ImNotTouchingYou($sub, null, true);\n\n      if (!clear) {\n        var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\n            $parentLi = $sub.parent('.is-dropdown-submenu-parent');\n        $parentLi.removeClass(\"opens\".concat(oldClass)).addClass(\"opens-\".concat(this.options.alignment));\n        clear = _foundation_util_box__WEBPACK_IMPORTED_MODULE_5__[\"Box\"].ImNotTouchingYou($sub, null, true);\n\n        if (!clear) {\n          $parentLi.removeClass(\"opens-\".concat(this.options.alignment)).addClass('opens-inner');\n        }\n\n        this.changed = true;\n      }\n\n      $sub.css('visibility', '');\n\n      if (this.options.closeOnClick) {\n        this._addBodyHandler();\n      }\n      /**\n       * Fires when the new dropdown pane is visible.\n       * @event DropdownMenu#show\n       */\n\n\n      this.$element.trigger('show.zf.dropdownMenu', [$sub]);\n    }\n    /**\n     * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\n     * @function\n     * @param {jQuery} $elem - element with a submenu to hide\n     * @param {Number} idx - index of the $tabs collection to hide\n     * @fires DropdownMenu#hide\n     * @private\n     */\n\n  }, {\n    key: \"_hide\",\n    value: function _hide($elem, idx) {\n      var $toClose;\n\n      if ($elem && $elem.length) {\n        $toClose = $elem;\n      } else if (typeof idx !== 'undefined') {\n        $toClose = this.$tabs.not(function (i, el) {\n          return i === idx;\n        });\n      } else {\n        $toClose = this.$element;\n      }\n\n      var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\n\n      if (somethingToClose) {\n        var $activeItem = $toClose.find('li.is-active');\n        $activeItem.add($toClose).attr({\n          'data-is-click': false\n        }).removeClass('is-active');\n        $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');\n\n        if (this.changed || $toClose.find('opens-inner').length) {\n          var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\n          $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass(\"opens-inner opens-\".concat(this.options.alignment)).addClass(\"opens-\".concat(oldClass));\n          this.changed = false;\n        }\n\n        clearTimeout($activeItem.data('_delay'));\n\n        this._removeBodyHandler();\n        /**\n         * Fires when the open menus are closed.\n         * @event DropdownMenu#hide\n         */\n\n\n        this.$element.trigger('hide.zf.dropdownMenu', [$toClose]);\n      }\n    }\n    /**\n     * Destroys the plugin.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$menuItems.off('.zf.dropdownMenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).off('.zf.dropdownMenu');\n      _foundation_util_nest__WEBPACK_IMPORTED_MODULE_4__[\"Nest\"].Burn(this.$element, 'dropdown');\n    }\n  }]);\n\n  return DropdownMenu;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n/**\n * Default settings for plugin\n */\n\n\nDropdownMenu.defaults = {\n  /**\n   * Disallows hover events from opening submenus\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  disableHover: false,\n\n  /**\n   * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  autoclose: true,\n\n  /**\n   * Amount of time to delay opening a submenu on hover event.\n   * @option\n   * @type {number}\n   * @default 50\n   */\n  hoverDelay: 50,\n\n  /**\n   * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  clickOpen: false,\n\n  /**\n   * Amount of time to delay closing a submenu on a mouseleave event.\n   * @option\n   * @type {number}\n   * @default 500\n   */\n  closingTime: 500,\n\n  /**\n   * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'auto'`, `'left'` or `'right'`.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  alignment: 'auto',\n\n  /**\n   * Allow clicks on the body to close any open submenus.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClick: true,\n\n  /**\n   * Allow clicks on leaf anchor links to close any open submenus.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClickInside: true,\n\n  /**\n   * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\n   * @option\n   * @type {string}\n   * @default 'vertical'\n   */\n  verticalClass: 'vertical',\n\n  /**\n   * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\n   * @option\n   * @type {string}\n   * @default 'align-right'\n   */\n  rightClass: 'align-right',\n\n  /**\n   * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  forceFollow: true\n};\n\n\n//# sourceURL=webpack:///./js/foundation.dropdownMenu.js?");/***/},/***/"./js/foundation.equalizer.js":/*!************************************!*\
	  !*** ./js/foundation.equalizer.js ***!
	  \************************************/ /*! exports provided: Equalizer */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Equalizer\", function() { return Equalizer; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.imageLoader */ \"./js/foundation.util.imageLoader.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Equalizer module.\n * @module foundation.equalizer\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.imageLoader if equalizer contains images\n */\n\nvar Equalizer =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Equalizer, _Plugin);\n\n  function Equalizer() {\n    _classCallCheck(this, Equalizer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Equalizer).apply(this, arguments));\n  }\n\n  _createClass(Equalizer, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Equalizer.\n     * @class\n     * @name Equalizer\n     * @fires Equalizer#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Equalizer.defaults, this.$element.data(), options);\n      this.className = 'Equalizer'; // ie9 back compat\n\n      this._init();\n    }\n    /**\n     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var eqId = this.$element.attr('data-equalizer') || '';\n      var $watched = this.$element.find(\"[data-equalizer-watch=\\\"\".concat(eqId, \"\\\"]\"));\n\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init();\n\n      this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');\n      this.$element.attr('data-resize', eqId || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'eq'));\n      this.$element.attr('data-mutate', eqId || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'eq'));\n      this.hasNested = this.$element.find('[data-equalizer]').length > 0;\n      this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;\n      this.isOn = false;\n      this._bindHandler = {\n        onResizeMeBound: this._onResizeMe.bind(this),\n        onPostEqualizedBound: this._onPostEqualized.bind(this)\n      };\n      var imgs = this.$element.find('img');\n      var tooSmall;\n\n      if (this.options.equalizeOn) {\n        tooSmall = this._checkMQ();\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));\n      } else {\n        this._events();\n      }\n\n      if (typeof tooSmall !== 'undefined' && tooSmall === false || typeof tooSmall === 'undefined') {\n        if (imgs.length) {\n          Object(_foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_2__[\"onImagesLoaded\"])(imgs, this._reflow.bind(this));\n        } else {\n          this._reflow();\n        }\n      }\n    }\n    /**\n     * Removes event listeners if the breakpoint is too small.\n     * @private\n     */\n\n  }, {\n    key: \"_pauseEvents\",\n    value: function _pauseEvents() {\n      this.isOn = false;\n      this.$element.off({\n        '.zf.equalizer': this._bindHandler.onPostEqualizedBound,\n        'resizeme.zf.trigger': this._bindHandler.onResizeMeBound,\n        'mutateme.zf.trigger': this._bindHandler.onResizeMeBound\n      });\n    }\n    /**\n     * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound\n     * @private\n     */\n\n  }, {\n    key: \"_onResizeMe\",\n    value: function _onResizeMe(e) {\n      this._reflow();\n    }\n    /**\n     * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound\n     * @private\n     */\n\n  }, {\n    key: \"_onPostEqualized\",\n    value: function _onPostEqualized(e) {\n      if (e.target !== this.$element[0]) {\n        this._reflow();\n      }\n    }\n    /**\n     * Initializes events for Equalizer.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      this._pauseEvents();\n\n      if (this.hasNested) {\n        this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);\n      } else {\n        this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);\n        this.$element.on('mutateme.zf.trigger', this._bindHandler.onResizeMeBound);\n      }\n\n      this.isOn = true;\n    }\n    /**\n     * Checks the current breakpoint to the minimum required size.\n     * @private\n     */\n\n  }, {\n    key: \"_checkMQ\",\n    value: function _checkMQ() {\n      var tooSmall = !_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].is(this.options.equalizeOn);\n\n      if (tooSmall) {\n        if (this.isOn) {\n          this._pauseEvents();\n\n          this.$watched.css('height', 'auto');\n        }\n      } else {\n        if (!this.isOn) {\n          this._events();\n        }\n      }\n\n      return tooSmall;\n    }\n    /**\n     * A noop version for the plugin\n     * @private\n     */\n\n  }, {\n    key: \"_killswitch\",\n    value: function _killswitch() {\n      return;\n    }\n    /**\n     * Calls necessary functions to update Equalizer upon DOM change\n     * @private\n     */\n\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      if (!this.options.equalizeOnStack) {\n        if (this._isStacked()) {\n          this.$watched.css('height', 'auto');\n          return false;\n        }\n      }\n\n      if (this.options.equalizeByRow) {\n        this.getHeightsByRow(this.applyHeightByRow.bind(this));\n      } else {\n        this.getHeights(this.applyHeight.bind(this));\n      }\n    }\n    /**\n     * Manually determines if the first 2 elements are *NOT* stacked.\n     * @private\n     */\n\n  }, {\n    key: \"_isStacked\",\n    value: function _isStacked() {\n      if (!this.$watched[0] || !this.$watched[1]) {\n        return true;\n      }\n\n      return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;\n    }\n    /**\n     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\n     * @param {Function} cb - A non-optional callback to return the heights array to.\n     * @returns {Array} heights - An array of heights of children within Equalizer container\n     */\n\n  }, {\n    key: \"getHeights\",\n    value: function getHeights(cb) {\n      var heights = [];\n\n      for (var i = 0, len = this.$watched.length; i < len; i++) {\n        this.$watched[i].style.height = 'auto';\n        heights.push(this.$watched[i].offsetHeight);\n      }\n\n      cb(heights);\n    }\n    /**\n     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\n     * @param {Function} cb - A non-optional callback to return the heights array to.\n     * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\n     */\n\n  }, {\n    key: \"getHeightsByRow\",\n    value: function getHeightsByRow(cb) {\n      var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,\n          groups = [],\n          group = 0; //group by Row\n\n      groups[group] = [];\n\n      for (var i = 0, len = this.$watched.length; i < len; i++) {\n        this.$watched[i].style.height = 'auto'; //maybe could use this.$watched[i].offsetTop\n\n        var elOffsetTop = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.$watched[i]).offset().top;\n\n        if (elOffsetTop != lastElTopOffset) {\n          group++;\n          groups[group] = [];\n          lastElTopOffset = elOffsetTop;\n        }\n\n        groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);\n      }\n\n      for (var j = 0, ln = groups.length; j < ln; j++) {\n        var heights = jquery__WEBPACK_IMPORTED_MODULE_0___default()(groups[j]).map(function () {\n          return this[1];\n        }).get();\n        var max = Math.max.apply(null, heights);\n        groups[j].push(max);\n      }\n\n      cb(groups);\n    }\n    /**\n     * Changes the CSS height property of each child in an Equalizer parent to match the tallest\n     * @param {array} heights - An array of heights of children within Equalizer container\n     * @fires Equalizer#preequalized\n     * @fires Equalizer#postequalized\n     */\n\n  }, {\n    key: \"applyHeight\",\n    value: function applyHeight(heights) {\n      var max = Math.max.apply(null, heights);\n      /**\n       * Fires before the heights are applied\n       * @event Equalizer#preequalized\n       */\n\n      this.$element.trigger('preequalized.zf.equalizer');\n      this.$watched.css('height', max);\n      /**\n       * Fires when the heights have been applied\n       * @event Equalizer#postequalized\n       */\n\n      this.$element.trigger('postequalized.zf.equalizer');\n    }\n    /**\n     * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row\n     * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\n     * @fires Equalizer#preequalized\n     * @fires Equalizer#preequalizedrow\n     * @fires Equalizer#postequalizedrow\n     * @fires Equalizer#postequalized\n     */\n\n  }, {\n    key: \"applyHeightByRow\",\n    value: function applyHeightByRow(groups) {\n      /**\n       * Fires before the heights are applied\n       */\n      this.$element.trigger('preequalized.zf.equalizer');\n\n      for (var i = 0, len = groups.length; i < len; i++) {\n        var groupsILength = groups[i].length,\n            max = groups[i][groupsILength - 1];\n\n        if (groupsILength <= 2) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(groups[i][0][0]).css({\n            'height': 'auto'\n          });\n          continue;\n        }\n        /**\n          * Fires before the heights per row are applied\n          * @event Equalizer#preequalizedrow\n          */\n\n\n        this.$element.trigger('preequalizedrow.zf.equalizer');\n\n        for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(groups[i][j][0]).css({\n            'height': max\n          });\n        }\n        /**\n          * Fires when the heights per row have been applied\n          * @event Equalizer#postequalizedrow\n          */\n\n\n        this.$element.trigger('postequalizedrow.zf.equalizer');\n      }\n      /**\n       * Fires when the heights have been applied\n       */\n\n\n      this.$element.trigger('postequalized.zf.equalizer');\n    }\n    /**\n     * Destroys an instance of Equalizer.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this._pauseEvents();\n\n      this.$watched.css('height', 'auto');\n    }\n  }]);\n\n  return Equalizer;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\"Plugin\"]);\n/**\n * Default settings for plugin\n */\n\n\nEqualizer.defaults = {\n  /**\n   * Enable height equalization when stacked on smaller screens.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  equalizeOnStack: false,\n\n  /**\n   * Enable height equalization row by row.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  equalizeByRow: false,\n\n  /**\n   * String representing the minimum breakpoint size the plugin should equalize heights on.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  equalizeOn: ''\n};\n\n\n//# sourceURL=webpack:///./js/foundation.equalizer.js?");/***/},/***/"./js/foundation.interchange.js":/*!**************************************!*\
	  !*** ./js/foundation.interchange.js ***!
	  \**************************************/ /*! exports provided: Interchange */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interchange\", function() { return Interchange; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Interchange module.\n * @module foundation.interchange\n * @requires foundation.util.mediaQuery\n */\n\nvar Interchange =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Interchange, _Plugin);\n\n  function Interchange() {\n    _classCallCheck(this, Interchange);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Interchange).apply(this, arguments));\n  }\n\n  _createClass(Interchange, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Interchange.\n     * @class\n     * @name Interchange\n     * @fires Interchange#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Interchange.defaults, this.$element.data(), options);\n      this.rules = [];\n      this.currentPath = '';\n      this.className = 'Interchange'; // ie9 back compat\n      // Triggers init is idempotent, just need to make sure it is initialized\n\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n\n      this._events();\n    }\n    /**\n     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init();\n\n      var id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'interchange');\n      this.$element.attr({\n        'data-resize': id,\n        'id': id\n      });\n\n      this._parseOptions();\n\n      this._addBreakpoints();\n\n      this._generateRules();\n\n      this._reflow();\n    }\n    /**\n     * Initializes events for Interchange.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function () {\n        return _this._reflow();\n      });\n    }\n    /**\n     * Calls necessary functions to update Interchange upon DOM change\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      var match; // Iterate through each rule, but only save the last match\n\n      for (var i in this.rules) {\n        if (this.rules.hasOwnProperty(i)) {\n          var rule = this.rules[i];\n\n          if (window.matchMedia(rule.query).matches) {\n            match = rule;\n          }\n        }\n      }\n\n      if (match) {\n        this.replace(match.path);\n      }\n    }\n    /**\n     * Check options valifity and set defaults for:\n     * - `data-interchange-type`: if set, enforce the type of replacement (auto, src, background or html)\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_parseOptions\",\n    value: function _parseOptions() {\n      var types = ['auto', 'src', 'background', 'html'];\n      if (typeof this.options.type === 'undefined') this.options.type = 'auto';else if (types.indexOf(this.options.type) === -1) {\n        console.log(\"Warning: invalid value \\\"\".concat(this.options.type, \"\\\" for Interchange option \\\"type\\\"\"));\n        this.options.type = 'auto';\n      }\n    }\n    /**\n     * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_addBreakpoints\",\n    value: function _addBreakpoints() {\n      for (var i in _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].queries) {\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].queries.hasOwnProperty(i)) {\n          var query = _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].queries[i];\n          Interchange.SPECIAL_QUERIES[query.name] = query.value;\n        }\n      }\n    }\n    /**\n     * Checks the Interchange element for the provided media query + content pairings\n     * @function\n     * @private\n     * @param {Object} element - jQuery object that is an Interchange instance\n     * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys\n     */\n\n  }, {\n    key: \"_generateRules\",\n    value: function _generateRules(element) {\n      var rulesList = [];\n      var rules;\n\n      if (this.options.rules) {\n        rules = this.options.rules;\n      } else {\n        rules = this.$element.data('interchange');\n      }\n\n      rules = typeof rules === 'string' ? rules.match(/\\[.*?, .*?\\]/g) : rules;\n\n      for (var i in rules) {\n        if (rules.hasOwnProperty(i)) {\n          var rule = rules[i].slice(1, -1).split(', ');\n          var path = rule.slice(0, -1).join('');\n          var query = rule[rule.length - 1];\n\n          if (Interchange.SPECIAL_QUERIES[query]) {\n            query = Interchange.SPECIAL_QUERIES[query];\n          }\n\n          rulesList.push({\n            path: path,\n            query: query\n          });\n        }\n      }\n\n      this.rules = rulesList;\n    }\n    /**\n     * Update the `src` property of an image, or change the HTML of a container, to the specified path.\n     * @function\n     * @param {String} path - Path to the image or HTML partial.\n     * @fires Interchange#replaced\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(path) {\n      var _this2 = this;\n\n      if (this.currentPath === path) return;\n      var trigger = 'replaced.zf.interchange';\n      var type = this.options.type;\n\n      if (type === 'auto') {\n        if (this.$element[0].nodeName === 'IMG') type = 'src';else if (path.match(/\\.(gif|jpe?g|png|svg|tiff)([?#].*)?/i)) type = 'background';else type = 'html';\n      } // Replacing images\n\n\n      if (type === 'src') {\n        this.$element.attr('src', path).on('load', function () {\n          _this2.currentPath = path;\n        }).trigger(trigger);\n      } // Replacing background images\n      else if (type === 'background') {\n          path = path.replace(/\\(/g, '%28').replace(/\\)/g, '%29');\n          this.$element.css({\n            'background-image': 'url(' + path + ')'\n          }).trigger(trigger);\n        } // Replacing HTML\n        else if (type === 'html') {\n            jquery__WEBPACK_IMPORTED_MODULE_0___default.a.get(path, function (response) {\n              _this2.$element.html(response).trigger(trigger);\n\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()(response).foundation();\n              _this2.currentPath = path;\n            });\n          }\n      /**\n       * Fires when content in an Interchange element is done being loaded.\n       * @event Interchange#replaced\n       */\n      // this.$element.trigger('replaced.zf.interchange');\n\n    }\n    /**\n     * Destroys an instance of interchange.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.off('resizeme.zf.trigger');\n    }\n  }]);\n\n  return Interchange;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\"Plugin\"]);\n/**\n * Default settings for plugin\n */\n\n\nInterchange.defaults = {\n  /**\n   * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.\n   * @option\n   * @type {?array}\n   * @default null\n   */\n  rules: null,\n\n  /**\n   * Type of the responsive ressource to replace. It can take the following options:\n   * - `auto` (default): choose the type according to the element tag or the ressource extension,\n   * - `src`: replace the `[src]` attribute, recommended for images `<img>`.\n   * - `background`: replace the `background-image` CSS property.\n   * - `html`: replace the element content.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  type: 'auto'\n};\nInterchange.SPECIAL_QUERIES = {\n  'landscape': 'screen and (orientation: landscape)',\n  'portrait': 'screen and (orientation: portrait)',\n  'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'\n};\n\n\n//# sourceURL=webpack:///./js/foundation.interchange.js?");/***/},/***/"./js/foundation.magellan.js":/*!***********************************!*\
	  !*** ./js/foundation.magellan.js ***!
	  \***********************************/ /*! exports provided: Magellan */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Magellan\", function() { return Magellan; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_smoothScroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.smoothScroll */ \"./js/foundation.smoothScroll.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Magellan module.\n * @module foundation.magellan\n * @requires foundation.smoothScroll\n * @requires foundation.util.triggers\n */\n\nvar Magellan =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Magellan, _Plugin);\n\n  function Magellan() {\n    _classCallCheck(this, Magellan);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Magellan).apply(this, arguments));\n  }\n\n  _createClass(Magellan, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Magellan.\n     * @class\n     * @name Magellan\n     * @fires Magellan#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Magellan.defaults, this.$element.data(), options);\n      this.className = 'Magellan'; // ie9 back compat\n      // Triggers init is idempotent, just need to make sure it is initialized\n\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n\n      this.calcPoints();\n    }\n    /**\n     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'magellan');\n\n      var _this = this;\n\n      this.$targets = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-magellan-target]');\n      this.$links = this.$element.find('a');\n      this.$element.attr({\n        'data-resize': id,\n        'data-scroll': id,\n        'id': id\n      });\n      this.$active = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\n      this.scrollPos = parseInt(window.pageYOffset, 10);\n\n      this._events();\n    }\n    /**\n     * Calculates an array of pixel values that are the demarcation lines between locations on the page.\n     * Can be invoked if new elements are added or the size of a location changes.\n     * @function\n     */\n\n  }, {\n    key: \"calcPoints\",\n    value: function calcPoints() {\n      var _this = this,\n          body = document.body,\n          html = document.documentElement;\n\n      this.points = [];\n      this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));\n      this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));\n      this.$targets.each(function () {\n        var $tar = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            pt = Math.round($tar.offset().top - _this.options.threshold);\n        $tar.targetPoint = pt;\n\n        _this.points.push(pt);\n      });\n    }\n    /**\n     * Initializes events for Magellan.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).one('load', function () {\n        if (_this.options.deepLinking) {\n          if (location.hash) {\n            _this.scrollToLoc(location.hash);\n          }\n        }\n\n        _this.calcPoints();\n\n        _this._updateActive();\n      });\n      _this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"onLoad\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\n        _this.$element.on({\n          'resizeme.zf.trigger': _this.reflow.bind(_this),\n          'scrollme.zf.trigger': _this._updateActive.bind(_this)\n        }).on('click.zf.magellan', 'a[href^=\"#\"]', function (e) {\n          e.preventDefault();\n          var arrival = this.getAttribute('href');\n\n          _this.scrollToLoc(arrival);\n        });\n      });\n\n      this._deepLinkScroll = function (e) {\n        if (_this.options.deepLinking) {\n          _this.scrollToLoc(window.location.hash);\n        }\n      };\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('hashchange', this._deepLinkScroll);\n    }\n    /**\n     * Function to scroll to a given location on the page.\n     * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'\n     * @function\n     */\n\n  }, {\n    key: \"scrollToLoc\",\n    value: function scrollToLoc(loc) {\n      this._inTransition = true;\n\n      var _this = this;\n\n      var options = {\n        animationEasing: this.options.animationEasing,\n        animationDuration: this.options.animationDuration,\n        threshold: this.options.threshold,\n        offset: this.options.offset\n      };\n      _foundation_smoothScroll__WEBPACK_IMPORTED_MODULE_3__[\"SmoothScroll\"].scrollToLoc(loc, options, function () {\n        _this._inTransition = false;\n      });\n    }\n    /**\n     * Calls necessary functions to update Magellan upon DOM change\n     * @function\n     */\n\n  }, {\n    key: \"reflow\",\n    value: function reflow() {\n      this.calcPoints();\n\n      this._updateActive();\n    }\n    /**\n     * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.\n     * @private\n     * @function\n     * @fires Magellan#update\n     */\n\n  }, {\n    key: \"_updateActive\",\n    value: function _updateActive()\n    /*evt, elem, scrollPos*/\n    {\n      var _this2 = this;\n\n      if (this._inTransition) return;\n      var newScrollPos = parseInt(window.pageYOffset, 10);\n      var isScrollingUp = this.scrollPos > newScrollPos;\n      this.scrollPos = newScrollPos;\n      var activeIdx; // Before the first point: no link\n\n      if (newScrollPos < this.points[0]) {}\n      /* do nothing */\n      // At the bottom of the page: last link\n      else if (newScrollPos + this.winHeight === this.docHeight) {\n          activeIdx = this.points.length - 1;\n        } // Otherwhise, use the last visible link\n        else {\n            var visibleLinks = this.points.filter(function (p, i) {\n              return p - _this2.options.offset - (isScrollingUp ? _this2.options.threshold : 0) <= newScrollPos;\n            });\n            activeIdx = visibleLinks.length ? visibleLinks.length - 1 : 0;\n          } // Get the new active link\n\n\n      var $oldActive = this.$active;\n      var activeHash = '';\n\n      if (typeof activeIdx !== 'undefined') {\n        this.$active = this.$links.filter('[href=\"#' + this.$targets.eq(activeIdx).data('magellan-target') + '\"]');\n        if (this.$active.length) activeHash = this.$active[0].getAttribute('href');\n      } else {\n        this.$active = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\n      }\n\n      var isNewActive = !(!this.$active.length && !$oldActive.length) && !this.$active.is($oldActive);\n      var isNewHash = activeHash !== window.location.hash; // Update the active link element\n\n      if (isNewActive) {\n        $oldActive.removeClass(this.options.activeClass);\n        this.$active.addClass(this.options.activeClass);\n      } // Update the hash (it may have changed with the same active link)\n\n\n      if (this.options.deepLinking && isNewHash) {\n        if (window.history.pushState) {\n          // Set or remove the hash (see: https://stackoverflow.com/a/5298684/4317384\n          var url = activeHash ? activeHash : window.location.pathname + window.location.search;\n\n          if (this.options.updateHistory) {\n            window.history.pushState({}, '', url);\n          } else {\n            window.history.replaceState({}, '', url);\n          }\n        } else {\n          window.location.hash = activeHash;\n        }\n      }\n\n      if (isNewActive) {\n        /**\n         * Fires when magellan is finished updating to the new active element.\n         * @event Magellan#update\n         */\n        this.$element.trigger('update.zf.magellan', [this.$active]);\n      }\n    }\n    /**\n     * Destroys an instance of Magellan and resets the url of the window.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.off('.zf.trigger .zf.magellan').find(\".\".concat(this.options.activeClass)).removeClass(this.options.activeClass);\n\n      if (this.options.deepLinking) {\n        var hash = this.$active[0].getAttribute('href');\n        window.location.hash.replace(hash, '');\n      }\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('hashchange', this._deepLinkScroll);\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\n    }\n  }]);\n\n  return Magellan;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n/**\n * Default settings for plugin\n */\n\n\nMagellan.defaults = {\n  /**\n   * Amount of time, in ms, the animated scrolling should take between locations.\n   * @option\n   * @type {number}\n   * @default 500\n   */\n  animationDuration: 500,\n\n  /**\n   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.\n   * @option\n   * @type {string}\n   * @default 'linear'\n   * @see {@link https://api.jquery.com/animate|Jquery animate}\n   */\n  animationEasing: 'linear',\n\n  /**\n   * Number of pixels to use as a marker for location changes.\n   * @option\n   * @type {number}\n   * @default 50\n   */\n  threshold: 50,\n\n  /**\n   * Class applied to the active locations link on the magellan container.\n   * @option\n   * @type {string}\n   * @default 'is-active'\n   */\n  activeClass: 'is-active',\n\n  /**\n   * Allows the script to manipulate the url of the current page, and if supported, alter the history.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  deepLinking: false,\n\n  /**\n   * Update the browser history with the active link, if deep linking is enabled.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  updateHistory: false,\n\n  /**\n   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  offset: 0\n};\n\n\n//# sourceURL=webpack:///./js/foundation.magellan.js?");/***/},/***/"./js/foundation.offcanvas.js":/*!************************************!*\
	  !*** ./js/foundation.offcanvas.js ***!
	  \************************************/ /*! exports provided: OffCanvas */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OffCanvas\", function() { return OffCanvas; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n/**\n * OffCanvas module.\n * @module foundation.offCanvas\n * @requires foundation.util.keyboard\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.triggers\n */\n\nvar OffCanvas =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(OffCanvas, _Plugin);\n\n  function OffCanvas() {\n    _classCallCheck(this, OffCanvas);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(OffCanvas).apply(this, arguments));\n  }\n\n  _createClass(OffCanvas, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of an off-canvas wrapper.\n     * @class\n     * @name OffCanvas\n     * @fires OffCanvas#init\n     * @param {Object} element - jQuery object to initialize.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      var _this2 = this;\n\n      this.className = 'OffCanvas'; // ie9 back compat\n\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, OffCanvas.defaults, this.$element.data(), options);\n      this.contentClasses = {\n        base: [],\n        reveal: []\n      };\n      this.$lastTrigger = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\n      this.$triggers = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\n      this.position = 'left';\n      this.$content = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\n      this.nested = !!this.options.nested;\n      this.$sticky = jquery__WEBPACK_IMPORTED_MODULE_0___default()();\n      this.isInCanvas = false; // Defines the CSS transition/position classes of the off-canvas content container.\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(['push', 'overlap']).each(function (index, val) {\n        _this2.contentClasses.base.push('has-transition-' + val);\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(['left', 'right', 'top', 'bottom']).each(function (index, val) {\n        _this2.contentClasses.base.push('has-position-' + val);\n\n        _this2.contentClasses.reveal.push('has-reveal-' + val);\n      }); // Triggers init is idempotent, just need to make sure it is initialized\n\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_5__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__[\"MediaQuery\"]._init();\n\n      this._init();\n\n      this._events();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].register('OffCanvas', {\n        'ESCAPE': 'close'\n      });\n    }\n    /**\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var id = this.$element.attr('id');\n      this.$element.attr('aria-hidden', 'true'); // Find off-canvas content, either by ID (if specified), by siblings or by closest selector (fallback)\n\n      if (this.options.contentId) {\n        this.$content = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + this.options.contentId);\n      } else if (this.$element.siblings('[data-off-canvas-content]').length) {\n        this.$content = this.$element.siblings('[data-off-canvas-content]').first();\n      } else {\n        this.$content = this.$element.closest('[data-off-canvas-content]').first();\n      }\n\n      if (!this.options.contentId) {\n        // Assume that the off-canvas element is nested if it isn't a sibling of the content\n        this.nested = this.$element.siblings('[data-off-canvas-content]').length === 0;\n      } else if (this.options.contentId && this.options.nested === null) {\n        // Warning if using content ID without setting the nested option\n        // Once the element is nested it is required to work properly in this case\n        console.warn('Remember to use the nested option if using the content ID option!');\n      }\n\n      if (this.nested === true) {\n        // Force transition overlap if nested\n        this.options.transition = 'overlap'; // Remove appropriate classes if already assigned in markup\n\n        this.$element.removeClass('is-transition-push');\n      }\n\n      this.$element.addClass(\"is-transition-\".concat(this.options.transition, \" is-closed\")); // Find triggers that affect this element and add aria-expanded to them\n\n      this.$triggers = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).find('[data-open=\"' + id + '\"], [data-close=\"' + id + '\"], [data-toggle=\"' + id + '\"]').attr('aria-expanded', 'false').attr('aria-controls', id); // Get position by checking for related CSS class\n\n      this.position = this.$element.is('.position-left, .position-top, .position-right, .position-bottom') ? this.$element.attr('class').match(/position\\-(left|top|right|bottom)/)[1] : this.position; // Add an overlay over the content if necessary\n\n      if (this.options.contentOverlay === true) {\n        var overlay = document.createElement('div');\n        var overlayPosition = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.$element).css(\"position\") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';\n        overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);\n        this.$overlay = jquery__WEBPACK_IMPORTED_MODULE_0___default()(overlay);\n\n        if (overlayPosition === 'is-overlay-fixed') {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.$overlay).insertAfter(this.$element);\n        } else {\n          this.$content.append(this.$overlay);\n        }\n      } // Get the revealOn option from the class.\n\n\n      var revealOnRegExp = new RegExp(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"RegExpEscape\"])(this.options.revealClass) + '([^\\\\s]+)', 'g');\n      var revealOnClass = revealOnRegExp.exec(this.$element[0].className);\n\n      if (revealOnClass) {\n        this.options.isRevealed = true;\n        this.options.revealOn = this.options.revealOn || revealOnClass[1];\n      } // Ensure the `reveal-on-*` class is set.\n\n\n      if (this.options.isRevealed === true && this.options.revealOn) {\n        this.$element.first().addClass(\"\".concat(this.options.revealClass).concat(this.options.revealOn));\n\n        this._setMQChecker();\n      }\n\n      if (this.options.transitionTime) {\n        this.$element.css('transition-duration', this.options.transitionTime);\n      } // Find fixed elements that should stay fixed while off-canvas is opened\n\n\n      this.$sticky = this.$content.find('[data-off-canvas-sticky]');\n\n      if (this.$sticky.length > 0 && this.options.transition === 'push') {\n        // If there's at least one match force contentScroll:false because the absolute top value doesn't get recalculated on scroll\n        // Limit to push transition since there's no transform scope for overlap\n        this.options.contentScroll = false;\n      }\n\n      var inCanvasFor = this.$element.attr('class').match(/\\bin-canvas-for-(\\w+)/);\n\n      if (inCanvasFor && inCanvasFor.length === 2) {\n        // Set `inCanvasOn` option if found in-canvas-for-[BREAKPONT] CSS class\n        this.options.inCanvasOn = inCanvasFor[1];\n      } else if (this.options.inCanvasOn) {\n        // Ensure the CSS class is set\n        this.$element.addClass(\"in-canvas-for-\".concat(this.options.inCanvasOn));\n      }\n\n      if (this.options.inCanvasOn) {\n        this._checkInCanvas();\n      } // Initally remove all transition/position CSS classes from off-canvas content container.\n\n\n      this._removeContentClasses();\n    }\n    /**\n     * Adds event handlers to the off-canvas wrapper and the exit overlay.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this3 = this;\n\n      this.$element.off('.zf.trigger .zf.offCanvas').on({\n        'open.zf.trigger': this.open.bind(this),\n        'close.zf.trigger': this.close.bind(this),\n        'toggle.zf.trigger': this.toggle.bind(this),\n        'keydown.zf.offCanvas': this._handleKeyboard.bind(this)\n      });\n\n      if (this.options.closeOnClick === true) {\n        var $target = this.options.contentOverlay ? this.$overlay : this.$content;\n        $target.on({\n          'click.zf.offCanvas': this.close.bind(this)\n        });\n      }\n\n      if (this.options.inCanvasOn) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', function () {\n          _this3._checkInCanvas();\n        });\n      }\n    }\n    /**\n     * Applies event listener for elements that will reveal at certain breakpoints.\n     * @private\n     */\n\n  }, {\n    key: \"_setMQChecker\",\n    value: function _setMQChecker() {\n      var _this = this;\n\n      this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"onLoad\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__[\"MediaQuery\"].atLeast(_this.options.revealOn)) {\n          _this.reveal(true);\n        }\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', function () {\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__[\"MediaQuery\"].atLeast(_this.options.revealOn)) {\n          _this.reveal(true);\n        } else {\n          _this.reveal(false);\n        }\n      });\n    }\n    /**\n     * Checks if InCanvas on current breakpoint and adjust off-canvas accordingly\n     * @private\n     */\n\n  }, {\n    key: \"_checkInCanvas\",\n    value: function _checkInCanvas() {\n      this.isInCanvas = _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__[\"MediaQuery\"].atLeast(this.options.inCanvasOn);\n\n      if (this.isInCanvas === true) {\n        this.close();\n      }\n    }\n    /**\n     * Removes the CSS transition/position classes of the off-canvas content container.\n     * Removing the classes is important when another off-canvas gets opened that uses the same content container.\n     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.\n     * @private\n     */\n\n  }, {\n    key: \"_removeContentClasses\",\n    value: function _removeContentClasses(hasReveal) {\n      if (typeof hasReveal !== 'boolean') {\n        this.$content.removeClass(this.contentClasses.base.join(' '));\n      } else if (hasReveal === false) {\n        this.$content.removeClass(\"has-reveal-\".concat(this.position));\n      }\n    }\n    /**\n     * Adds the CSS transition/position classes of the off-canvas content container, based on the opening off-canvas element.\n     * Beforehand any transition/position class gets removed.\n     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.\n     * @private\n     */\n\n  }, {\n    key: \"_addContentClasses\",\n    value: function _addContentClasses(hasReveal) {\n      this._removeContentClasses(hasReveal);\n\n      if (typeof hasReveal !== 'boolean') {\n        this.$content.addClass(\"has-transition-\".concat(this.options.transition, \" has-position-\").concat(this.position));\n      } else if (hasReveal === true) {\n        this.$content.addClass(\"has-reveal-\".concat(this.position));\n      }\n    }\n    /**\n     * Preserves the fixed behavior of sticky elements on opening an off-canvas with push transition.\n     * Since the off-canvas container has got a transform scope in such a case, it is done by calculating position absolute values.\n     * @private\n     */\n\n  }, {\n    key: \"_fixStickyElements\",\n    value: function _fixStickyElements() {\n      this.$sticky.each(function (_, el) {\n        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el); // If sticky element is currently fixed, adjust its top value to match absolute position due to transform scope\n        // Limit to push transition because postion:fixed works without problems for overlap (no transform scope)\n\n        if ($el.css('position') === 'fixed') {\n          // Save current inline styling to restore it if undoing the absolute fixing\n          var topVal = parseInt($el.css('top'), 10);\n          $el.data('offCanvasSticky', {\n            top: topVal\n          });\n          var absoluteTopVal = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).scrollTop() + topVal;\n          $el.css({\n            top: \"\".concat(absoluteTopVal, \"px\"),\n            width: '100%',\n            transition: 'none'\n          });\n        }\n      });\n    }\n    /**\n     * Restores the original fixed styling of sticky elements after having closed an off-canvas that got pseudo fixed beforehand.\n     * This reverts the changes of _fixStickyElements()\n     * @private\n     */\n\n  }, {\n    key: \"_unfixStickyElements\",\n    value: function _unfixStickyElements() {\n      this.$sticky.each(function (_, el) {\n        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()(el);\n        var stickyData = $el.data('offCanvasSticky'); // If sticky element has got data object with prior values (meaning it was originally fixed) restore these values once off-canvas is closed\n\n        if (_typeof(stickyData) === 'object') {\n          $el.css({\n            top: \"\".concat(stickyData.top, \"px\"),\n            width: '',\n            transition: ''\n          });\n          $el.data('offCanvasSticky', '');\n        }\n      });\n    }\n    /**\n     * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\n     * @param {Boolean} isRevealed - true if element should be revealed.\n     * @function\n     */\n\n  }, {\n    key: \"reveal\",\n    value: function reveal(isRevealed) {\n      if (isRevealed) {\n        this.close();\n        this.isRevealed = true;\n        this.$element.attr('aria-hidden', 'false');\n        this.$element.off('open.zf.trigger toggle.zf.trigger');\n        this.$element.removeClass('is-closed');\n      } else {\n        this.isRevealed = false;\n        this.$element.attr('aria-hidden', 'true');\n        this.$element.off('open.zf.trigger toggle.zf.trigger').on({\n          'open.zf.trigger': this.open.bind(this),\n          'toggle.zf.trigger': this.toggle.bind(this)\n        });\n        this.$element.addClass('is-closed');\n      }\n\n      this._addContentClasses(isRevealed);\n    }\n    /**\n     * Stops scrolling of the body when OffCanvas is open on mobile Safari and other troublesome browsers.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_stopScrolling\",\n    value: function _stopScrolling(event) {\n      return false;\n    }\n    /**\n     * Tag the element given as context whether it can be scrolled up and down.\n     * Used to allow or prevent it to scroll. See `_stopScrollPropagation`.\n     *\n     * Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios\n     * Only really works for y, not sure how to extend to x or if we need to.\n     *\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_recordScrollable\",\n    value: function _recordScrollable(event) {\n      var elem = this; // called from event handler context with this as elem\n      // If the element is scrollable (content overflows), then...\n\n      if (elem.scrollHeight !== elem.clientHeight) {\n        // If we're at the top, scroll down one pixel to allow scrolling up\n        if (elem.scrollTop === 0) {\n          elem.scrollTop = 1;\n        } // If we're at the bottom, scroll up one pixel to allow scrolling down\n\n\n        if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {\n          elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;\n        }\n      }\n\n      elem.allowUp = elem.scrollTop > 0;\n      elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;\n      elem.lastY = event.originalEvent.pageY;\n    }\n    /**\n     * Prevent the given event propagation if the element given as context can scroll.\n     * Used to preserve the element scrolling on mobile (`touchmove`) when the document\n     * scrolling is prevented. See https://git.io/zf-9707.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_stopScrollPropagation\",\n    value: function _stopScrollPropagation(event) {\n      var elem = this; // called from event handler context with this as elem\n\n      var parent; // off-canvas elem if called from inner scrollbox\n\n      var up = event.pageY < elem.lastY;\n      var down = !up;\n      elem.lastY = event.pageY;\n\n      if (up && elem.allowUp || down && elem.allowDown) {\n        // It is not recommended to stop event propagation (the user cannot watch it),\n        // but in this case this is the only solution we have.\n        event.stopPropagation(); // If elem is inner scrollbox we are scrolling the outer off-canvas down/up once the box end has been reached\n        // This lets the user continue to touch move the off-canvas without the need to place the finger outside the scrollbox\n\n        if (elem.hasAttribute('data-off-canvas-scrollbox')) {\n          parent = elem.closest('[data-off-canvas], [data-off-canvas-scrollbox-outer]');\n\n          if (elem.scrollTop <= 1 && parent.scrollTop > 0) {\n            parent.scrollTop--;\n          } else if (elem.scrollTop >= elem.scrollHeight - elem.clientHeight - 1 && parent.scrollTop < parent.scrollHeight - parent.clientHeight) {\n            parent.scrollTop++;\n          }\n        }\n      } else {\n        event.preventDefault();\n      }\n    }\n    /**\n     * Opens the off-canvas menu.\n     * @function\n     * @param {Object} event - Event object passed from listener.\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\n     * @fires OffCanvas#opened\n     * @todo also trigger 'open' event?\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(event, trigger) {\n      var _this4 = this;\n\n      if (this.$element.hasClass('is-open') || this.isRevealed || this.isInCanvas) {\n        return;\n      }\n\n      var _this = this;\n\n      if (trigger) {\n        this.$lastTrigger = trigger;\n      }\n\n      if (this.options.forceTo === 'top') {\n        window.scrollTo(0, 0);\n      } else if (this.options.forceTo === 'bottom') {\n        window.scrollTo(0, document.body.scrollHeight);\n      }\n\n      if (this.options.transitionTime && this.options.transition !== 'overlap') {\n        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', this.options.transitionTime);\n      } else {\n        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', '');\n      }\n\n      this.$element.addClass('is-open').removeClass('is-closed');\n      this.$triggers.attr('aria-expanded', 'true');\n      this.$element.attr('aria-hidden', 'false');\n      this.$content.addClass('is-open-' + this.position); // If `contentScroll` is set to false, add class and disable scrolling on touch devices.\n\n      if (this.options.contentScroll === false) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);\n        this.$element.on('touchstart', this._recordScrollable);\n        this.$element.on('touchmove', this._stopScrollPropagation);\n        this.$element.on('touchstart', '[data-off-canvas-scrollbox]', this._recordScrollable);\n        this.$element.on('touchmove', '[data-off-canvas-scrollbox]', this._stopScrollPropagation);\n      }\n\n      if (this.options.contentOverlay === true) {\n        this.$overlay.addClass('is-visible');\n      }\n\n      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n        this.$overlay.addClass('is-closable');\n      }\n\n      if (this.options.autoFocus === true) {\n        this.$element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"transitionend\"])(this.$element), function () {\n          if (!_this.$element.hasClass('is-open')) {\n            return; // exit if prematurely closed\n          }\n\n          var canvasFocus = _this.$element.find('[data-autofocus]');\n\n          if (canvasFocus.length) {\n            canvasFocus.eq(0).focus();\n          } else {\n            _this.$element.find('a, button').eq(0).focus();\n          }\n        });\n      }\n\n      if (this.options.trapFocus === true) {\n        this.$content.attr('tabindex', '-1');\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].trapFocus(this.$element);\n      }\n\n      if (this.options.transition === 'push') {\n        this._fixStickyElements();\n      }\n\n      this._addContentClasses();\n      /**\n       * Fires when the off-canvas menu opens.\n       * @event OffCanvas#opened\n       */\n\n\n      this.$element.trigger('opened.zf.offCanvas');\n      /**\n       * Fires when the off-canvas menu open transition is done.\n       * @event OffCanvas#openedEnd\n       */\n\n      this.$element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"transitionend\"])(this.$element), function () {\n        _this4.$element.trigger('openedEnd.zf.offCanvas');\n      });\n    }\n    /**\n     * Closes the off-canvas menu.\n     * @function\n     * @param {Function} cb - optional cb to fire after closure.\n     * @fires OffCanvas#close\n     * @fires OffCanvas#closed\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(cb) {\n      var _this5 = this;\n\n      if (!this.$element.hasClass('is-open') || this.isRevealed) {\n        return;\n      }\n      /**\n       * Fires when the off-canvas menu closes.\n       * @event OffCanvas#close\n       */\n\n\n      this.$element.trigger('close.zf.offCanvas');\n\n      var _this = this;\n\n      this.$element.removeClass('is-open');\n      this.$element.attr('aria-hidden', 'true');\n      this.$content.removeClass('is-open-left is-open-top is-open-right is-open-bottom');\n\n      if (this.options.contentOverlay === true) {\n        this.$overlay.removeClass('is-visible');\n      }\n\n      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n        this.$overlay.removeClass('is-closable');\n      }\n\n      this.$triggers.attr('aria-expanded', 'false'); // Listen to transitionEnd: add class, re-enable scrolling and release focus when done.\n\n      this.$element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"transitionend\"])(this.$element), function (e) {\n        _this5.$element.addClass('is-closed');\n\n        _this5._removeContentClasses();\n\n        if (_this5.options.transition === 'push') {\n          _this5._unfixStickyElements();\n        } // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.\n\n\n        if (_this5.options.contentScroll === false) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').removeClass('is-off-canvas-open').off('touchmove', _this5._stopScrolling);\n\n          _this5.$element.off('touchstart', _this5._recordScrollable);\n\n          _this5.$element.off('touchmove', _this5._stopScrollPropagation);\n\n          _this5.$element.off('touchstart', '[data-off-canvas-scrollbox]', _this5._recordScrollable);\n\n          _this5.$element.off('touchmove', '[data-off-canvas-scrollbox]', _this5._stopScrollPropagation);\n        }\n\n        if (_this5.options.trapFocus === true) {\n          _this5.$content.removeAttr('tabindex');\n\n          _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].releaseFocus(_this5.$element);\n        }\n        /**\n         * Fires when the off-canvas menu close transition is done.\n         * @event OffCanvas#closed\n         */\n\n\n        _this5.$element.trigger('closed.zf.offCanvas');\n      });\n    }\n    /**\n     * Toggles the off-canvas menu open or closed.\n     * @function\n     * @param {Object} event - Event object passed from listener.\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(event, trigger) {\n      if (this.$element.hasClass('is-open')) {\n        this.close(event, trigger);\n      } else {\n        this.open(event, trigger);\n      }\n    }\n    /**\n     * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_handleKeyboard\",\n    value: function _handleKeyboard(e) {\n      var _this6 = this;\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].handleKey(e, 'OffCanvas', {\n        close: function close() {\n          _this6.close();\n\n          _this6.$lastTrigger.focus();\n\n          return true;\n        },\n        handled: function handled() {\n          e.preventDefault();\n        }\n      });\n    }\n    /**\n     * Destroys the OffCanvas plugin.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.close();\n      this.$element.off('.zf.trigger .zf.offCanvas');\n      this.$overlay.off('.zf.offCanvas');\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\n    }\n  }]);\n\n  return OffCanvas;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n\nOffCanvas.defaults = {\n  /**\n   * Allow the user to click outside of the menu to close it.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClick: true,\n\n  /**\n   * Adds an overlay on top of `[data-off-canvas-content]`.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  contentOverlay: true,\n\n  /**\n   * Target an off-canvas content container by ID that may be placed anywhere. If null the closest content container will be taken.\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  contentId: null,\n\n  /**\n   * Define the off-canvas element is nested in an off-canvas content. This is required when using the contentId option for a nested element.\n   * @option\n   * @type {boolean}\n   * @default null\n   */\n  nested: null,\n\n  /**\n   * Enable/disable scrolling of the main content when an off canvas panel is open.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  contentScroll: true,\n\n  /**\n   * Amount of time the open and close transition requires, including the appropriate milliseconds (`ms`) or seconds (`s`) unit (e.g. `500ms`, `.75s`) If none selected, pulls from body style.\n   * @option\n   * @type {string}\n   * @default null\n   */\n  transitionTime: null,\n\n  /**\n   * Type of transition for the OffCanvas menu. Options are 'push', 'detached' or 'slide'.\n   * @option\n   * @type {string}\n   * @default push\n   */\n  transition: 'push',\n\n  /**\n   * Force the page to scroll to top or bottom on open.\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  forceTo: null,\n\n  /**\n   * Allow the OffCanvas to remain open for certain breakpoints.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  isRevealed: false,\n\n  /**\n   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  revealOn: null,\n\n  /**\n   * Breakpoint at which the off-canvas gets moved into canvas content and acts as regular page element.\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  inCanvasOn: null,\n\n  /**\n   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  autoFocus: true,\n\n  /**\n   * Class used to force an OffCanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\n   * @option\n   * @type {string}\n   * @default reveal-for-\n   * @todo improve the regex testing for this.\n   */\n  revealClass: 'reveal-for-',\n\n  /**\n   * Triggers optional focus trapping when opening an OffCanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  trapFocus: false\n};\n\n\n//# sourceURL=webpack:///./js/foundation.offcanvas.js?");/***/},/***/"./js/foundation.orbit.js":/*!********************************!*\
	  !*** ./js/foundation.orbit.js ***!
	  \********************************/ /*! exports provided: Orbit */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Orbit\", function() { return Orbit; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\n/* harmony import */ var _foundation_util_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.timer */ \"./js/foundation.util.timer.js\");\n/* harmony import */ var _foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.imageLoader */ \"./js/foundation.util.imageLoader.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./foundation.util.touch */ \"./js/foundation.util.touch.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n/**\n * Orbit module.\n * @module foundation.orbit\n * @requires foundation.util.keyboard\n * @requires foundation.util.motion\n * @requires foundation.util.timer\n * @requires foundation.util.imageLoader\n * @requires foundation.util.touch\n */\n\nvar Orbit =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Orbit, _Plugin);\n\n  function Orbit() {\n    _classCallCheck(this, Orbit);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Orbit).apply(this, arguments));\n  }\n\n  _createClass(Orbit, [{\n    key: \"_setup\",\n\n    /**\n    * Creates a new instance of an orbit carousel.\n    * @class\n    * @name Orbit\n    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.\n    * @param {Object} options - Overrides to the default plugin settings.\n    */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Orbit.defaults, this.$element.data(), options);\n      this.className = 'Orbit'; // ie9 back compat\n\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_7__[\"Touch\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a); // Touch init is idempotent, we just need to make sure it's initialied.\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].register('Orbit', {\n        'ltr': {\n          'ARROW_RIGHT': 'next',\n          'ARROW_LEFT': 'previous'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'next',\n          'ARROW_RIGHT': 'previous'\n        }\n      });\n    }\n    /**\n    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.\n    * @function\n    * @private\n    */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      // @TODO: consider discussion on PR #9278 about DOM pollution by changeSlide\n      this._reset();\n\n      this.$wrapper = this.$element.find(\".\".concat(this.options.containerClass));\n      this.$slides = this.$element.find(\".\".concat(this.options.slideClass));\n      var $images = this.$element.find('img'),\n          initActive = this.$slides.filter('.is-active'),\n          id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_5__[\"GetYoDigits\"])(6, 'orbit');\n      this.$element.attr({\n        'data-resize': id,\n        'id': id\n      });\n\n      if (!initActive.length) {\n        this.$slides.eq(0).addClass('is-active');\n      }\n\n      if (!this.options.useMUI) {\n        this.$slides.addClass('no-motionui');\n      }\n\n      if ($images.length) {\n        Object(_foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_4__[\"onImagesLoaded\"])($images, this._prepareForOrbit.bind(this));\n      } else {\n        this._prepareForOrbit(); //hehe\n\n      }\n\n      if (this.options.bullets) {\n        this._loadBullets();\n      }\n\n      this._events();\n\n      if (this.options.autoPlay && this.$slides.length > 1) {\n        this.geoSync();\n      }\n\n      if (this.options.accessible) {\n        // allow wrapper to be focusable to enable arrow navigation\n        this.$wrapper.attr('tabindex', 0);\n      }\n    }\n    /**\n    * Creates a jQuery collection of bullets, if they are being used.\n    * @function\n    * @private\n    */\n\n  }, {\n    key: \"_loadBullets\",\n    value: function _loadBullets() {\n      this.$bullets = this.$element.find(\".\".concat(this.options.boxOfBullets)).find('button');\n    }\n    /**\n    * Sets a `timer` object on the orbit, and starts the counter for the next slide.\n    * @function\n    */\n\n  }, {\n    key: \"geoSync\",\n    value: function geoSync() {\n      var _this = this;\n\n      this.timer = new _foundation_util_timer__WEBPACK_IMPORTED_MODULE_3__[\"Timer\"](this.$element, {\n        duration: this.options.timerDelay,\n        infinite: false\n      }, function () {\n        _this.changeSlide(true);\n      });\n      this.timer.start();\n    }\n    /**\n    * Sets wrapper and slide heights for the orbit.\n    * @function\n    * @private\n    */\n\n  }, {\n    key: \"_prepareForOrbit\",\n    value: function _prepareForOrbit() {\n      var _this = this;\n\n      this._setWrapperHeight();\n    }\n    /**\n    * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.\n    * @function\n    * @private\n    * @param {Function} cb - a callback function to fire when complete.\n    */\n\n  }, {\n    key: \"_setWrapperHeight\",\n    value: function _setWrapperHeight(cb) {\n      //rewrite this to `for` loop\n      var max = 0,\n          temp,\n          counter = 0,\n          _this = this;\n\n      this.$slides.each(function () {\n        temp = this.getBoundingClientRect().height;\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-slide', counter); // hide all slides but the active one\n\n        if (!/mui/g.test(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)[0].className) && _this.$slides.filter('.is-active')[0] !== _this.$slides.eq(counter)[0]) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).css({\n            'display': 'none'\n          });\n        }\n\n        max = temp > max ? temp : max;\n        counter++;\n      });\n\n      if (counter === this.$slides.length) {\n        this.$wrapper.css({\n          'height': max\n        }); //only change the wrapper height property once.\n\n        if (cb) {\n          cb(max);\n        } //fire callback with max height dimension.\n\n      }\n    }\n    /**\n    * Sets the max-height of each slide.\n    * @function\n    * @private\n    */\n\n  }, {\n    key: \"_setSlideHeight\",\n    value: function _setSlideHeight(height) {\n      this.$slides.each(function () {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).css('max-height', height);\n      });\n    }\n    /**\n    * Adds event listeners to basically everything within the element.\n    * @function\n    * @private\n    */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this; //***************************************\n      //**Now using custom event - thanks to:**\n      //**      Yohai Ararat of Toronto      **\n      //***************************************\n      //\n\n\n      this.$element.off('.resizeme.zf.trigger').on({\n        'resizeme.zf.trigger': this._prepareForOrbit.bind(this)\n      });\n\n      if (this.$slides.length > 1) {\n        if (this.options.swipe) {\n          this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {\n            e.preventDefault();\n\n            _this.changeSlide(true);\n          }).on('swiperight.zf.orbit', function (e) {\n            e.preventDefault();\n\n            _this.changeSlide(false);\n          });\n        } //***************************************\n\n\n        if (this.options.autoPlay) {\n          this.$slides.on('click.zf.orbit', function () {\n            _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);\n\n            _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();\n          });\n\n          if (this.options.pauseOnHover) {\n            this.$element.on('mouseenter.zf.orbit', function () {\n              _this.timer.pause();\n            }).on('mouseleave.zf.orbit', function () {\n              if (!_this.$element.data('clickedOn')) {\n                _this.timer.start();\n              }\n            });\n          }\n        }\n\n        if (this.options.navButtons) {\n          var $controls = this.$element.find(\".\".concat(this.options.nextClass, \", .\").concat(this.options.prevClass));\n          $controls.attr('tabindex', 0) //also need to handle enter/return and spacebar key presses\n          .on('click.zf.orbit touchend.zf.orbit', function (e) {\n            e.preventDefault();\n\n            _this.changeSlide(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).hasClass(_this.options.nextClass));\n          });\n        }\n\n        if (this.options.bullets) {\n          this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {\n            if (/is-active/g.test(this.className)) {\n              return false;\n            } //if this is active, kick out of function.\n\n\n            var idx = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('slide'),\n                ltr = idx > _this.$slides.filter('.is-active').data('slide'),\n                $slide = _this.$slides.eq(idx);\n\n            _this.changeSlide(ltr, $slide, idx);\n          });\n        }\n\n        if (this.options.accessible) {\n          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {\n            // handle keyboard event with keyboard util\n            _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].handleKey(e, 'Orbit', {\n              next: function next() {\n                _this.changeSlide(true);\n              },\n              previous: function previous() {\n                _this.changeSlide(false);\n              },\n              handled: function handled() {\n                // if bullet is focused, make sure focus moves\n                if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).is(_this.$bullets)) {\n                  _this.$bullets.filter('.is-active').focus();\n                }\n              }\n            });\n          });\n        }\n      }\n    }\n    /**\n     * Resets Orbit so it can be reinitialized\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      // Don't do anything if there are no slides (first run)\n      if (typeof this.$slides == 'undefined') {\n        return;\n      }\n\n      if (this.$slides.length > 1) {\n        // Remove old events\n        this.$element.off('.zf.orbit').find('*').off('.zf.orbit'); // Restart timer if autoPlay is enabled\n\n        if (this.options.autoPlay) {\n          this.timer.restart();\n        } // Reset all sliddes\n\n\n        this.$slides.each(function (el) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(el).removeClass('is-active is-active is-in').removeAttr('aria-live').hide();\n        }); // Show the first slide\n\n        this.$slides.first().addClass('is-active').show(); // Triggers when the slide has finished animating\n\n        this.$element.trigger('slidechange.zf.orbit', [this.$slides.first()]); // Select first bullet if bullets are present\n\n        if (this.options.bullets) {\n          this._updateBullets(0);\n        }\n      }\n    }\n    /**\n    * Changes the current slide to a new one.\n    * @function\n    * @param {Boolean} isLTR - if true the slide moves from right to left, if false the slide moves from left to right.\n    * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.\n    * @param {Number} idx - the index of the new slide in its collection, if one chosen.\n    * @fires Orbit#slidechange\n    */\n\n  }, {\n    key: \"changeSlide\",\n    value: function changeSlide(isLTR, chosenSlide, idx) {\n      if (!this.$slides) {\n        return;\n      } // Don't freak out if we're in the middle of cleanup\n\n\n      var $curSlide = this.$slides.filter('.is-active').eq(0);\n\n      if (/mui/g.test($curSlide[0].className)) {\n        return false;\n      } //if the slide is currently animating, kick out of the function\n\n\n      var $firstSlide = this.$slides.first(),\n          $lastSlide = this.$slides.last(),\n          dirIn = isLTR ? 'Right' : 'Left',\n          dirOut = isLTR ? 'Left' : 'Right',\n          _this = this,\n          $newSlide;\n\n      if (!chosenSlide) {\n        //most of the time, this will be auto played or clicked from the navButtons.\n        $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!\n        this.options.infiniteWrap ? $curSlide.next(\".\".concat(this.options.slideClass)).length ? $curSlide.next(\".\".concat(this.options.slideClass)) : $firstSlide : $curSlide.next(\".\".concat(this.options.slideClass)) : //pick next slide if moving left to right\n        this.options.infiniteWrap ? $curSlide.prev(\".\".concat(this.options.slideClass)).length ? $curSlide.prev(\".\".concat(this.options.slideClass)) : $lastSlide : $curSlide.prev(\".\".concat(this.options.slideClass)); //pick prev slide if moving right to left\n      } else {\n        $newSlide = chosenSlide;\n      }\n\n      if ($newSlide.length) {\n        /**\n        * Triggers before the next slide starts animating in and only if a next slide has been found.\n        * @event Orbit#beforeslidechange\n        */\n        this.$element.trigger('beforeslidechange.zf.orbit', [$curSlide, $newSlide]);\n\n        if (this.options.bullets) {\n          idx = idx || this.$slides.index($newSlide); //grab index to update bullets\n\n          this._updateBullets(idx);\n        }\n\n        if (this.options.useMUI && !this.$element.is(':hidden')) {\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateIn($newSlide.addClass('is-active'), this.options[\"animInFrom\".concat(dirIn)], function () {\n            $newSlide.css({\n              'display': 'block'\n            }).attr('aria-live', 'polite');\n          });\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateOut($curSlide.removeClass('is-active'), this.options[\"animOutTo\".concat(dirOut)], function () {\n            $curSlide.removeAttr('aria-live');\n\n            if (_this.options.autoPlay && !_this.timer.isPaused) {\n              _this.timer.restart();\n            } //do stuff?\n\n          });\n        } else {\n          $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();\n          $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();\n\n          if (this.options.autoPlay && !this.timer.isPaused) {\n            this.timer.restart();\n          }\n        }\n        /**\n        * Triggers when the slide has finished animating in.\n        * @event Orbit#slidechange\n        */\n\n\n        this.$element.trigger('slidechange.zf.orbit', [$newSlide]);\n      }\n    }\n    /**\n    * Updates the active state of the bullets, if displayed.\n    * Move the descriptor of the current slide `[data-slide-active-label]` to the newly active bullet.\n    * If no `[data-slide-active-label]` is set, will move the exceeding `span` element.\n    *\n    * @function\n    * @private\n    * @param {Number} idx - the index of the current slide.\n    */\n\n  }, {\n    key: \"_updateBullets\",\n    value: function _updateBullets(idx) {\n      var $oldBullet = this.$bullets.filter('.is-active');\n      var $othersBullets = this.$bullets.not('.is-active');\n      var $newBullet = this.$bullets.eq(idx);\n      $oldBullet.removeClass('is-active').blur();\n      $newBullet.addClass('is-active'); // Find the descriptor for the current slide to move it to the new slide button\n\n      var activeStateDescriptor = $oldBullet.children('[data-slide-active-label]').last(); // If not explicitely given, search for the last \"exceeding\" span element (compared to others bullets).\n\n      if (!activeStateDescriptor.length) {\n        var spans = $oldBullet.children('span');\n        var spanCountInOthersBullets = $othersBullets.toArray().map(function (b) {\n          return jquery__WEBPACK_IMPORTED_MODULE_0___default()(b).children('span').length;\n        }); // If there is an exceeding span element, use it as current slide descriptor\n\n        if (spanCountInOthersBullets.every(function (count) {\n          return count < spans.length;\n        })) {\n          activeStateDescriptor = spans.last();\n          activeStateDescriptor.attr('data-slide-active-label', '');\n        }\n      } // Move the current slide descriptor to the new slide button\n\n\n      if (activeStateDescriptor.length) {\n        activeStateDescriptor.detach();\n        $newBullet.append(activeStateDescriptor);\n      }\n    }\n    /**\n    * Destroys the carousel and hides the element.\n    * @function\n    */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();\n    }\n  }]);\n\n  return Orbit;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_6__[\"Plugin\"]);\n\nOrbit.defaults = {\n  /**\n  * Tells the JS to look for and loadBullets.\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  bullets: true,\n\n  /**\n  * Tells the JS to apply event listeners to nav buttons\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  navButtons: true,\n\n  /**\n  * motion-ui animation class to apply\n  * @option\n   * @type {string}\n  * @default 'slide-in-right'\n  */\n  animInFromRight: 'slide-in-right',\n\n  /**\n  * motion-ui animation class to apply\n  * @option\n   * @type {string}\n  * @default 'slide-out-right'\n  */\n  animOutToRight: 'slide-out-right',\n\n  /**\n  * motion-ui animation class to apply\n  * @option\n   * @type {string}\n  * @default 'slide-in-left'\n  *\n  */\n  animInFromLeft: 'slide-in-left',\n\n  /**\n  * motion-ui animation class to apply\n  * @option\n   * @type {string}\n  * @default 'slide-out-left'\n  */\n  animOutToLeft: 'slide-out-left',\n\n  /**\n  * Allows Orbit to automatically animate on page load.\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  autoPlay: true,\n\n  /**\n  * Amount of time, in ms, between slide transitions\n  * @option\n   * @type {number}\n  * @default 5000\n  */\n  timerDelay: 5000,\n\n  /**\n  * Allows Orbit to infinitely loop through the slides\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  infiniteWrap: true,\n\n  /**\n  * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  swipe: true,\n\n  /**\n  * Allows the timing function to pause animation on hover.\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  pauseOnHover: true,\n\n  /**\n  * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  accessible: true,\n\n  /**\n  * Class applied to the container of Orbit\n  * @option\n   * @type {string}\n  * @default 'orbit-container'\n  */\n  containerClass: 'orbit-container',\n\n  /**\n  * Class applied to individual slides.\n  * @option\n   * @type {string}\n  * @default 'orbit-slide'\n  */\n  slideClass: 'orbit-slide',\n\n  /**\n  * Class applied to the bullet container. You're welcome.\n  * @option\n   * @type {string}\n  * @default 'orbit-bullets'\n  */\n  boxOfBullets: 'orbit-bullets',\n\n  /**\n  * Class applied to the `next` navigation button.\n  * @option\n   * @type {string}\n  * @default 'orbit-next'\n  */\n  nextClass: 'orbit-next',\n\n  /**\n  * Class applied to the `previous` navigation button.\n  * @option\n   * @type {string}\n  * @default 'orbit-previous'\n  */\n  prevClass: 'orbit-previous',\n\n  /**\n  * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatibility.\n  * @option\n   * @type {boolean}\n  * @default true\n  */\n  useMUI: true\n};\n\n\n//# sourceURL=webpack:///./js/foundation.orbit.js?");/***/},/***/"./js/foundation.positionable.js":/*!***************************************!*\
	  !*** ./js/foundation.positionable.js ***!
	  \***************************************/ /*! exports provided: Positionable */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Positionable\", function() { return Positionable; });\n/* harmony import */ var _foundation_util_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./foundation.util.box */ \"./js/foundation.util.box.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar POSITIONS = ['left', 'right', 'top', 'bottom'];\nvar VERTICAL_ALIGNMENTS = ['top', 'bottom', 'center'];\nvar HORIZONTAL_ALIGNMENTS = ['left', 'right', 'center'];\nvar ALIGNMENTS = {\n  'left': VERTICAL_ALIGNMENTS,\n  'right': VERTICAL_ALIGNMENTS,\n  'top': HORIZONTAL_ALIGNMENTS,\n  'bottom': HORIZONTAL_ALIGNMENTS\n};\n\nfunction nextItem(item, array) {\n  var currentIdx = array.indexOf(item);\n\n  if (currentIdx === array.length - 1) {\n    return array[0];\n  } else {\n    return array[currentIdx + 1];\n  }\n}\n\nvar Positionable =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Positionable, _Plugin);\n\n  function Positionable() {\n    _classCallCheck(this, Positionable);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Positionable).apply(this, arguments));\n  }\n\n  _createClass(Positionable, [{\n    key: \"_init\",\n\n    /**\n     * Abstract class encapsulating the tether-like explicit positioning logic\n     * including repositioning based on overlap.\n     * Expects classes to define defaults for vOffset, hOffset, position,\n     * alignment, allowOverlap, and allowBottomOverlap. They can do this by\n     * extending the defaults, or (for now recommended due to the way docs are\n     * generated) by explicitly declaring them.\n     *\n     **/\n    value: function _init() {\n      this.triedPositions = {};\n      this.position = this.options.position === 'auto' ? this._getDefaultPosition() : this.options.position;\n      this.alignment = this.options.alignment === 'auto' ? this._getDefaultAlignment() : this.options.alignment;\n      this.originalPosition = this.position;\n      this.originalAlignment = this.alignment;\n    }\n  }, {\n    key: \"_getDefaultPosition\",\n    value: function _getDefaultPosition() {\n      return 'bottom';\n    }\n  }, {\n    key: \"_getDefaultAlignment\",\n    value: function _getDefaultAlignment() {\n      switch (this.position) {\n        case 'bottom':\n        case 'top':\n          return Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"rtl\"])() ? 'right' : 'left';\n\n        case 'left':\n        case 'right':\n          return 'bottom';\n      }\n    }\n    /**\n     * Adjusts the positionable possible positions by iterating through alignments\n     * and positions.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_reposition\",\n    value: function _reposition() {\n      if (this._alignmentsExhausted(this.position)) {\n        this.position = nextItem(this.position, POSITIONS);\n        this.alignment = ALIGNMENTS[this.position][0];\n      } else {\n        this._realign();\n      }\n    }\n    /**\n     * Adjusts the dropdown pane possible positions by iterating through alignments\n     * on the current position.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_realign\",\n    value: function _realign() {\n      this._addTriedPosition(this.position, this.alignment);\n\n      this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position]);\n    }\n  }, {\n    key: \"_addTriedPosition\",\n    value: function _addTriedPosition(position, alignment) {\n      this.triedPositions[position] = this.triedPositions[position] || [];\n      this.triedPositions[position].push(alignment);\n    }\n  }, {\n    key: \"_positionsExhausted\",\n    value: function _positionsExhausted() {\n      var isExhausted = true;\n\n      for (var i = 0; i < POSITIONS.length; i++) {\n        isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);\n      }\n\n      return isExhausted;\n    }\n  }, {\n    key: \"_alignmentsExhausted\",\n    value: function _alignmentsExhausted(position) {\n      return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;\n    } // When we're trying to center, we don't want to apply offset that's going to\n    // take us just off center, so wrap around to return 0 for the appropriate\n    // offset in those alignments.  TODO: Figure out if we want to make this\n    // configurable behavior... it feels more intuitive, especially for tooltips, but\n    // it's possible someone might actually want to start from center and then nudge\n    // slightly off.\n\n  }, {\n    key: \"_getVOffset\",\n    value: function _getVOffset() {\n      return this.options.vOffset;\n    }\n  }, {\n    key: \"_getHOffset\",\n    value: function _getHOffset() {\n      return this.options.hOffset;\n    }\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition($anchor, $element, $parent) {\n      if ($anchor.attr('aria-expanded') === 'false') {\n        return false;\n      }\n\n      if (!this.options.allowOverlap) {\n        // restore original position & alignment before checking overlap\n        this.position = this.originalPosition;\n        this.alignment = this.originalAlignment;\n      }\n\n      $element.offset(_foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n\n      if (!this.options.allowOverlap) {\n        var minOverlap = 100000000; // default coordinates to how we start, in case we can't figure out better\n\n        var minCoordinates = {\n          position: this.position,\n          alignment: this.alignment\n        };\n\n        while (!this._positionsExhausted()) {\n          var overlap = _foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);\n\n          if (overlap === 0) {\n            return;\n          }\n\n          if (overlap < minOverlap) {\n            minOverlap = overlap;\n            minCoordinates = {\n              position: this.position,\n              alignment: this.alignment\n            };\n          }\n\n          this._reposition();\n\n          $element.offset(_foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n        } // If we get through the entire loop, there was no non-overlapping\n        // position available. Pick the version with least overlap.\n\n\n        this.position = minCoordinates.position;\n        this.alignment = minCoordinates.alignment;\n        $element.offset(_foundation_util_box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n      }\n    }\n  }]);\n\n  return Positionable;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n\nPositionable.defaults = {\n  /**\n   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  position: 'auto',\n\n  /**\n   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  alignment: 'auto',\n\n  /**\n   * Allow overlap of container/window. If false, dropdown positionable first\n   * try to position as defined by data-position and data-alignment, but\n   * reposition if it would cause an overflow.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  allowOverlap: false,\n\n  /**\n   * Allow overlap of only the bottom of the container. This is the most common\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\n   * screen but not otherwise influence or break out of the container.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  allowBottomOverlap: true,\n\n  /**\n   * Number of pixels the positionable should be separated vertically from anchor\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  vOffset: 0,\n\n  /**\n   * Number of pixels the positionable should be separated horizontally from anchor\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  hOffset: 0\n};\n\n\n//# sourceURL=webpack:///./js/foundation.positionable.js?");/***/},/***/"./js/foundation.responsiveAccordionTabs.js":/*!**************************************************!*\
	  !*** ./js/foundation.responsiveAccordionTabs.js ***!
	  \**************************************************/ /*! exports provided: ResponsiveAccordionTabs */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResponsiveAccordionTabs\", function() { return ResponsiveAccordionTabs; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_accordion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.accordion */ \"./js/foundation.accordion.js\");\n/* harmony import */ var _foundation_tabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.tabs */ \"./js/foundation.tabs.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n // The plugin matches the plugin classes with these plugin instances.\n\nvar MenuPlugins = {\n  tabs: {\n    cssClass: 'tabs',\n    plugin: _foundation_tabs__WEBPACK_IMPORTED_MODULE_5__[\"Tabs\"],\n    open: function open(plugin, target) {\n      return plugin.selectTab(target);\n    },\n    close: null\n    /* not supported */\n    ,\n    toggle: null\n    /* not supported */\n\n  },\n  accordion: {\n    cssClass: 'accordion',\n    plugin: _foundation_accordion__WEBPACK_IMPORTED_MODULE_4__[\"Accordion\"],\n    open: function open(plugin, target) {\n      return plugin.down(jquery__WEBPACK_IMPORTED_MODULE_0___default()(target));\n    },\n    close: function close(plugin, target) {\n      return plugin.up(jquery__WEBPACK_IMPORTED_MODULE_0___default()(target));\n    },\n    toggle: function toggle(plugin, target) {\n      return plugin.toggle(jquery__WEBPACK_IMPORTED_MODULE_0___default()(target));\n    }\n  }\n};\n/**\n * ResponsiveAccordionTabs module.\n * @module foundation.responsiveAccordionTabs\n * @requires foundation.util.motion\n * @requires foundation.accordion\n * @requires foundation.tabs\n */\n\nvar ResponsiveAccordionTabs =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ResponsiveAccordionTabs, _Plugin);\n\n  function ResponsiveAccordionTabs(element, options) {\n    var _this2;\n\n    _classCallCheck(this, ResponsiveAccordionTabs);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveAccordionTabs).call(this, element, options));\n    return _possibleConstructorReturn(_this2, _this2.options.reflow && _this2.storezfData || _assertThisInitialized(_this2));\n  }\n  /**\n   * Creates a new instance of a responsive accordion tabs.\n   * @class\n   * @name ResponsiveAccordionTabs\n   * @fires ResponsiveAccordionTabs#init\n   * @param {jQuery} element - jQuery object to make into Responsive Accordion Tabs.\n   * @param {Object} options - Overrides to the default plugin settings.\n   */\n\n\n  _createClass(ResponsiveAccordionTabs, [{\n    key: \"_setup\",\n    value: function _setup(element, options) {\n      this.$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);\n      this.$element.data('zfPluginBase', this);\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, ResponsiveAccordionTabs.defaults, this.$element.data(), options);\n      this.rules = this.$element.data('responsive-accordion-tabs');\n      this.currentMq = null;\n      this.currentRule = null;\n      this.currentPlugin = null;\n      this.className = 'ResponsiveAccordionTabs'; // ie9 back compat\n\n      if (!this.$element.attr('id')) {\n        this.$element.attr('id', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'responsiveaccordiontabs'));\n      }\n\n      this._init();\n\n      this._events();\n    }\n    /**\n     * Initializes the Menu by parsing the classes from the 'data-responsive-accordion-tabs' attribute on the element.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of \"classes\" to an object of rules\n\n\n      if (typeof this.rules === 'string') {\n        var rulesTree = {}; // Parse rules from \"classes\" pulled from data attribute\n\n        var rules = this.rules.split(' '); // Iterate through every rule found\n\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i].split('-');\n          var ruleSize = rule.length > 1 ? rule[0] : 'small';\n          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\n\n          if (MenuPlugins[rulePlugin] !== null) {\n            rulesTree[ruleSize] = MenuPlugins[rulePlugin];\n          }\n        }\n\n        this.rules = rulesTree;\n      }\n\n      this._getAllOptions();\n\n      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default.a.isEmptyObject(this.rules)) {\n        this._checkMediaQueries();\n      }\n    }\n  }, {\n    key: \"_getAllOptions\",\n    value: function _getAllOptions() {\n      //get all defaults and options\n      var _this = this;\n\n      _this.allOptions = {};\n\n      for (var key in MenuPlugins) {\n        if (MenuPlugins.hasOwnProperty(key)) {\n          var obj = MenuPlugins[key];\n\n          try {\n            var dummyPlugin = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<ul></ul>');\n            var tmpPlugin = new obj.plugin(dummyPlugin, _this.options);\n\n            for (var keyKey in tmpPlugin.options) {\n              if (tmpPlugin.options.hasOwnProperty(keyKey) && keyKey !== 'zfPlugin') {\n                var objObj = tmpPlugin.options[keyKey];\n                _this.allOptions[keyKey] = objObj;\n              }\n            }\n\n            tmpPlugin.destroy();\n          } catch (e) {}\n        }\n      }\n    }\n    /**\n     * Initializes events for the Menu.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      this._changedZfMediaQueryHandler = this._checkMediaQueries.bind(this);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._changedZfMediaQueryHandler);\n    }\n    /**\n     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_checkMediaQueries\",\n    value: function _checkMediaQueries() {\n      var matchedMq,\n          _this = this; // Iterate through each rule and find the last matching rule\n\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(this.rules, function (key) {\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(key)) {\n          matchedMq = key;\n        }\n      }); // No match? No dice\n\n      if (!matchedMq) return; // Plugin already initialized? We good\n\n      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(MenuPlugins, function (key, value) {\n        _this.$element.removeClass(value.cssClass);\n      }); // Add the CSS class for the new plugin\n\n      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin\n\n      if (this.currentPlugin) {\n        //don't know why but on nested elements data zfPlugin get's lost\n        if (!this.currentPlugin.$element.data('zfPlugin') && this.storezfData) this.currentPlugin.$element.data('zfPlugin', this.storezfData);\n        this.currentPlugin.destroy();\n      }\n\n      this._handleMarkup(this.rules[matchedMq].cssClass);\n\n      this.currentRule = this.rules[matchedMq];\n      this.currentPlugin = new this.currentRule.plugin(this.$element, this.options);\n      this.storezfData = this.currentPlugin.$element.data('zfPlugin');\n    }\n  }, {\n    key: \"_handleMarkup\",\n    value: function _handleMarkup(toSet) {\n      var _this = this,\n          fromString = 'accordion';\n\n      var $panels = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-tabs-content=' + this.$element.attr('id') + ']');\n      if ($panels.length) fromString = 'tabs';\n\n      if (fromString === toSet) {\n        return;\n      }\n\n      var tabsTitle = _this.allOptions.linkClass ? _this.allOptions.linkClass : 'tabs-title';\n      var tabsPanel = _this.allOptions.panelClass ? _this.allOptions.panelClass : 'tabs-panel';\n      this.$element.removeAttr('role');\n      var $liHeads = this.$element.children('.' + tabsTitle + ',[data-accordion-item]').removeClass(tabsTitle).removeClass('accordion-item').removeAttr('data-accordion-item');\n      var $liHeadsA = $liHeads.children('a').removeClass('accordion-title');\n\n      if (fromString === 'tabs') {\n        $panels = $panels.children('.' + tabsPanel).removeClass(tabsPanel).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby');\n        $panels.children('a').removeAttr('role').removeAttr('aria-controls').removeAttr('aria-selected');\n      } else {\n        $panels = $liHeads.children('[data-tab-content]').removeClass('accordion-content');\n      }\n\n      $panels.css({\n        display: '',\n        visibility: ''\n      });\n      $liHeads.css({\n        display: '',\n        visibility: ''\n      });\n\n      if (toSet === 'accordion') {\n        $panels.each(function (key, value) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).appendTo($liHeads.get(key)).addClass('accordion-content').attr('data-tab-content', '').removeClass('is-active').css({\n            height: ''\n          });\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-tabs-content=' + _this.$element.attr('id') + ']').after('<div id=\"tabs-placeholder-' + _this.$element.attr('id') + '\"></div>').detach();\n          $liHeads.addClass('accordion-item').attr('data-accordion-item', '');\n          $liHeadsA.addClass('accordion-title');\n        });\n      } else if (toSet === 'tabs') {\n        var $tabsContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-tabs-content=' + _this.$element.attr('id') + ']');\n        var $placeholder = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#tabs-placeholder-' + _this.$element.attr('id'));\n\n        if ($placeholder.length) {\n          $tabsContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div class=\"tabs-content\"></div>').insertAfter($placeholder).attr('data-tabs-content', _this.$element.attr('id'));\n          $placeholder.remove();\n        } else {\n          $tabsContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div class=\"tabs-content\"></div>').insertAfter(_this.$element).attr('data-tabs-content', _this.$element.attr('id'));\n        }\n\n        $panels.each(function (key, value) {\n          var tempValue = jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).appendTo($tabsContent).addClass(tabsPanel);\n          var hash = $liHeadsA.get(key).hash.slice(1);\n          var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).attr('id') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'accordion');\n\n          if (hash !== id) {\n            if (hash !== '') {\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).attr('id', hash);\n            } else {\n              hash = id;\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()(value).attr('id', hash);\n              jquery__WEBPACK_IMPORTED_MODULE_0___default()($liHeadsA.get(key)).attr('href', jquery__WEBPACK_IMPORTED_MODULE_0___default()($liHeadsA.get(key)).attr('href').replace('#', '') + '#' + hash);\n            }\n          }\n\n          var isActive = jquery__WEBPACK_IMPORTED_MODULE_0___default()($liHeads.get(key)).hasClass('is-active');\n\n          if (isActive) {\n            tempValue.addClass('is-active');\n          }\n        });\n        $liHeads.addClass(tabsTitle);\n      }\n\n      ;\n    }\n    /**\n     * Opens the plugin pane defined by `target`.\n     * @param {jQuery | String} target - jQuery object or string of the id of the pane to open.\n     * @see Accordion.down\n     * @see Tabs.selectTab\n     * @function\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(_target) {\n      if (this.currentRule && typeof this.currentRule.open === 'function') {\n        var _this$currentRule;\n\n        return (_this$currentRule = this.currentRule).open.apply(_this$currentRule, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));\n      }\n    }\n    /**\n     * Closes the plugin pane defined by `target`. Not availaible for Tabs.\n     * @param {jQuery | String} target - jQuery object or string of the id of the pane to close.\n     * @see Accordion.up\n     * @function\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(_target) {\n      if (this.currentRule && typeof this.currentRule.close === 'function') {\n        var _this$currentRule2;\n\n        return (_this$currentRule2 = this.currentRule).close.apply(_this$currentRule2, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));\n      }\n    }\n    /**\n     * Toggles the plugin pane defined by `target`. Not availaible for Tabs.\n     * @param {jQuery | String} target - jQuery object or string of the id of the pane to toggle.\n     * @see Accordion.toggle\n     * @function\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(_target) {\n      if (this.currentRule && typeof this.currentRule.toggle === 'function') {\n        var _this$currentRule3;\n\n        return (_this$currentRule3 = this.currentRule).toggle.apply(_this$currentRule3, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));\n      }\n    }\n    /**\n     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (this.currentPlugin) this.currentPlugin.destroy();\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('changed.zf.mediaquery', this._changedZfMediaQueryHandler);\n    }\n  }]);\n\n  return ResponsiveAccordionTabs;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\"Plugin\"]);\n\nResponsiveAccordionTabs.defaults = {};\n\n\n//# sourceURL=webpack:///./js/foundation.responsiveAccordionTabs.js?");/***/},/***/"./js/foundation.responsiveMenu.js":/*!*****************************************!*\
	  !*** ./js/foundation.responsiveMenu.js ***!
	  \*****************************************/ /*! exports provided: ResponsiveMenu */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResponsiveMenu\", function() { return ResponsiveMenu; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.dropdownMenu */ \"./js/foundation.dropdownMenu.js\");\n/* harmony import */ var _foundation_drilldown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.drilldown */ \"./js/foundation.drilldown.js\");\n/* harmony import */ var _foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.accordionMenu */ \"./js/foundation.accordionMenu.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\nvar MenuPlugins = {\n  dropdown: {\n    cssClass: 'dropdown',\n    plugin: _foundation_dropdownMenu__WEBPACK_IMPORTED_MODULE_4__[\"DropdownMenu\"]\n  },\n  drilldown: {\n    cssClass: 'drilldown',\n    plugin: _foundation_drilldown__WEBPACK_IMPORTED_MODULE_5__[\"Drilldown\"]\n  },\n  accordion: {\n    cssClass: 'accordion-menu',\n    plugin: _foundation_accordionMenu__WEBPACK_IMPORTED_MODULE_6__[\"AccordionMenu\"]\n  }\n}; // import \"foundation.util.triggers.js\";\n\n/**\n * ResponsiveMenu module.\n * @module foundation.responsiveMenu\n * @requires foundation.util.triggers\n * @requires foundation.util.mediaQuery\n */\n\nvar ResponsiveMenu =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ResponsiveMenu, _Plugin);\n\n  function ResponsiveMenu() {\n    _classCallCheck(this, ResponsiveMenu);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveMenu).apply(this, arguments));\n  }\n\n  _createClass(ResponsiveMenu, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of a responsive menu.\n     * @class\n     * @name ResponsiveMenu\n     * @fires ResponsiveMenu#init\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);\n      this.rules = this.$element.data('responsive-menu');\n      this.currentMq = null;\n      this.currentPlugin = null;\n      this.className = 'ResponsiveMenu'; // ie9 back compat\n\n      this._init();\n\n      this._events();\n    }\n    /**\n     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of \"classes\" to an object of rules\n\n\n      if (typeof this.rules === 'string') {\n        var rulesTree = {}; // Parse rules from \"classes\" pulled from data attribute\n\n        var rules = this.rules.split(' '); // Iterate through every rule found\n\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i].split('-');\n          var ruleSize = rule.length > 1 ? rule[0] : 'small';\n          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\n\n          if (MenuPlugins[rulePlugin] !== null) {\n            rulesTree[ruleSize] = MenuPlugins[rulePlugin];\n          }\n        }\n\n        this.rules = rulesTree;\n      }\n\n      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default.a.isEmptyObject(this.rules)) {\n        this._checkMediaQueries();\n      } // Add data-mutate since children may need it.\n\n\n      this.$element.attr('data-mutate', this.$element.attr('data-mutate') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'responsive-menu'));\n    }\n    /**\n     * Initializes events for the Menu.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', function () {\n        _this._checkMediaQueries();\n      }); // $(window).on('resize.zf.ResponsiveMenu', function() {\n      //   _this._checkMediaQueries();\n      // });\n    }\n    /**\n     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_checkMediaQueries\",\n    value: function _checkMediaQueries() {\n      var matchedMq,\n          _this = this; // Iterate through each rule and find the last matching rule\n\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(this.rules, function (key) {\n        if (_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(key)) {\n          matchedMq = key;\n        }\n      }); // No match? No dice\n\n      if (!matchedMq) return; // Plugin already initialized? We good\n\n      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes\n\n      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(MenuPlugins, function (key, value) {\n        _this.$element.removeClass(value.cssClass);\n      }); // Add the CSS class for the new plugin\n\n      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin\n\n      if (this.currentPlugin) this.currentPlugin.destroy();\n      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\n    }\n    /**\n     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.currentPlugin.destroy();\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('.zf.ResponsiveMenu');\n    }\n  }]);\n\n  return ResponsiveMenu;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\"Plugin\"]);\n\nResponsiveMenu.defaults = {};\n\n\n//# sourceURL=webpack:///./js/foundation.responsiveMenu.js?");/***/},/***/"./js/foundation.responsiveToggle.js":/*!*******************************************!*\
	  !*** ./js/foundation.responsiveToggle.js ***!
	  \*******************************************/ /*! exports provided: ResponsiveToggle */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResponsiveToggle\", function() { return ResponsiveToggle; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n/**\n * ResponsiveToggle module.\n * @module foundation.responsiveToggle\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.motion\n */\n\nvar ResponsiveToggle =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(ResponsiveToggle, _Plugin);\n\n  function ResponsiveToggle() {\n    _classCallCheck(this, ResponsiveToggle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveToggle).apply(this, arguments));\n  }\n\n  _createClass(ResponsiveToggle, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Tab Bar.\n     * @class\n     * @name ResponsiveToggle\n     * @fires ResponsiveToggle#init\n     * @param {jQuery} element - jQuery object to attach tab bar functionality to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);\n      this.className = 'ResponsiveToggle'; // ie9 back compat\n\n      this._init();\n\n      this._events();\n    }\n    /**\n     * Initializes the tab bar by finding the target element, toggling element, and running update().\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"]._init();\n\n      var targetID = this.$element.data('responsive-toggle');\n\n      if (!targetID) {\n        console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');\n      }\n\n      this.$targetMenu = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(targetID));\n      this.$toggler = this.$element.find('[data-toggle]').filter(function () {\n        var target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('toggle');\n        return target === targetID || target === \"\";\n      });\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, this.options, this.$targetMenu.data()); // If they were set, parse the animation classes\n\n      if (this.options.animate) {\n        var input = this.options.animate.split(' ');\n        this.animationIn = input[0];\n        this.animationOut = input[1] || null;\n      }\n\n      this._update();\n    }\n    /**\n     * Adds necessary event handlers for the tab bar to work.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      this._updateMqHandler = this._update.bind(this);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._updateMqHandler);\n      this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));\n    }\n    /**\n     * Checks the current media query to determine if the tab bar should be visible or hidden.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      // Mobile\n      if (!_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(this.options.hideFor)) {\n        this.$element.show();\n        this.$targetMenu.hide();\n      } // Desktop\n      else {\n          this.$element.hide();\n          this.$targetMenu.show();\n        }\n    }\n    /**\n     * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.\n     * @function\n     * @fires ResponsiveToggle#toggled\n     */\n\n  }, {\n    key: \"toggleMenu\",\n    value: function toggleMenu() {\n      var _this2 = this;\n\n      if (!_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_1__[\"MediaQuery\"].atLeast(this.options.hideFor)) {\n        /**\n         * Fires when the element attached to the tab bar toggles.\n         * @event ResponsiveToggle#toggled\n         */\n        if (this.options.animate) {\n          if (this.$targetMenu.is(':hidden')) {\n            _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateIn(this.$targetMenu, this.animationIn, function () {\n              _this2.$element.trigger('toggled.zf.responsiveToggle');\n\n              _this2.$targetMenu.find('[data-mutate]').triggerHandler('mutateme.zf.trigger');\n            });\n          } else {\n            _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateOut(this.$targetMenu, this.animationOut, function () {\n              _this2.$element.trigger('toggled.zf.responsiveToggle');\n            });\n          }\n        } else {\n          this.$targetMenu.toggle(0);\n          this.$targetMenu.find('[data-mutate]').trigger('mutateme.zf.trigger');\n          this.$element.trigger('toggled.zf.responsiveToggle');\n        }\n      }\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.off('.zf.responsiveToggle');\n      this.$toggler.off('.zf.responsiveToggle');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('changed.zf.mediaquery', this._updateMqHandler);\n    }\n  }]);\n\n  return ResponsiveToggle;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_3__[\"Plugin\"]);\n\nResponsiveToggle.defaults = {\n  /**\n   * The breakpoint after which the menu is always shown, and the tab bar is hidden.\n   * @option\n   * @type {string}\n   * @default 'medium'\n   */\n  hideFor: 'medium',\n\n  /**\n   * To decide if the toggle should be animated or not.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  animate: false\n};\n\n\n//# sourceURL=webpack:///./js/foundation.responsiveToggle.js?");/***/},/***/"./js/foundation.reveal.js":/*!*********************************!*\
	  !*** ./js/foundation.reveal.js ***!
	  \*********************************/ /*! exports provided: Reveal */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Reveal\", function() { return Reveal; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./foundation.util.touch */ \"./js/foundation.util.touch.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n/**\n * Reveal module.\n * @module foundation.reveal\n * @requires foundation.util.keyboard\n * @requires foundation.util.touch\n * @requires foundation.util.triggers\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.motion if using animations\n */\n\nvar Reveal =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Reveal, _Plugin);\n\n  function Reveal() {\n    _classCallCheck(this, Reveal);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Reveal).apply(this, arguments));\n  }\n\n  _createClass(Reveal, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Reveal.\n     * @class\n     * @name Reveal\n     * @param {jQuery} element - jQuery object to use for the modal.\n     * @param {Object} options - optional parameters.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Reveal.defaults, this.$element.data(), options);\n      this.className = 'Reveal'; // ie9 back compat\n\n      this._init(); // Touch and Triggers init are idempotent, just need to make sure they are initialized\n\n\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_7__[\"Touch\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].register('Reveal', {\n        'ESCAPE': 'close'\n      });\n    }\n    /**\n     * Initializes the modal by adding the overlay and close buttons, (if selected).\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var _this2 = this;\n\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__[\"MediaQuery\"]._init();\n\n      this.id = this.$element.attr('id');\n      this.isActive = false;\n      this.cached = {\n        mq: _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_4__[\"MediaQuery\"].current\n      };\n      this.$anchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open=\\\"\".concat(this.id, \"\\\"]\")).length ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open=\\\"\".concat(this.id, \"\\\"]\")) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-toggle=\\\"\".concat(this.id, \"\\\"]\"));\n      this.$anchor.attr({\n        'aria-controls': this.id,\n        'aria-haspopup': true,\n        'tabindex': 0\n      });\n\n      if (this.options.fullScreen || this.$element.hasClass('full')) {\n        this.options.fullScreen = true;\n        this.options.overlay = false;\n      }\n\n      if (this.options.overlay && !this.$overlay) {\n        this.$overlay = this._makeOverlay(this.id);\n      }\n\n      this.$element.attr({\n        'role': 'dialog',\n        'aria-hidden': true,\n        'data-yeti-box': this.id,\n        'data-resize': this.id\n      });\n\n      if (this.$overlay) {\n        this.$element.detach().appendTo(this.$overlay);\n      } else {\n        this.$element.detach().appendTo(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.appendTo));\n        this.$element.addClass('without-overlay');\n      }\n\n      this._events();\n\n      if (this.options.deepLink && window.location.hash === \"#\".concat(this.id)) {\n        this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"onLoad\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\n          return _this2.open();\n        });\n      }\n    }\n    /**\n     * Creates an overlay div to display behind the modal.\n     * @private\n     */\n\n  }, {\n    key: \"_makeOverlay\",\n    value: function _makeOverlay() {\n      var additionalOverlayClasses = '';\n\n      if (this.options.additionalOverlayClasses) {\n        additionalOverlayClasses = ' ' + this.options.additionalOverlayClasses;\n      }\n\n      return jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div></div>').addClass('reveal-overlay' + additionalOverlayClasses).appendTo(this.options.appendTo);\n    }\n    /**\n     * Updates position of modal\n     * TODO:  Figure out if we actually need to cache these values or if it doesn't matter\n     * @private\n     */\n\n  }, {\n    key: \"_updatePosition\",\n    value: function _updatePosition() {\n      var width = this.$element.outerWidth();\n      var outerWidth = jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).width();\n      var height = this.$element.outerHeight();\n      var outerHeight = jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height();\n      var left,\n          top = null;\n\n      if (this.options.hOffset === 'auto') {\n        left = parseInt((outerWidth - width) / 2, 10);\n      } else {\n        left = parseInt(this.options.hOffset, 10);\n      }\n\n      if (this.options.vOffset === 'auto') {\n        if (height > outerHeight) {\n          top = parseInt(Math.min(100, outerHeight / 10), 10);\n        } else {\n          top = parseInt((outerHeight - height) / 4, 10);\n        }\n      } else if (this.options.vOffset !== null) {\n        top = parseInt(this.options.vOffset, 10);\n      }\n\n      if (top !== null) {\n        this.$element.css({\n          top: top + 'px'\n        });\n      } // only worry about left if we don't have an overlay or we have a horizontal offset,\n      // otherwise we're perfectly in the middle\n\n\n      if (!this.$overlay || this.options.hOffset !== 'auto') {\n        this.$element.css({\n          left: left + 'px'\n        });\n        this.$element.css({\n          margin: '0px'\n        });\n      }\n    }\n    /**\n     * Adds event handlers for the modal.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this3 = this;\n\n      var _this = this;\n\n      this.$element.on({\n        'open.zf.trigger': this.open.bind(this),\n        'close.zf.trigger': function closeZfTrigger(event, $element) {\n          if (event.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).parents('[data-closable]')[0] === $element) {\n            // only close reveal when it's explicitly called\n            return _this3.close.apply(_this3);\n          }\n        },\n        'toggle.zf.trigger': this.toggle.bind(this),\n        'resizeme.zf.trigger': function resizemeZfTrigger() {\n          _this._updatePosition();\n        }\n      });\n\n      if (this.options.closeOnClick && this.options.overlay) {\n        this.$overlay.off('.zf.reveal').on('click.zf.dropdown tap.zf.dropdown', function (e) {\n          if (e.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(_this.$element[0], e.target) || !jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(document, e.target)) {\n            return;\n          }\n\n          _this.close();\n        });\n      }\n\n      if (this.options.deepLink) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(\"hashchange.zf.reveal:\".concat(this.id), this._handleState.bind(this));\n      }\n    }\n    /**\n     * Handles modal methods on back/forward button clicks or any other event that triggers hashchange.\n     * @private\n     */\n\n  }, {\n    key: \"_handleState\",\n    value: function _handleState(e) {\n      if (window.location.hash === '#' + this.id && !this.isActive) {\n        this.open();\n      } else {\n        this.close();\n      }\n    }\n    /**\n    * Disables the scroll when Reveal is shown to prevent the background from shifting\n    * @param {number} scrollTop - Scroll to visually apply, window current scroll by default\n    */\n\n  }, {\n    key: \"_disableScroll\",\n    value: function _disableScroll(scrollTop) {\n      scrollTop = scrollTop || jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop();\n\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).height() > jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height()) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"html\").css(\"top\", -scrollTop);\n      }\n    }\n    /**\n    * Reenables the scroll when Reveal closes\n    * @param {number} scrollTop - Scroll to restore, html \"top\" property by default (as set by `_disableScroll`)\n    */\n\n  }, {\n    key: \"_enableScroll\",\n    value: function _enableScroll(scrollTop) {\n      scrollTop = scrollTop || parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"html\").css(\"top\"));\n\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).height() > jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height()) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"html\").css(\"top\", \"\");\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop(-scrollTop);\n      }\n    }\n    /**\n     * Opens the modal controlled by `this.$anchor`, and closes all others by default.\n     * @function\n     * @fires Reveal#closeme\n     * @fires Reveal#open\n     */\n\n  }, {\n    key: \"open\",\n    value: function open() {\n      var _this4 = this;\n\n      // either update or replace browser history\n      var hash = \"#\".concat(this.id);\n\n      if (this.options.deepLink && window.location.hash !== hash) {\n        if (window.history.pushState) {\n          if (this.options.updateHistory) {\n            window.history.pushState({}, '', hash);\n          } else {\n            window.history.replaceState({}, '', hash);\n          }\n        } else {\n          window.location.hash = hash;\n        }\n      } // Remember anchor that opened it to set focus back later, have general anchors as fallback\n\n\n      this.$activeAnchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.activeElement).is(this.$anchor) ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.activeElement) : this.$anchor;\n      this.isActive = true; // Make elements invisible, but remove display: none so we can get size and positioning\n\n      this.$element.css({\n        'visibility': 'hidden'\n      }).show().scrollTop(0);\n\n      if (this.options.overlay) {\n        this.$overlay.css({\n          'visibility': 'hidden'\n        }).show();\n      }\n\n      this._updatePosition();\n\n      this.$element.hide().css({\n        'visibility': ''\n      });\n\n      if (this.$overlay) {\n        this.$overlay.css({\n          'visibility': ''\n        }).hide();\n\n        if (this.$element.hasClass('fast')) {\n          this.$overlay.addClass('fast');\n        } else if (this.$element.hasClass('slow')) {\n          this.$overlay.addClass('slow');\n        }\n      }\n\n      if (!this.options.multipleOpened) {\n        /**\n         * Fires immediately before the modal opens.\n         * Closes any other modals that are currently open\n         * @event Reveal#closeme\n         */\n        this.$element.trigger('closeme.zf.reveal', this.id);\n      }\n\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reveal:visible').length === 0) {\n        this._disableScroll();\n      }\n\n      var _this = this; // Motion UI method of reveal\n\n\n      if (this.options.animationIn) {\n        var afterAnimation = function afterAnimation() {\n          _this.$element.attr({\n            'aria-hidden': false,\n            'tabindex': -1\n          }).focus();\n\n          _this._addGlobalClasses();\n\n          _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].trapFocus(_this.$element);\n        };\n\n        if (this.options.overlay) {\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_5__[\"Motion\"].animateIn(this.$overlay, 'fade-in');\n        }\n\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_5__[\"Motion\"].animateIn(this.$element, this.options.animationIn, function () {\n          if (_this4.$element) {\n            // protect against object having been removed\n            _this4.focusableElements = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].findFocusable(_this4.$element);\n            afterAnimation();\n          }\n        });\n      } // jQuery method of reveal\n      else {\n          if (this.options.overlay) {\n            this.$overlay.show(0);\n          }\n\n          this.$element.show(this.options.showDelay);\n        } // handle accessibility\n\n\n      this.$element.attr({\n        'aria-hidden': false,\n        'tabindex': -1\n      }).focus();\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].trapFocus(this.$element);\n\n      this._addGlobalClasses();\n\n      this._addGlobalListeners();\n      /**\n       * Fires when the modal has successfully opened.\n       * @event Reveal#open\n       */\n\n\n      this.$element.trigger('open.zf.reveal');\n    }\n    /**\n     * Adds classes and listeners on document required by open modals.\n     *\n     * The following classes are added and updated:\n     * - `.is-reveal-open` - Prevents the scroll on document\n     * - `.zf-has-scroll`  - Displays a disabled scrollbar on document if required like if the\n     *                       scroll was not disabled. This prevent a \"shift\" of the page content due\n     *                       the scrollbar disappearing when the modal opens.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addGlobalClasses\",\n    value: function _addGlobalClasses() {\n      var updateScrollbarClass = function updateScrollbarClass() {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').toggleClass('zf-has-scroll', !!(jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).height() > jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).height()));\n      };\n\n      this.$element.on('resizeme.zf.trigger.revealScrollbarListener', function () {\n        return updateScrollbarClass();\n      });\n      updateScrollbarClass();\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').addClass('is-reveal-open');\n    }\n    /**\n     * Removes classes and listeners on document that were required by open modals.\n     * @private\n     */\n\n  }, {\n    key: \"_removeGlobalClasses\",\n    value: function _removeGlobalClasses() {\n      this.$element.off('resizeme.zf.trigger.revealScrollbarListener');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').removeClass('is-reveal-open');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html').removeClass('zf-has-scroll');\n    }\n    /**\n     * Adds extra event handlers for the body and window if necessary.\n     * @private\n     */\n\n  }, {\n    key: \"_addGlobalListeners\",\n    value: function _addGlobalListeners() {\n      var _this = this;\n\n      if (!this.$element) {\n        return;\n      } // If we're in the middle of cleanup, don't freak out\n\n\n      this.focusableElements = _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].findFocusable(this.$element);\n\n      if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').on('click.zf.dropdown tap.zf.dropdown', function (e) {\n          if (e.target === _this.$element[0] || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(_this.$element[0], e.target) || !jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(document, e.target)) {\n            return;\n          }\n\n          _this.close();\n        });\n      }\n\n      if (this.options.closeOnEsc) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('keydown.zf.reveal', function (e) {\n          _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].handleKey(e, 'Reveal', {\n            close: function close() {\n              if (_this.options.closeOnEsc) {\n                _this.close();\n              }\n            }\n          });\n        });\n      }\n    }\n    /**\n     * Closes the modal.\n     * @function\n     * @fires Reveal#closed\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (!this.isActive || !this.$element.is(':visible')) {\n        return false;\n      }\n\n      var _this = this; // Motion UI method of hiding\n\n\n      if (this.options.animationOut) {\n        if (this.options.overlay) {\n          _foundation_util_motion__WEBPACK_IMPORTED_MODULE_5__[\"Motion\"].animateOut(this.$overlay, 'fade-out');\n        }\n\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_5__[\"Motion\"].animateOut(this.$element, this.options.animationOut, finishUp);\n      } // jQuery method of hiding\n      else {\n          this.$element.hide(this.options.hideDelay);\n\n          if (this.options.overlay) {\n            this.$overlay.hide(0, finishUp);\n          } else {\n            finishUp();\n          }\n        } // Conditionals to remove extra event listeners added on open\n\n\n      if (this.options.closeOnEsc) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('keydown.zf.reveal');\n      }\n\n      if (!this.options.overlay && this.options.closeOnClick) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').off('click.zf.dropdown tap.zf.dropdown');\n      }\n\n      this.$element.off('keydown.zf.reveal');\n\n      function finishUp() {\n        // Get the current top before the modal is closed and restore the scroll after.\n        // TODO: use component properties instead of HTML properties\n        // See https://github.com/foundation/foundation-sites/pull/10786\n        var scrollTop = parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"html\").css(\"top\"));\n\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reveal:visible').length === 0) {\n          _this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal\n\n        }\n\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].releaseFocus(_this.$element);\n\n        _this.$element.attr('aria-hidden', true);\n\n        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reveal:visible').length === 0) {\n          _this._enableScroll(scrollTop);\n        }\n        /**\n        * Fires when the modal is done closing.\n        * @event Reveal#closed\n        */\n\n\n        _this.$element.trigger('closed.zf.reveal');\n      }\n      /**\n      * Resets the modal content\n      * This prevents a running video to keep going in the background\n      */\n\n\n      if (this.options.resetOnClose) {\n        this.$element.html(this.$element.html());\n      }\n\n      this.isActive = false; // If deepLink and we did not switched to an other modal...\n\n      if (_this.options.deepLink && window.location.hash === \"#\".concat(this.id)) {\n        // Remove the history hash\n        if (window.history.replaceState) {\n          var urlWithoutHash = window.location.pathname + window.location.search;\n\n          if (this.options.updateHistory) {\n            window.history.pushState({}, '', urlWithoutHash); // remove the hash\n          } else {\n            window.history.replaceState('', document.title, urlWithoutHash);\n          }\n        } else {\n          window.location.hash = '';\n        }\n      }\n\n      this.$activeAnchor.focus();\n    }\n    /**\n     * Toggles the open/closed state of a modal.\n     * @function\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (this.isActive) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n  }, {\n    key: \"_destroy\",\n\n    /**\n     * Destroys an instance of a modal.\n     * @function\n     */\n    value: function _destroy() {\n      if (this.options.overlay) {\n        this.$element.appendTo(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.appendTo)); // move $element outside of $overlay to prevent error unregisterPlugin()\n\n        this.$overlay.hide().off().remove();\n      }\n\n      this.$element.hide().off();\n      this.$anchor.off('.zf');\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(\".zf.reveal:\".concat(this.id));\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\n\n      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()('.reveal:visible').length === 0) {\n        this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal\n\n      }\n    }\n  }]);\n\n  return Reveal;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n\nReveal.defaults = {\n  /**\n   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  animationIn: '',\n\n  /**\n   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  animationOut: '',\n\n  /**\n   * Time, in ms, to delay the opening of a modal after a click if no animation used.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  showDelay: 0,\n\n  /**\n   * Time, in ms, to delay the closing of a modal after a click if no animation used.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  hideDelay: 0,\n\n  /**\n   * Allows a click on the body/overlay to close the modal.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClick: true,\n\n  /**\n   * Allows the modal to close if the user presses the `ESCAPE` key.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnEsc: true,\n\n  /**\n   * If true, allows multiple modals to be displayed at once.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  multipleOpened: false,\n\n  /**\n   * Distance, in pixels, the modal should push down from the top of the screen.\n   * @option\n   * @type {number|string}\n   * @default auto\n   */\n  vOffset: 'auto',\n\n  /**\n   * Distance, in pixels, the modal should push in from the side of the screen.\n   * @option\n   * @type {number|string}\n   * @default auto\n   */\n  hOffset: 'auto',\n\n  /**\n   * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  fullScreen: false,\n\n  /**\n   * Allows the modal to generate an overlay div, which will cover the view when modal opens.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  overlay: true,\n\n  /**\n   * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  resetOnClose: false,\n\n  /**\n   * Link the location hash to the modal.\n   * Set the location hash when the modal is opened/closed, and open/close the modal when the location changes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  deepLink: false,\n\n  /**\n   * If `deepLink` is enabled, update the browser history with the open modal\n   * @option\n   * @default false\n   */\n  updateHistory: false,\n\n  /**\n  * Allows the modal to append to custom div.\n  * @option\n  * @type {string}\n  * @default \"body\"\n  */\n  appendTo: \"body\",\n\n  /**\n   * Allows adding additional class names to the reveal overlay.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  additionalOverlayClasses: ''\n};\n\n\n//# sourceURL=webpack:///./js/foundation.reveal.js?");/***/},/***/"./js/foundation.slider.js":/*!*********************************!*\
	  !*** ./js/foundation.slider.js ***!
	  \*********************************/ /*! exports provided: Slider */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Slider\", function() { return Slider; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_util_touch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./foundation.util.touch */ \"./js/foundation.util.touch.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n/**\n * Slider module.\n * @module foundation.slider\n * @requires foundation.util.motion\n * @requires foundation.util.triggers\n * @requires foundation.util.keyboard\n * @requires foundation.util.touch\n */\n\nvar Slider =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Slider, _Plugin);\n\n  function Slider() {\n    _classCallCheck(this, Slider);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Slider).apply(this, arguments));\n  }\n\n  _createClass(Slider, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of a slider control.\n     * @class\n     * @name Slider\n     * @param {jQuery} element - jQuery object to make into a slider control.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Slider.defaults, this.$element.data(), options);\n      this.className = 'Slider'; // ie9 back compat\n      // Touch and Triggers inits are idempotent, we just need to make sure it's initialied.\n\n      _foundation_util_touch__WEBPACK_IMPORTED_MODULE_5__[\"Touch\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_6__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].register('Slider', {\n        'ltr': {\n          'ARROW_RIGHT': 'increase',\n          'ARROW_UP': 'increase',\n          'ARROW_DOWN': 'decrease',\n          'ARROW_LEFT': 'decrease',\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\n          'SHIFT_ARROW_UP': 'increase_fast',\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\n          'SHIFT_ARROW_LEFT': 'decrease_fast',\n          'HOME': 'min',\n          'END': 'max'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'increase',\n          'ARROW_RIGHT': 'decrease',\n          'SHIFT_ARROW_LEFT': 'increase_fast',\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\n        }\n      });\n    }\n    /**\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      this.inputs = this.$element.find('input');\n      this.handles = this.$element.find('[data-slider-handle]');\n      this.$handle = this.handles.eq(0);\n      this.$input = this.inputs.length ? this.inputs.eq(0) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(this.$handle.attr('aria-controls')));\n      this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\n\n      var _this = this;\n\n      if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\n        this.options.disabled = true;\n        this.$element.addClass(this.options.disabledClass);\n      }\n\n      if (!this.inputs.length) {\n        this.inputs = jquery__WEBPACK_IMPORTED_MODULE_0___default()().add(this.$input);\n        this.options.binding = true;\n      }\n\n      this._setInitAttr(0);\n\n      if (this.handles[1]) {\n        this.options.doubleSided = true;\n        this.$handle2 = this.handles.eq(1);\n        this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(this.$handle2.attr('aria-controls')));\n\n        if (!this.inputs[1]) {\n          this.inputs = this.inputs.add(this.$input2);\n        } // this.$handle.triggerHandler('click.zf.slider');\n\n\n        this._setInitAttr(1);\n      } // Set handle positions\n\n\n      this.setHandles();\n\n      this._events();\n    }\n  }, {\n    key: \"setHandles\",\n    value: function setHandles() {\n      var _this2 = this;\n\n      if (this.handles[1]) {\n        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), function () {\n          _this2._setHandlePos(_this2.$handle2, _this2.inputs.eq(1).val());\n        });\n      } else {\n        this._setHandlePos(this.$handle, this.inputs.eq(0).val());\n      }\n    }\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      this.setHandles();\n    }\n    /**\n    * @function\n    * @private\n    * @param {Number} value - floating point (the value) to be transformed using to a relative position on the slider (the inverse of _value)\n    */\n\n  }, {\n    key: \"_pctOfBar\",\n    value: function _pctOfBar(value) {\n      var pctOfBar = percent(value - this.options.start, this.options.end - this.options.start);\n\n      switch (this.options.positionValueFunction) {\n        case \"pow\":\n          pctOfBar = this._logTransform(pctOfBar);\n          break;\n\n        case \"log\":\n          pctOfBar = this._powTransform(pctOfBar);\n          break;\n      }\n\n      return pctOfBar.toFixed(2);\n    }\n    /**\n    * @function\n    * @private\n    * @param {Number} pctOfBar - floating point, the relative position of the slider (typically between 0-1) to be transformed to a value\n    */\n\n  }, {\n    key: \"_value\",\n    value: function _value(pctOfBar) {\n      switch (this.options.positionValueFunction) {\n        case \"pow\":\n          pctOfBar = this._powTransform(pctOfBar);\n          break;\n\n        case \"log\":\n          pctOfBar = this._logTransform(pctOfBar);\n          break;\n      }\n\n      var value;\n\n      if (this.options.vertical) {\n        // linear interpolation which is working with negative values for start\n        // https://math.stackexchange.com/a/1019084\n        value = parseFloat(this.options.end) + pctOfBar * (this.options.start - this.options.end);\n      } else {\n        value = (this.options.end - this.options.start) * pctOfBar + parseFloat(this.options.start);\n      }\n\n      return value;\n    }\n    /**\n    * @function\n    * @private\n    * @param {Number} value - floating point (typically between 0-1) to be transformed using the log function\n    */\n\n  }, {\n    key: \"_logTransform\",\n    value: function _logTransform(value) {\n      return baseLog(this.options.nonLinearBase, value * (this.options.nonLinearBase - 1) + 1);\n    }\n    /**\n    * @function\n    * @private\n    * @param {Number} value - floating point (typically between 0-1) to be transformed using the power function\n    */\n\n  }, {\n    key: \"_powTransform\",\n    value: function _powTransform(value) {\n      return (Math.pow(this.options.nonLinearBase, value) - 1) / (this.options.nonLinearBase - 1);\n    }\n    /**\n     * Sets the position of the selected handle and fill bar.\n     * @function\n     * @private\n     * @param {jQuery} $hndl - the selected handle to move.\n     * @param {Number} location - floating point between the start and end values of the slider bar.\n     * @param {Function} cb - callback function to fire on completion.\n     * @fires Slider#moved\n     * @fires Slider#changed\n     */\n\n  }, {\n    key: \"_setHandlePos\",\n    value: function _setHandlePos($hndl, location, cb) {\n      // don't move if the slider has been disabled since its initialization\n      if (this.$element.hasClass(this.options.disabledClass)) {\n        return;\n      } //might need to alter that slightly for bars that will have odd number selections.\n\n\n      location = parseFloat(location); //on input change events, convert string to number...grumble.\n      // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\n\n      if (location < this.options.start) {\n        location = this.options.start;\n      } else if (location > this.options.end) {\n        location = this.options.end;\n      }\n\n      var isDbl = this.options.doubleSided;\n\n      if (isDbl) {\n        //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\n        if (this.handles.index($hndl) === 0) {\n          var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\n          location = location >= h2Val ? h2Val - this.options.step : location;\n        } else {\n          var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\n          location = location <= h1Val ? h1Val + this.options.step : location;\n        }\n      }\n\n      var _this = this,\n          vert = this.options.vertical,\n          hOrW = vert ? 'height' : 'width',\n          lOrT = vert ? 'top' : 'left',\n          handleDim = $hndl[0].getBoundingClientRect()[hOrW],\n          elemDim = this.$element[0].getBoundingClientRect()[hOrW],\n          //percentage of bar min/max value based on click or drag point\n      pctOfBar = this._pctOfBar(location),\n          //number of actual pixels to shift the handle, based on the percentage obtained above\n      pxToMove = (elemDim - handleDim) * pctOfBar,\n          //percentage of bar to shift the handle\n      movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal); //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\n\n\n      location = parseFloat(location.toFixed(this.options.decimal)); // declare empty object for css adjustments, only used with 2 handled-sliders\n\n      var css = {};\n\n      this._setValues($hndl, location); // TODO update to calculate based on values set to respective inputs??\n\n\n      if (isDbl) {\n        var isLeftHndl = this.handles.index($hndl) === 0,\n            //empty variable, will be used for min-height/width for fill bar\n        dim,\n            //percentage w/h of the handle compared to the slider bar\n        handlePct = ~~(percent(handleDim, elemDim) * 100); //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\n\n        if (isLeftHndl) {\n          //left or top percentage value to apply to the fill bar.\n          css[lOrT] = \"\".concat(movement, \"%\"); //calculate the new min-height/width for the fill bar.\n\n          dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct; //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\n          //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\n\n          if (cb && typeof cb === 'function') {\n            cb();\n          } //this is only needed for the initialization of 2 handled sliders\n\n        } else {\n          //just caching the value of the left/bottom handle's left/top property\n          var handlePos = parseFloat(this.$handle[0].style[lOrT]); //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\n          //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\n\n          dim = movement - (isNaN(handlePos) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\n        } // assign the min-height/width to our css object\n\n\n        css[\"min-\".concat(hOrW)] = \"\".concat(dim, \"%\");\n      }\n\n      this.$element.one('finished.zf.animate', function () {\n        /**\n         * Fires when the handle is done moving.\n         * @event Slider#moved\n         */\n        _this.$element.trigger('moved.zf.slider', [$hndl]);\n      }); //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\n\n      var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\n      Object(_foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Move\"])(moveTime, $hndl, function () {\n        // adjusting the left/top property of the handle, based on the percentage calculated above\n        // if movement isNaN, that is because the slider is hidden and we cannot determine handle width,\n        // fall back to next best guess.\n        if (isNaN(movement)) {\n          $hndl.css(lOrT, \"\".concat(pctOfBar * 100, \"%\"));\n        } else {\n          $hndl.css(lOrT, \"\".concat(movement, \"%\"));\n        }\n\n        if (!_this.options.doubleSided) {\n          //if single-handled, a simple method to expand the fill bar\n          _this.$fill.css(hOrW, \"\".concat(pctOfBar * 100, \"%\"));\n        } else {\n          //otherwise, use the css object we created above\n          _this.$fill.css(css);\n        }\n      });\n      /**\n       * Fires when the value has not been change for a given time.\n       * @event Slider#changed\n       */\n\n      clearTimeout(_this.timeout);\n      _this.timeout = setTimeout(function () {\n        _this.$element.trigger('changed.zf.slider', [$hndl]);\n      }, _this.options.changedDelay);\n    }\n    /**\n     * Sets the initial attribute for the slider element.\n     * @function\n     * @private\n     * @param {Number} idx - index of the current handle/input to use.\n     */\n\n  }, {\n    key: \"_setInitAttr\",\n    value: function _setInitAttr(idx) {\n      var initVal = idx === 0 ? this.options.initialStart : this.options.initialEnd;\n      var id = this.inputs.eq(idx).attr('id') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"GetYoDigits\"])(6, 'slider');\n      this.inputs.eq(idx).attr({\n        'id': id,\n        'max': this.options.end,\n        'min': this.options.start,\n        'step': this.options.step\n      });\n      this.inputs.eq(idx).val(initVal);\n      this.handles.eq(idx).attr({\n        'role': 'slider',\n        'aria-controls': id,\n        'aria-valuemax': this.options.end,\n        'aria-valuemin': this.options.start,\n        'aria-valuenow': initVal,\n        'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\n        'tabindex': 0\n      });\n    }\n    /**\n     * Sets the input and `aria-valuenow` values for the slider element.\n     * @function\n     * @private\n     * @param {jQuery} $handle - the currently selected handle.\n     * @param {Number} val - floating point of the new value.\n     */\n\n  }, {\n    key: \"_setValues\",\n    value: function _setValues($handle, val) {\n      var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\n      this.inputs.eq(idx).val(val);\n      $handle.attr('aria-valuenow', val);\n    }\n    /**\n     * Handles events on the slider element.\n     * Calculates the new location of the current handle.\n     * If there are two handles and the bar was clicked, it determines which handle to move.\n     * @function\n     * @private\n     * @param {Object} e - the `event` object passed from the listener.\n     * @param {jQuery} $handle - the current handle to calculate for, if selected.\n     * @param {Number} val - floating point number for the new value of the slider.\n     * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\n     */\n\n  }, {\n    key: \"_handleEvent\",\n    value: function _handleEvent(e, $handle, val) {\n      var value, hasVal;\n\n      if (!val) {\n        //click or drag events\n        e.preventDefault();\n\n        var _this = this,\n            vertical = this.options.vertical,\n            param = vertical ? 'height' : 'width',\n            direction = vertical ? 'top' : 'left',\n            eventOffset = vertical ? e.pageY : e.pageX,\n            barDim = this.$element[0].getBoundingClientRect()[param],\n            windowScroll = vertical ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollTop() : jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).scrollLeft();\n\n        var elemOffset = this.$element.offset()[direction]; // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\n        // best way to guess this is simulated is if clientY == pageY\n\n        if (e.clientY === e.pageY) {\n          eventOffset = eventOffset + windowScroll;\n        }\n\n        var eventFromBar = eventOffset - elemOffset;\n        var barXY;\n\n        if (eventFromBar < 0) {\n          barXY = 0;\n        } else if (eventFromBar > barDim) {\n          barXY = barDim;\n        } else {\n          barXY = eventFromBar;\n        }\n\n        var offsetPct = percent(barXY, barDim);\n        value = this._value(offsetPct); // turn everything around for RTL, yay math!\n\n        if (Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"rtl\"])() && !this.options.vertical) {\n          value = this.options.end - value;\n        }\n\n        value = _this._adjustValue(null, value); //boolean flag for the setHandlePos fn, specifically for vertical sliders\n\n        hasVal = false;\n\n        if (!$handle) {\n          //figure out which handle it is, pass it to the next function.\n          var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\n              secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\n          $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\n        }\n      } else {\n        //change event on input\n        value = this._adjustValue(null, val);\n        hasVal = true;\n      }\n\n      this._setHandlePos($handle, value);\n    }\n    /**\n     * Adjustes value for handle in regard to step value. returns adjusted value\n     * @function\n     * @private\n     * @param {jQuery} $handle - the selected handle.\n     * @param {Number} value - value to adjust. used if $handle is falsy\n     */\n\n  }, {\n    key: \"_adjustValue\",\n    value: function _adjustValue($handle, value) {\n      var val,\n          step = this.options.step,\n          div = parseFloat(step / 2),\n          left,\n          prev_val,\n          next_val;\n\n      if (!!$handle) {\n        val = parseFloat($handle.attr('aria-valuenow'));\n      } else {\n        val = value;\n      }\n\n      if (val >= 0) {\n        left = val % step;\n      } else {\n        left = step + val % step;\n      }\n\n      prev_val = val - left;\n      next_val = prev_val + step;\n\n      if (left === 0) {\n        return val;\n      }\n\n      val = val >= prev_val + div ? next_val : prev_val;\n      return val;\n    }\n    /**\n     * Adds event listeners to the slider elements.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      this._eventsForHandle(this.$handle);\n\n      if (this.handles[1]) {\n        this._eventsForHandle(this.$handle2);\n      }\n    }\n    /**\n     * Adds event listeners a particular handle\n     * @function\n     * @private\n     * @param {jQuery} $handle - the current handle to apply listeners to.\n     */\n\n  }, {\n    key: \"_eventsForHandle\",\n    value: function _eventsForHandle($handle) {\n      var _this = this,\n          curHandle;\n\n      var handleChangeEvent = function handleChangeEvent(e) {\n        var idx = _this.inputs.index(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\n\n        _this._handleEvent(e, _this.handles.eq(idx), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val());\n      }; // IE only triggers the change event when the input loses focus which strictly follows the HTML specification\n      // listen for the enter key and trigger a change\n      // @see https://html.spec.whatwg.org/multipage/input.html#common-input-element-events\n\n\n      this.inputs.off('keyup.zf.slider').on('keyup.zf.slider', function (e) {\n        if (e.keyCode == 13) handleChangeEvent.call(this, e);\n      });\n      this.inputs.off('change.zf.slider').on('change.zf.slider', handleChangeEvent);\n\n      if (this.options.clickSelect) {\n        this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\n          if (_this.$element.data('dragging')) {\n            return false;\n          }\n\n          if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.target).is('[data-slider-handle]')) {\n            if (_this.options.doubleSided) {\n              _this._handleEvent(e);\n            } else {\n              _this._handleEvent(e, _this.$handle);\n            }\n          }\n        });\n      }\n\n      if (this.options.draggable) {\n        this.handles.addTouch();\n        var $body = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body');\n        $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\n          $handle.addClass('is-dragging');\n\n          _this.$fill.addClass('is-dragging'); //\n\n\n          _this.$element.data('dragging', true);\n\n          curHandle = jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.currentTarget);\n          $body.on('mousemove.zf.slider', function (e) {\n            e.preventDefault();\n\n            _this._handleEvent(e, curHandle);\n          }).on('mouseup.zf.slider', function (e) {\n            _this._handleEvent(e, curHandle);\n\n            $handle.removeClass('is-dragging');\n\n            _this.$fill.removeClass('is-dragging');\n\n            _this.$element.data('dragging', false);\n\n            $body.off('mousemove.zf.slider mouseup.zf.slider');\n          });\n        }) // prevent events triggered by touch\n        .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\n          e.preventDefault();\n        });\n      }\n\n      $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\n        var _$handle = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\n            oldValue = parseFloat(_this.inputs.eq(idx).val()),\n            newValue; // handle keyboard event with keyboard util\n\n\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"].handleKey(e, 'Slider', {\n          decrease: function decrease() {\n            newValue = oldValue - _this.options.step;\n          },\n          increase: function increase() {\n            newValue = oldValue + _this.options.step;\n          },\n          decrease_fast: function decrease_fast() {\n            newValue = oldValue - _this.options.step * 10;\n          },\n          increase_fast: function increase_fast() {\n            newValue = oldValue + _this.options.step * 10;\n          },\n          min: function min() {\n            newValue = _this.options.start;\n          },\n          max: function max() {\n            newValue = _this.options.end;\n          },\n          handled: function handled() {\n            // only set handle pos when event was handled specially\n            e.preventDefault();\n\n            _this._setHandlePos(_$handle, newValue);\n          }\n        });\n        /*if (newValue) { // if pressed key has special function, update value\n          e.preventDefault();\n          _this._setHandlePos(_$handle, newValue);\n        }*/\n      });\n    }\n    /**\n     * Destroys the slider plugin.\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.handles.off('.zf.slider');\n      this.inputs.off('.zf.slider');\n      this.$element.off('.zf.slider');\n      clearTimeout(this.timeout);\n    }\n  }]);\n\n  return Slider;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_4__[\"Plugin\"]);\n\nSlider.defaults = {\n  /**\n   * Minimum value for the slider scale.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  start: 0,\n\n  /**\n   * Maximum value for the slider scale.\n   * @option\n   * @type {number}\n   * @default 100\n   */\n  end: 100,\n\n  /**\n   * Minimum value change per change event.\n   * @option\n   * @type {number}\n   * @default 1\n   */\n  step: 1,\n\n  /**\n   * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  initialStart: 0,\n\n  /**\n   * Value at which the right handle/second input should be set to on initialization.\n   * @option\n   * @type {number}\n   * @default 100\n   */\n  initialEnd: 100,\n\n  /**\n   * Allows the input to be located outside the container and visible. Set to by the JS\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  binding: false,\n\n  /**\n   * Allows the user to click/tap on the slider bar to select a value.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  clickSelect: true,\n\n  /**\n   * Set to true and use the `vertical` class to change alignment to vertical.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  vertical: false,\n\n  /**\n   * Allows the user to drag the slider handle(s) to select a value.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  draggable: true,\n\n  /**\n   * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  disabled: false,\n\n  /**\n   * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  doubleSided: false,\n\n  /**\n   * Potential future feature.\n   */\n  // steps: 100,\n\n  /**\n   * Number of decimal places the plugin should go to for floating point precision.\n   * @option\n   * @type {number}\n   * @default 2\n   */\n  decimal: 2,\n\n  /**\n   * Time delay for dragged elements.\n   */\n  // dragDelay: 0,\n\n  /**\n   * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\n   * @option\n   * @type {number}\n   * @default 200\n   */\n  moveTime: 200,\n  //update this if changing the transition time in the sass\n\n  /**\n   * Class applied to disabled sliders.\n   * @option\n   * @type {string}\n   * @default 'disabled'\n   */\n  disabledClass: 'disabled',\n\n  /**\n   * Will invert the default layout for a vertical<span data-tooltip title=\"who would do this???\"> </span>slider.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  invertVertical: false,\n\n  /**\n   * Milliseconds before the `changed.zf-slider` event is triggered after value change.\n   * @option\n   * @type {number}\n   * @default 500\n   */\n  changedDelay: 500,\n\n  /**\n  * Basevalue for non-linear sliders\n  * @option\n  * @type {number}\n  * @default 5\n  */\n  nonLinearBase: 5,\n\n  /**\n  * Basevalue for non-linear sliders, possible values are: `'linear'`, `'pow'` & `'log'`. Pow and Log use the nonLinearBase setting.\n  * @option\n  * @type {string}\n  * @default 'linear'\n  */\n  positionValueFunction: 'linear'\n};\n\nfunction percent(frac, num) {\n  return frac / num;\n}\n\nfunction absPosition($handle, dir, clickPos, param) {\n  return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\n}\n\nfunction baseLog(base, value) {\n  return Math.log(value) / Math.log(base);\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.slider.js?");/***/},/***/"./js/foundation.smoothScroll.js":/*!***************************************!*\
	  !*** ./js/foundation.smoothScroll.js ***!
	  \***************************************/ /*! exports provided: SmoothScroll */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SmoothScroll\", function() { return SmoothScroll; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n/**\n * SmoothScroll module.\n * @module foundation.smoothScroll\n */\n\nvar SmoothScroll =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(SmoothScroll, _Plugin);\n\n  function SmoothScroll() {\n    _classCallCheck(this, SmoothScroll);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SmoothScroll).apply(this, arguments));\n  }\n\n  _createClass(SmoothScroll, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of SmoothScroll.\n     * @class\n     * @name SmoothScroll\n     * @fires SmoothScroll#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, SmoothScroll.defaults, this.$element.data(), options);\n      this.className = 'SmoothScroll'; // ie9 back compat\n\n      this._init();\n    }\n    /**\n     * Initialize the SmoothScroll plugin\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"GetYoDigits\"])(6, 'smooth-scroll');\n      this.$element.attr({\n        id: id\n      });\n\n      this._events();\n    }\n    /**\n     * Initializes events for SmoothScroll.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      this._linkClickListener = this._handleLinkClick.bind(this);\n      this.$element.on('click.zf.smoothScroll', this._linkClickListener);\n      this.$element.on('click.zf.smoothScroll', 'a[href^=\"#\"]', this._linkClickListener);\n    }\n    /**\n     * Handle the given event to smoothly scroll to the anchor pointed by the event target.\n     * @param {*} e - event\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_handleLinkClick\",\n    value: function _handleLinkClick(e) {\n      var _this = this;\n\n      // Follow the link if it does not point to an anchor.\n      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(e.currentTarget).is('a[href^=\"#\"]')) return;\n      var arrival = e.currentTarget.getAttribute('href');\n      this._inTransition = true;\n      SmoothScroll.scrollToLoc(arrival, this.options, function () {\n        _this._inTransition = false;\n      });\n      e.preventDefault();\n    }\n  }, {\n    key: \"_destroy\",\n\n    /**\n     * Destroys the SmoothScroll instance.\n     * @function\n     */\n    value: function _destroy() {\n      this.$element.off('click.zf.smoothScroll', this._linkClickListener);\n      this.$element.off('click.zf.smoothScroll', 'a[href^=\"#\"]', this._linkClickListener);\n    }\n  }], [{\n    key: \"scrollToLoc\",\n\n    /**\n     * Function to scroll to a given location on the page.\n     * @param {String} loc - A properly formatted jQuery id selector. Example: '#foo'\n     * @param {Object} options - The options to use.\n     * @param {Function} callback - The callback function.\n     * @static\n     * @function\n     */\n    value: function scrollToLoc(loc) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SmoothScroll.defaults;\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      var $loc = jquery__WEBPACK_IMPORTED_MODULE_0___default()(loc); // Do nothing if target does not exist to prevent errors\n\n      if (!$loc.length) return false;\n      var scrollPos = Math.round($loc.offset().top - options.threshold / 2 - options.offset);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').stop(true).animate({\n        scrollTop: scrollPos\n      }, options.animationDuration, options.animationEasing, function () {\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n    }\n  }]);\n\n  return SmoothScroll;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\"Plugin\"]);\n/**\n * Default settings for plugin.\n */\n\n\nSmoothScroll.defaults = {\n  /**\n   * Amount of time, in ms, the animated scrolling should take between locations.\n   * @option\n   * @type {number}\n   * @default 500\n   */\n  animationDuration: 500,\n\n  /**\n   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.\n   * @option\n   * @type {string}\n   * @default 'linear'\n   * @see {@link https://api.jquery.com/animate|Jquery animate}\n   */\n  animationEasing: 'linear',\n\n  /**\n   * Number of pixels to use as a marker for location changes.\n   * @option\n   * @type {number}\n   * @default 50\n   */\n  threshold: 50,\n\n  /**\n   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  offset: 0\n};\n\n\n//# sourceURL=webpack:///./js/foundation.smoothScroll.js?");/***/},/***/"./js/foundation.sticky.js":/*!*********************************!*\
	  !*** ./js/foundation.sticky.js ***!
	  \*********************************/ /*! exports provided: Sticky */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sticky\", function() { return Sticky; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Sticky module.\n * @module foundation.sticky\n * @requires foundation.util.triggers\n * @requires foundation.util.mediaQuery\n */\n\nvar Sticky =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Sticky, _Plugin);\n\n  function Sticky() {\n    _classCallCheck(this, Sticky);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Sticky).apply(this, arguments));\n  }\n\n  _createClass(Sticky, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of a sticky thing.\n     * @class\n     * @name Sticky\n     * @param {jQuery} element - jQuery object to make sticky.\n     * @param {Object} options - options object passed when creating the element programmatically.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Sticky.defaults, this.$element.data(), options);\n      this.className = 'Sticky'; // ie9 back compat\n      // Triggers init is idempotent, just need to make sure it is initialized\n\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n    }\n    /**\n     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\"MediaQuery\"]._init();\n\n      var $parent = this.$element.parent('[data-sticky-container]'),\n          id = this.$element[0].id || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"GetYoDigits\"])(6, 'sticky'),\n          _this = this;\n\n      if ($parent.length) {\n        this.$container = $parent;\n      } else {\n        this.wasWrapped = true;\n        this.$element.wrap(this.options.container);\n        this.$container = this.$element.parent();\n      }\n\n      this.$container.addClass(this.options.containerClass);\n      this.$element.addClass(this.options.stickyClass).attr({\n        'data-resize': id,\n        'data-mutate': id\n      });\n\n      if (this.options.anchor !== '') {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + _this.options.anchor).attr({\n          'data-mutate': id\n        });\n      }\n\n      this.scrollCount = this.options.checkEvery;\n      this.isStuck = false;\n      this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"onLoad\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\n        //We calculate the container height to have correct values for anchor points offset calculation.\n        _this.containerHeight = _this.$element.css(\"display\") == \"none\" ? 0 : _this.$element[0].getBoundingClientRect().height;\n\n        _this.$container.css('height', _this.containerHeight);\n\n        _this.elemHeight = _this.containerHeight;\n\n        if (_this.options.anchor !== '') {\n          _this.$anchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + _this.options.anchor);\n        } else {\n          _this._parsePoints();\n        }\n\n        _this._setSizes(function () {\n          var scroll = window.pageYOffset;\n\n          _this._calc(false, scroll); //Unstick the element will ensure that proper classes are set.\n\n\n          if (!_this.isStuck) {\n            _this._removeSticky(scroll >= _this.topPoint ? false : true);\n          }\n        });\n\n        _this._events(id.split('-').reverse().join('-'));\n      });\n    }\n    /**\n     * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_parsePoints\",\n    value: function _parsePoints() {\n      var top = this.options.topAnchor == \"\" ? 1 : this.options.topAnchor,\n          btm = this.options.btmAnchor == \"\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\n          pts = [top, btm],\n          breaks = {};\n\n      for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\n        var pt;\n\n        if (typeof pts[i] === 'number') {\n          pt = pts[i];\n        } else {\n          var place = pts[i].split(':'),\n              anchor = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(place[0]));\n          pt = anchor.offset().top;\n\n          if (place[1] && place[1].toLowerCase() === 'bottom') {\n            pt += anchor[0].getBoundingClientRect().height;\n          }\n        }\n\n        breaks[i] = pt;\n      }\n\n      this.points = breaks;\n      return;\n    }\n    /**\n     * Adds event handlers for the scrolling element.\n     * @private\n     * @param {String} id - pseudo-random id for unique scroll event listener.\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events(id) {\n      var _this = this,\n          scrollListener = this.scrollListener = \"scroll.zf.\".concat(id);\n\n      if (this.isOn) {\n        return;\n      }\n\n      if (this.canStick) {\n        this.isOn = true;\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(scrollListener).on(scrollListener, function (e) {\n          if (_this.scrollCount === 0) {\n            _this.scrollCount = _this.options.checkEvery;\n\n            _this._setSizes(function () {\n              _this._calc(false, window.pageYOffset);\n            });\n          } else {\n            _this.scrollCount--;\n\n            _this._calc(false, window.pageYOffset);\n          }\n        });\n      }\n\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\n        _this._eventsHandler(id);\n      });\n      this.$element.on('mutateme.zf.trigger', function (e, el) {\n        _this._eventsHandler(id);\n      });\n\n      if (this.$anchor) {\n        this.$anchor.on('mutateme.zf.trigger', function (e, el) {\n          _this._eventsHandler(id);\n        });\n      }\n    }\n    /**\n     * Handler for events.\n     * @private\n     * @param {String} id - pseudo-random id for unique scroll event listener.\n     */\n\n  }, {\n    key: \"_eventsHandler\",\n    value: function _eventsHandler(id) {\n      var _this = this,\n          scrollListener = this.scrollListener = \"scroll.zf.\".concat(id);\n\n      _this._setSizes(function () {\n        _this._calc(false);\n\n        if (_this.canStick) {\n          if (!_this.isOn) {\n            _this._events(id);\n          }\n        } else if (_this.isOn) {\n          _this._pauseListeners(scrollListener);\n        }\n      });\n    }\n    /**\n     * Removes event handlers for scroll and change events on anchor.\n     * @fires Sticky#pause\n     * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\n     */\n\n  }, {\n    key: \"_pauseListeners\",\n    value: function _pauseListeners(scrollListener) {\n      this.isOn = false;\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(scrollListener);\n      /**\n       * Fires when the plugin is paused due to resize event shrinking the view.\n       * @event Sticky#pause\n       * @private\n       */\n\n      this.$element.trigger('pause.zf.sticky');\n    }\n    /**\n     * Called on every `scroll` event and on `_init`\n     * fires functions based on booleans and cached values\n     * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\n     * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\n     */\n\n  }, {\n    key: \"_calc\",\n    value: function _calc(checkSizes, scroll) {\n      if (checkSizes) {\n        this._setSizes();\n      }\n\n      if (!this.canStick) {\n        if (this.isStuck) {\n          this._removeSticky(true);\n        }\n\n        return false;\n      }\n\n      if (!scroll) {\n        scroll = window.pageYOffset;\n      }\n\n      if (scroll >= this.topPoint) {\n        if (scroll <= this.bottomPoint) {\n          if (!this.isStuck) {\n            this._setSticky();\n          }\n        } else {\n          if (this.isStuck) {\n            this._removeSticky(false);\n          }\n        }\n      } else {\n        if (this.isStuck) {\n          this._removeSticky(true);\n        }\n      }\n    }\n    /**\n     * Causes the $element to become stuck.\n     * Adds `position: fixed;`, and helper classes.\n     * @fires Sticky#stuckto\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_setSticky\",\n    value: function _setSticky() {\n      var _this = this,\n          stickTo = this.options.stickTo,\n          mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\n          notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\n          css = {};\n\n      css[mrgn] = \"\".concat(this.options[mrgn], \"em\");\n      css[stickTo] = 0;\n      css[notStuckTo] = 'auto';\n      this.isStuck = true;\n      this.$element.removeClass(\"is-anchored is-at-\".concat(notStuckTo)).addClass(\"is-stuck is-at-\".concat(stickTo)).css(css)\n      /**\n       * Fires when the $element has become `position: fixed;`\n       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\n       * @event Sticky#stuckto\n       */\n      .trigger(\"sticky.zf.stuckto:\".concat(stickTo));\n      this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\", function () {\n        _this._setSizes();\n      });\n    }\n    /**\n     * Causes the $element to become unstuck.\n     * Removes `position: fixed;`, and helper classes.\n     * Adds other helper classes.\n     * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\n     * @fires Sticky#unstuckfrom\n     * @private\n     */\n\n  }, {\n    key: \"_removeSticky\",\n    value: function _removeSticky(isTop) {\n      var stickTo = this.options.stickTo,\n          stickToTop = stickTo === 'top',\n          css = {},\n          anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\n          mrgn = stickToTop ? 'marginTop' : 'marginBottom',\n          topOrBottom = isTop ? 'top' : 'bottom';\n      css[mrgn] = 0;\n      css['bottom'] = 'auto';\n\n      if (isTop) {\n        css['top'] = 0;\n      } else {\n        css['top'] = anchorPt;\n      }\n\n      this.isStuck = false;\n      this.$element.removeClass(\"is-stuck is-at-\".concat(stickTo)).addClass(\"is-anchored is-at-\".concat(topOrBottom)).css(css)\n      /**\n       * Fires when the $element has become anchored.\n       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\n       * @event Sticky#unstuckfrom\n       */\n      .trigger(\"sticky.zf.unstuckfrom:\".concat(topOrBottom));\n    }\n    /**\n     * Sets the $element and $container sizes for plugin.\n     * Calls `_setBreakPoints`.\n     * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\n     * @private\n     */\n\n  }, {\n    key: \"_setSizes\",\n    value: function _setSizes(cb) {\n      this.canStick = _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_3__[\"MediaQuery\"].is(this.options.stickyOn);\n\n      if (!this.canStick) {\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      }\n\n      var _this = this,\n          newElemWidth = this.$container[0].getBoundingClientRect().width,\n          comp = window.getComputedStyle(this.$container[0]),\n          pdngl = parseInt(comp['padding-left'], 10),\n          pdngr = parseInt(comp['padding-right'], 10);\n\n      if (this.$anchor && this.$anchor.length) {\n        this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\n      } else {\n        this._parsePoints();\n      }\n\n      this.$element.css({\n        'max-width': \"\".concat(newElemWidth - pdngl - pdngr, \"px\")\n      }); // Recalculate the height only if it is \"dynamic\"\n\n      if (this.options.dynamicHeight || !this.containerHeight) {\n        // Get the sticked element height and apply it to the container to \"hold the place\"\n        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\n        newContainerHeight = this.$element.css(\"display\") == \"none\" ? 0 : newContainerHeight;\n        this.$container.css('height', newContainerHeight);\n        this.containerHeight = newContainerHeight;\n      }\n\n      this.elemHeight = this.containerHeight;\n\n      if (!this.isStuck) {\n        if (this.$element.hasClass('is-at-bottom')) {\n          var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\n          this.$element.css('top', anchorPt);\n        }\n      }\n\n      this._setBreakPoints(this.containerHeight, function () {\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      });\n    }\n    /**\n     * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\n     * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\n     * @param {Function} cb - optional callback function to be called on completion.\n     * @private\n     */\n\n  }, {\n    key: \"_setBreakPoints\",\n    value: function _setBreakPoints(elemHeight, cb) {\n      if (!this.canStick) {\n        if (cb && typeof cb === 'function') {\n          cb();\n        } else {\n          return false;\n        }\n      }\n\n      var mTop = emCalc(this.options.marginTop),\n          mBtm = emCalc(this.options.marginBottom),\n          topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\n          bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\n          // topPoint = this.$anchor.offset().top || this.points[0],\n      // bottomPoint = topPoint + this.anchorHeight || this.points[1],\n      winHeight = window.innerHeight;\n\n      if (this.options.stickTo === 'top') {\n        topPoint -= mTop;\n        bottomPoint -= elemHeight + mTop;\n      } else if (this.options.stickTo === 'bottom') {\n        topPoint -= winHeight - (elemHeight + mBtm);\n        bottomPoint -= winHeight - mBtm;\n      } else {//this would be the stickTo: both option... tricky\n      }\n\n      this.topPoint = topPoint;\n      this.bottomPoint = bottomPoint;\n\n      if (cb && typeof cb === 'function') {\n        cb();\n      }\n    }\n    /**\n     * Destroys the current sticky element.\n     * Resets the element to the top position first.\n     * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this._removeSticky(true);\n\n      this.$element.removeClass(\"\".concat(this.options.stickyClass, \" is-anchored is-at-top\")).css({\n        height: '',\n        top: '',\n        bottom: '',\n        'max-width': ''\n      }).off('resizeme.zf.trigger').off('mutateme.zf.trigger');\n\n      if (this.$anchor && this.$anchor.length) {\n        this.$anchor.off('change.zf.sticky');\n      }\n\n      if (this.scrollListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.scrollListener);\n      if (this.onLoadListener) jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\n\n      if (this.wasWrapped) {\n        this.$element.unwrap();\n      } else {\n        this.$container.removeClass(this.options.containerClass).css({\n          height: ''\n        });\n      }\n    }\n  }]);\n\n  return Sticky;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n\nSticky.defaults = {\n  /**\n   * Customizable container template. Add your own classes for styling and sizing.\n   * @option\n   * @type {string}\n   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'\n   */\n  container: '<div data-sticky-container></div>',\n\n  /**\n   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.\n   * @option\n   * @type {string}\n   * @default 'top'\n   */\n  stickTo: 'top',\n\n  /**\n   * If anchored to a single element, the id of that element.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  anchor: '',\n\n  /**\n   * If using more than one element as anchor points, the id of the top anchor.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  topAnchor: '',\n\n  /**\n   * If using more than one element as anchor points, the id of the bottom anchor.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  btmAnchor: '',\n\n  /**\n   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\n   * @option\n   * @type {number}\n   * @default 1\n   */\n  marginTop: 1,\n\n  /**\n   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\n   * @option\n   * @type {number}\n   * @default 1\n   */\n  marginBottom: 1,\n\n  /**\n   * Breakpoint string that is the minimum screen size an element should become sticky.\n   * @option\n   * @type {string}\n   * @default 'medium'\n   */\n  stickyOn: 'medium',\n\n  /**\n   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\n   * @option\n   * @type {string}\n   * @default 'sticky'\n   */\n  stickyClass: 'sticky',\n\n  /**\n   * Class applied to sticky container. Foundation defaults to `sticky-container`.\n   * @option\n   * @type {string}\n   * @default 'sticky-container'\n   */\n  containerClass: 'sticky-container',\n\n  /**\n   * If true (by default), keep the sticky container the same height as the element. Otherwise, the container height is set once and does not change.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  dynamicHeight: true,\n\n  /**\n   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\n   * @option\n   * @type {number}\n   * @default -1\n   */\n  checkEvery: -1\n};\n/**\n * Helper function to calculate em values\n * @param Number {em} - number of em's to calculate into pixels\n */\n\nfunction emCalc(em) {\n  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.sticky.js?");/***/},/***/"./js/foundation.tabs.js":/*!*******************************!*\
	  !*** ./js/foundation.tabs.js ***!
	  \*******************************/ /*! exports provided: Tabs */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tabs\", function() { return Tabs; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.keyboard */ \"./js/foundation.util.keyboard.js\");\n/* harmony import */ var _foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.imageLoader */ \"./js/foundation.util.imageLoader.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Tabs module.\n * @module foundation.tabs\n * @requires foundation.util.keyboard\n * @requires foundation.util.imageLoader if tabs contain images\n */\n\nvar Tabs =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Tabs, _Plugin);\n\n  function Tabs() {\n    _classCallCheck(this, Tabs);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tabs).apply(this, arguments));\n  }\n\n  _createClass(Tabs, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of tabs.\n     * @class\n     * @name Tabs\n     * @fires Tabs#init\n     * @param {jQuery} element - jQuery object to make into tabs.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Tabs.defaults, this.$element.data(), options);\n      this.className = 'Tabs'; // ie9 back compat\n\n      this._init();\n\n      _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].register('Tabs', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'previous',\n        'ARROW_DOWN': 'next',\n        'ARROW_LEFT': 'previous' // 'TAB': 'next',\n        // 'SHIFT_TAB': 'previous'\n\n      });\n    }\n    /**\n     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var _this2 = this;\n\n      var _this = this;\n\n      this._isInitializing = true;\n      this.$element.attr({\n        'role': 'tablist'\n      });\n      this.$tabTitles = this.$element.find(\".\".concat(this.options.linkClass));\n      this.$tabContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-tabs-content=\\\"\".concat(this.$element[0].id, \"\\\"]\"));\n      this.$tabTitles.each(function () {\n        var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            $link = $elem.find('a'),\n            isActive = $elem.hasClass(\"\".concat(_this.options.linkActiveClass)),\n            hash = $link.attr('data-tabs-target') || $link[0].hash.slice(1),\n            linkId = $link[0].id ? $link[0].id : \"\".concat(hash, \"-label\"),\n            $tabContent = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(hash));\n        $elem.attr({\n          'role': 'presentation'\n        });\n        $link.attr({\n          'role': 'tab',\n          'aria-controls': hash,\n          'aria-selected': isActive,\n          'id': linkId,\n          'tabindex': isActive ? '0' : '-1'\n        });\n        $tabContent.attr({\n          'role': 'tabpanel',\n          'aria-labelledby': linkId\n        }); // Save up the initial hash to return to it later when going back in history\n\n        if (isActive) {\n          _this._initialAnchor = \"#\".concat(hash);\n        }\n\n        if (!isActive) {\n          $tabContent.attr('aria-hidden', 'true');\n        }\n\n        if (isActive && _this.options.autoFocus) {\n          _this.onLoadListener = Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"onLoad\"])(jquery__WEBPACK_IMPORTED_MODULE_0___default()(window), function () {\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').animate({\n              scrollTop: $elem.offset().top\n            }, _this.options.deepLinkSmudgeDelay, function () {\n              $link.focus();\n            });\n          });\n        }\n      });\n\n      if (this.options.matchHeight) {\n        var $images = this.$tabContent.find('img');\n\n        if ($images.length) {\n          Object(_foundation_util_imageLoader__WEBPACK_IMPORTED_MODULE_4__[\"onImagesLoaded\"])($images, this._setHeight.bind(this));\n        } else {\n          this._setHeight();\n        }\n      } // Current context-bound function to open tabs on page load or history hashchange\n\n\n      this._checkDeepLink = function () {\n        var anchor = window.location.hash;\n\n        if (!anchor.length) {\n          // If we are still initializing and there is no anchor, then there is nothing to do\n          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor\n\n          if (_this2._initialAnchor) anchor = _this2._initialAnchor;\n        }\n\n        var anchorNoHash = anchor.indexOf('#') >= 0 ? anchor.slice(1) : anchor;\n        var $anchor = anchorNoHash && jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(anchorNoHash));\n\n        var $link = anchor && _this2.$element.find(\"[href$=\\\"\".concat(anchor, \"\\\"],[data-tabs-target=\\\"\").concat(anchorNoHash, \"\\\"]\")).first(); // Whether the anchor element that has been found is part of this element\n\n\n        var isOwnAnchor = !!($anchor.length && $link.length);\n\n        if (isOwnAnchor) {\n          // If there is an anchor for the hash, select it\n          if ($anchor && $anchor.length && $link && $link.length) {\n            _this2.selectTab($anchor, true);\n          } // Otherwise, collapse everything\n          else {\n              _this2._collapse();\n            } // Roll up a little to show the titles\n\n\n          if (_this2.options.deepLinkSmudge) {\n            var offset = _this2.$element.offset();\n\n            jquery__WEBPACK_IMPORTED_MODULE_0___default()('html, body').animate({\n              scrollTop: offset.top\n            }, _this2.options.deepLinkSmudgeDelay);\n          }\n          /**\n           * Fires when the plugin has deeplinked at pageload\n           * @event Tabs#deeplink\n           */\n\n\n          _this2.$element.trigger('deeplink.zf.tabs', [$link, $anchor]);\n        }\n      }; //use browser to open a tab, if it exists in this tabset\n\n\n      if (this.options.deepLink) {\n        this._checkDeepLink();\n      }\n\n      this._events();\n\n      this._isInitializing = false;\n    }\n    /**\n     * Adds event handlers for items within the tabs.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      this._addKeyHandler();\n\n      this._addClickHandler();\n\n      this._setHeightMqHandler = null;\n\n      if (this.options.matchHeight) {\n        this._setHeightMqHandler = this._setHeight.bind(this);\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('changed.zf.mediaquery', this._setHeightMqHandler);\n      }\n\n      if (this.options.deepLink) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on('hashchange', this._checkDeepLink);\n      }\n    }\n    /**\n     * Adds click handlers for items within the tabs.\n     * @private\n     */\n\n  }, {\n    key: \"_addClickHandler\",\n    value: function _addClickHandler() {\n      var _this = this;\n\n      this.$element.off('click.zf.tabs').on('click.zf.tabs', \".\".concat(this.options.linkClass), function (e) {\n        e.preventDefault();\n\n        _this._handleTabChange(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));\n      });\n    }\n    /**\n     * Adds keyboard event handlers for items within the tabs.\n     * @private\n     */\n\n  }, {\n    key: \"_addKeyHandler\",\n    value: function _addKeyHandler() {\n      var _this = this;\n\n      this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {\n        if (e.which === 9) return;\n        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            $elements = $element.parent('ul').children('li'),\n            $prevElement,\n            $nextElement;\n        $elements.each(function (i) {\n          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is($element)) {\n            if (_this.options.wrapOnKeys) {\n              $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);\n              $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);\n            } else {\n              $prevElement = $elements.eq(Math.max(0, i - 1));\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\n            }\n\n            return;\n          }\n        }); // handle keyboard event with keyboard util\n\n        _foundation_util_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"Keyboard\"].handleKey(e, 'Tabs', {\n          open: function open() {\n            $element.find('[role=\"tab\"]').focus();\n\n            _this._handleTabChange($element);\n          },\n          previous: function previous() {\n            $prevElement.find('[role=\"tab\"]').focus();\n\n            _this._handleTabChange($prevElement);\n          },\n          next: function next() {\n            $nextElement.find('[role=\"tab\"]').focus();\n\n            _this._handleTabChange($nextElement);\n          },\n          handled: function handled() {\n            e.preventDefault();\n          }\n        });\n      });\n    }\n    /**\n     * Opens the tab `$targetContent` defined by `$target`. Collapses active tab.\n     * @param {jQuery} $target - Tab to open.\n     * @param {boolean} historyHandled - browser has already handled a history update\n     * @fires Tabs#change\n     * @function\n     */\n\n  }, {\n    key: \"_handleTabChange\",\n    value: function _handleTabChange($target, historyHandled) {\n      // With `activeCollapse`, if the target is the active Tab, collapse it.\n      if ($target.hasClass(\"\".concat(this.options.linkActiveClass))) {\n        if (this.options.activeCollapse) {\n          this._collapse();\n        }\n\n        return;\n      }\n\n      var $oldTab = this.$element.find(\".\".concat(this.options.linkClass, \".\").concat(this.options.linkActiveClass)),\n          $tabLink = $target.find('[role=\"tab\"]'),\n          target = $tabLink.attr('data-tabs-target'),\n          anchor = target && target.length ? \"#\".concat(target) : $tabLink[0].hash,\n          $targetContent = this.$tabContent.find(anchor); //close old tab\n\n      this._collapseTab($oldTab); //open new tab\n\n\n      this._openTab($target); //either replace or update browser history\n\n\n      if (this.options.deepLink && !historyHandled) {\n        if (this.options.updateHistory) {\n          history.pushState({}, '', anchor);\n        } else {\n          history.replaceState({}, '', anchor);\n        }\n      }\n      /**\n       * Fires when the plugin has successfully changed tabs.\n       * @event Tabs#change\n       */\n\n\n      this.$element.trigger('change.zf.tabs', [$target, $targetContent]); //fire to children a mutation event\n\n      $targetContent.find(\"[data-mutate]\").trigger(\"mutateme.zf.trigger\");\n    }\n    /**\n     * Opens the tab `$targetContent` defined by `$target`.\n     * @param {jQuery} $target - Tab to open.\n     * @function\n     */\n\n  }, {\n    key: \"_openTab\",\n    value: function _openTab($target) {\n      var $tabLink = $target.find('[role=\"tab\"]'),\n          hash = $tabLink.attr('data-tabs-target') || $tabLink[0].hash.slice(1),\n          $targetContent = this.$tabContent.find(\"#\".concat(hash));\n      $target.addClass(\"\".concat(this.options.linkActiveClass));\n      $tabLink.attr({\n        'aria-selected': 'true',\n        'tabindex': '0'\n      });\n      $targetContent.addClass(\"\".concat(this.options.panelActiveClass)).removeAttr('aria-hidden');\n    }\n    /**\n     * Collapses `$targetContent` defined by `$target`.\n     * @param {jQuery} $target - Tab to collapse.\n     * @function\n     */\n\n  }, {\n    key: \"_collapseTab\",\n    value: function _collapseTab($target) {\n      var $target_anchor = $target.removeClass(\"\".concat(this.options.linkActiveClass)).find('[role=\"tab\"]').attr({\n        'aria-selected': 'false',\n        'tabindex': -1\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat($target_anchor.attr('aria-controls'))).removeClass(\"\".concat(this.options.panelActiveClass)).attr({\n        'aria-hidden': 'true'\n      });\n    }\n    /**\n     * Collapses the active Tab.\n     * @fires Tabs#collapse\n     * @function\n     */\n\n  }, {\n    key: \"_collapse\",\n    value: function _collapse() {\n      var $activeTab = this.$element.find(\".\".concat(this.options.linkClass, \".\").concat(this.options.linkActiveClass));\n\n      if ($activeTab.length) {\n        this._collapseTab($activeTab);\n        /**\n        * Fires when the plugin has successfully collapsed tabs.\n        * @event Tabs#collapse\n        */\n\n\n        this.$element.trigger('collapse.zf.tabs', [$activeTab]);\n      }\n    }\n    /**\n     * Public method for selecting a content pane to display.\n     * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.\n     * @param {boolean} historyHandled - browser has already handled a history update\n     * @function\n     */\n\n  }, {\n    key: \"selectTab\",\n    value: function selectTab(elem, historyHandled) {\n      var idStr, hashIdStr;\n\n      if (_typeof(elem) === 'object') {\n        idStr = elem[0].id;\n      } else {\n        idStr = elem;\n      }\n\n      if (idStr.indexOf('#') < 0) {\n        hashIdStr = \"#\".concat(idStr);\n      } else {\n        hashIdStr = idStr;\n        idStr = idStr.slice(1);\n      }\n\n      var $target = this.$tabTitles.has(\"[href$=\\\"\".concat(hashIdStr, \"\\\"],[data-tabs-target=\\\"\").concat(idStr, \"\\\"]\")).first();\n\n      this._handleTabChange($target, historyHandled);\n    }\n  }, {\n    key: \"_setHeight\",\n\n    /**\n     * Sets the height of each panel to the height of the tallest panel.\n     * If enabled in options, gets called on media query change.\n     * If loading content via external source, can be called directly or with _reflow.\n     * If enabled with `data-match-height=\"true\"`, tabs sets to equal height\n     * @function\n     * @private\n     */\n    value: function _setHeight() {\n      var max = 0,\n          _this = this; // Lock down the `this` value for the root tabs object\n\n\n      this.$tabContent.find(\".\".concat(this.options.panelClass)).css('height', '').each(function () {\n        var panel = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n            isActive = panel.hasClass(\"\".concat(_this.options.panelActiveClass)); // get the options from the parent instead of trying to get them from the child\n\n        if (!isActive) {\n          panel.css({\n            'visibility': 'hidden',\n            'display': 'block'\n          });\n        }\n\n        var temp = this.getBoundingClientRect().height;\n\n        if (!isActive) {\n          panel.css({\n            'visibility': '',\n            'display': ''\n          });\n        }\n\n        max = temp > max ? temp : max;\n      }).css('height', \"\".concat(max, \"px\"));\n    }\n    /**\n     * Destroys an instance of tabs.\n     * @fires Tabs#destroyed\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.find(\".\".concat(this.options.linkClass)).off('.zf.tabs').hide().end().find(\".\".concat(this.options.panelClass)).hide();\n\n      if (this.options.matchHeight) {\n        if (this._setHeightMqHandler != null) {\n          jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('changed.zf.mediaquery', this._setHeightMqHandler);\n        }\n      }\n\n      if (this.options.deepLink) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('hashchange', this._checkDeepLink);\n      }\n\n      if (this.onLoadListener) {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(this.onLoadListener);\n      }\n    }\n  }]);\n\n  return Tabs;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_1__[\"Plugin\"]);\n\nTabs.defaults = {\n  /**\n   * Link the location hash to the active pane.\n   * Set the location hash when the active pane changes, and open the corresponding pane when the location changes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  deepLink: false,\n\n  /**\n   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the tab panel is visible\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  deepLinkSmudge: false,\n\n  /**\n   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment\n   * @option\n   * @type {number}\n   * @default 300\n   */\n  deepLinkSmudgeDelay: 300,\n\n  /**\n   * If `deepLink` is enabled, update the browser history with the open tab\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  updateHistory: false,\n\n  /**\n   * Allows the window to scroll to content of active pane on load.\n   * Not recommended if more than one tab panel per page.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  autoFocus: false,\n\n  /**\n   * Allows keyboard input to 'wrap' around the tab links.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  wrapOnKeys: true,\n\n  /**\n   * Allows the tab content panes to match heights if set to true.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  matchHeight: false,\n\n  /**\n   * Allows active tabs to collapse when clicked.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  activeCollapse: false,\n\n  /**\n   * Class applied to `li`'s in tab link list.\n   * @option\n   * @type {string}\n   * @default 'tabs-title'\n   */\n  linkClass: 'tabs-title',\n\n  /**\n   * Class applied to the active `li` in tab link list.\n   * @option\n   * @type {string}\n   * @default 'is-active'\n   */\n  linkActiveClass: 'is-active',\n\n  /**\n   * Class applied to the content containers.\n   * @option\n   * @type {string}\n   * @default 'tabs-panel'\n   */\n  panelClass: 'tabs-panel',\n\n  /**\n   * Class applied to the active content container.\n   * @option\n   * @type {string}\n   * @default 'is-active'\n   */\n  panelActiveClass: 'is-active'\n};\n\n\n//# sourceURL=webpack:///./js/foundation.tabs.js?");/***/},/***/"./js/foundation.toggler.js":/*!**********************************!*\
	  !*** ./js/foundation.toggler.js ***!
	  \**********************************/ /*! exports provided: Toggler */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Toggler\", function() { return Toggler; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\n/* harmony import */ var _foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.core.plugin */ \"./js/foundation.core.plugin.js\");\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Toggler module.\n * @module foundation.toggler\n * @requires foundation.util.motion\n * @requires foundation.util.triggers\n */\n\nvar Toggler =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Toggler, _Plugin);\n\n  function Toggler() {\n    _classCallCheck(this, Toggler);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Toggler).apply(this, arguments));\n  }\n\n  _createClass(Toggler, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of Toggler.\n     * @class\n     * @name Toggler\n     * @fires Toggler#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Toggler.defaults, element.data(), options);\n      this.className = '';\n      this.className = 'Toggler'; // ie9 back compat\n      // Triggers init is idempotent, just need to make sure it is initialized\n\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_4__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n\n      this._events();\n    }\n    /**\n     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      // Collect triggers to set ARIA attributes to\n      var id = this.$element[0].id,\n          $triggers = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open~=\\\"\".concat(id, \"\\\"], [data-close~=\\\"\").concat(id, \"\\\"], [data-toggle~=\\\"\").concat(id, \"\\\"]\"));\n      var input; // Parse animation classes if they were set\n\n      if (this.options.animate) {\n        input = this.options.animate.split(' ');\n        this.animationIn = input[0];\n        this.animationOut = input[1] || null; // - aria-expanded: according to the element visibility.\n\n        $triggers.attr('aria-expanded', !this.$element.is(':hidden'));\n      } // Otherwise, parse toggle class\n      else {\n          input = this.options.toggler;\n\n          if (typeof input !== 'string' || !input.length) {\n            throw new Error(\"The 'toogler' option containing the target class is required, got \\\"\".concat(input, \"\\\"\"));\n          } // Allow for a . at the beginning of the string\n\n\n          this.className = input[0] === '.' ? input.slice(1) : input; // - aria-expanded: according to the elements class set.\n\n          $triggers.attr('aria-expanded', this.$element.hasClass(this.className));\n        } // - aria-controls: adding the element id to it if not already in it.\n\n\n      $triggers.each(function (index, trigger) {\n        var $trigger = jquery__WEBPACK_IMPORTED_MODULE_0___default()(trigger);\n        var controls = $trigger.attr('aria-controls') || '';\n        var containsId = new RegExp(\"\\\\b\".concat(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"RegExpEscape\"])(id), \"\\\\b\")).test(controls);\n        if (!containsId) $trigger.attr('aria-controls', controls ? \"\".concat(controls, \" \").concat(id) : id);\n      });\n    }\n    /**\n     * Initializes events for the toggle trigger.\n     * @function\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));\n    }\n    /**\n     * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was \"on\" or \"off\".\n     * @function\n     * @fires Toggler#on\n     * @fires Toggler#off\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();\n    }\n  }, {\n    key: \"_toggleClass\",\n    value: function _toggleClass() {\n      this.$element.toggleClass(this.className);\n      var isOn = this.$element.hasClass(this.className);\n\n      if (isOn) {\n        /**\n         * Fires if the target element has the class after a toggle.\n         * @event Toggler#on\n         */\n        this.$element.trigger('on.zf.toggler');\n      } else {\n        /**\n         * Fires if the target element does not have the class after a toggle.\n         * @event Toggler#off\n         */\n        this.$element.trigger('off.zf.toggler');\n      }\n\n      this._updateARIA(isOn);\n\n      this.$element.find('[data-mutate]').trigger('mutateme.zf.trigger');\n    }\n  }, {\n    key: \"_toggleAnimate\",\n    value: function _toggleAnimate() {\n      var _this = this;\n\n      if (this.$element.is(':hidden')) {\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_1__[\"Motion\"].animateIn(this.$element, this.animationIn, function () {\n          _this._updateARIA(true);\n\n          this.trigger('on.zf.toggler');\n          this.find('[data-mutate]').trigger('mutateme.zf.trigger');\n        });\n      } else {\n        _foundation_util_motion__WEBPACK_IMPORTED_MODULE_1__[\"Motion\"].animateOut(this.$element, this.animationOut, function () {\n          _this._updateARIA(false);\n\n          this.trigger('off.zf.toggler');\n          this.find('[data-mutate]').trigger('mutateme.zf.trigger');\n        });\n      }\n    }\n  }, {\n    key: \"_updateARIA\",\n    value: function _updateARIA(isOn) {\n      var id = this.$element[0].id;\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-open=\\\"\".concat(id, \"\\\"], [data-close=\\\"\").concat(id, \"\\\"], [data-toggle=\\\"\").concat(id, \"\\\"]\")).attr({\n        'aria-expanded': isOn ? true : false\n      });\n    }\n    /**\n     * Destroys the instance of Toggler on the element.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.off('.zf.toggler');\n    }\n  }]);\n\n  return Toggler;\n}(_foundation_core_plugin__WEBPACK_IMPORTED_MODULE_2__[\"Plugin\"]);\n\nToggler.defaults = {\n  /**\n   * Class of the element to toggle. It can be provided with or without \".\"\n   * @option\n   * @type {string}\n   */\n  toggler: undefined,\n\n  /**\n   * Tells the plugin if the element should animated when toggled.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  animate: false\n};\n\n\n//# sourceURL=webpack:///./js/foundation.toggler.js?");/***/},/***/"./js/foundation.tooltip.js":/*!**********************************!*\
	  !*** ./js/foundation.tooltip.js ***!
	  \**********************************/ /*! exports provided: Tooltip */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tooltip\", function() { return Tooltip; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.mediaQuery */ \"./js/foundation.util.mediaQuery.js\");\n/* harmony import */ var _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./foundation.util.triggers */ \"./js/foundation.util.triggers.js\");\n/* harmony import */ var _foundation_positionable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./foundation.positionable */ \"./js/foundation.positionable.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * Tooltip module.\n * @module foundation.tooltip\n * @requires foundation.util.box\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.triggers\n */\n\nvar Tooltip =\n/*#__PURE__*/\nfunction (_Positionable) {\n  _inherits(Tooltip, _Positionable);\n\n  function Tooltip() {\n    _classCallCheck(this, Tooltip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).apply(this, arguments));\n  }\n\n  _createClass(Tooltip, [{\n    key: \"_setup\",\n\n    /**\n     * Creates a new instance of a Tooltip.\n     * @class\n     * @name Tooltip\n     * @fires Tooltip#init\n     * @param {jQuery} element - jQuery object to attach a tooltip to.\n     * @param {Object} options - object to extend the default configuration.\n     */\n    value: function _setup(element, options) {\n      this.$element = element;\n      this.options = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, Tooltip.defaults, this.$element.data(), options);\n      this.className = 'Tooltip'; // ie9 back compat\n\n      this.isActive = false;\n      this.isClick = false; // Triggers init is idempotent, just need to make sure it is initialized\n\n      _foundation_util_triggers__WEBPACK_IMPORTED_MODULE_3__[\"Triggers\"].init(jquery__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n      this._init();\n    }\n    /**\n     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.\n     * @private\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"MediaQuery\"]._init();\n\n      var elemId = this.$element.attr('aria-describedby') || Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"GetYoDigits\"])(6, 'tooltip');\n      this.options.tipText = this.options.tipText || this.$element.attr('title');\n      this.template = this.options.template ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.options.template) : this._buildTemplate(elemId);\n\n      if (this.options.allowHtml) {\n        this.template.appendTo(document.body).html(this.options.tipText).hide();\n      } else {\n        this.template.appendTo(document.body).text(this.options.tipText).hide();\n      }\n\n      this.$element.attr({\n        'title': '',\n        'aria-describedby': elemId,\n        'data-yeti-box': elemId,\n        'data-toggle': elemId,\n        'data-resize': elemId\n      }).addClass(this.options.triggerClass);\n\n      _get(_getPrototypeOf(Tooltip.prototype), \"_init\", this).call(this);\n\n      this._events();\n    }\n  }, {\n    key: \"_getDefaultPosition\",\n    value: function _getDefaultPosition() {\n      // handle legacy classnames\n      var elementClassName = this.$element[0].className;\n\n      if (this.$element[0] instanceof SVGElement) {\n        elementClassName = elementClassName.baseVal;\n      }\n\n      var position = elementClassName.match(/\\b(top|left|right|bottom)\\b/g);\n      return position ? position[0] : 'top';\n    }\n  }, {\n    key: \"_getDefaultAlignment\",\n    value: function _getDefaultAlignment() {\n      return 'center';\n    }\n  }, {\n    key: \"_getHOffset\",\n    value: function _getHOffset() {\n      if (this.position === 'left' || this.position === 'right') {\n        return this.options.hOffset + this.options.tooltipWidth;\n      } else {\n        return this.options.hOffset;\n      }\n    }\n  }, {\n    key: \"_getVOffset\",\n    value: function _getVOffset() {\n      if (this.position === 'top' || this.position === 'bottom') {\n        return this.options.vOffset + this.options.tooltipHeight;\n      } else {\n        return this.options.vOffset;\n      }\n    }\n    /**\n     * builds the tooltip element, adds attributes, and returns the template.\n     * @private\n     */\n\n  }, {\n    key: \"_buildTemplate\",\n    value: function _buildTemplate(id) {\n      var templateClasses = \"\".concat(this.options.tooltipClass, \" \").concat(this.options.templateClasses).trim();\n      var $template = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div></div>').addClass(templateClasses).attr({\n        'role': 'tooltip',\n        'aria-hidden': true,\n        'data-is-active': false,\n        'data-is-focus': false,\n        'id': id\n      });\n      return $template;\n    }\n    /**\n     * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.\n     * if the tooltip is larger than the screen width, default to full width - any user selected margin\n     * @private\n     */\n\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition() {\n      _get(_getPrototypeOf(Tooltip.prototype), \"_setPosition\", this).call(this, this.$element, this.template);\n    }\n    /**\n     * reveals the tooltip, and fires an event to close any other open tooltips on the page\n     * @fires Tooltip#closeme\n     * @fires Tooltip#show\n     * @function\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.options.showOn !== 'all' && !_foundation_util_mediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"MediaQuery\"].is(this.options.showOn)) {\n        // console.error('The screen is too small to display this tooltip');\n        return false;\n      }\n\n      var _this = this;\n\n      this.template.css('visibility', 'hidden').show();\n\n      this._setPosition();\n\n      this.template.removeClass('top bottom left right').addClass(this.position);\n      this.template.removeClass('align-top align-bottom align-left align-right align-center').addClass('align-' + this.alignment);\n      /**\n       * Fires to close all other open tooltips on the page\n       * @event Closeme#tooltip\n       */\n\n      this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));\n      this.template.attr({\n        'data-is-active': true,\n        'aria-hidden': false\n      });\n      _this.isActive = true; // console.log(this.template);\n\n      this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {//maybe do stuff?\n      });\n      /**\n       * Fires when the tooltip is shown\n       * @event Tooltip#show\n       */\n\n      this.$element.trigger('show.zf.tooltip');\n    }\n    /**\n     * Hides the current tooltip, and resets the positioning class if it was changed due to collision\n     * @fires Tooltip#hide\n     * @function\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      // console.log('hiding', this.$element.data('yeti-box'));\n      var _this = this;\n\n      this.template.stop().attr({\n        'aria-hidden': true,\n        'data-is-active': false\n      }).fadeOut(this.options.fadeOutDuration, function () {\n        _this.isActive = false;\n        _this.isClick = false;\n      });\n      /**\n       * fires when the tooltip is hidden\n       * @event Tooltip#hide\n       */\n\n      this.$element.trigger('hide.zf.tooltip');\n    }\n    /**\n     * adds event listeners for the tooltip and its anchor\n     * TODO combine some of the listeners like focus and mouseenter, etc.\n     * @private\n     */\n\n  }, {\n    key: \"_events\",\n    value: function _events() {\n      var _this = this;\n\n      var hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined';\n      var $template = this.template;\n      var isFocus = false; // `disableForTouch: Fully disable the tooltip on touch devices\n\n      if (hasTouch && this.options.disableForTouch) return;\n\n      if (!this.options.disableHover) {\n        this.$element.on('mouseenter.zf.tooltip', function (e) {\n          if (!_this.isActive) {\n            _this.timeout = setTimeout(function () {\n              _this.show();\n            }, _this.options.hoverDelay);\n          }\n        }).on('mouseleave.zf.tooltip', Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"ignoreMousedisappear\"])(function (e) {\n          clearTimeout(_this.timeout);\n\n          if (!isFocus || _this.isClick && !_this.options.clickOpen) {\n            _this.hide();\n          }\n        }));\n      }\n\n      if (hasTouch) {\n        this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {\n          _this.isActive ? _this.hide() : _this.show();\n        });\n      }\n\n      if (this.options.clickOpen) {\n        this.$element.on('mousedown.zf.tooltip', function (e) {\n          if (_this.isClick) {//_this.hide();\n            // _this.isClick = false;\n          } else {\n            _this.isClick = true;\n\n            if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {\n              _this.show();\n            }\n          }\n        });\n      } else {\n        this.$element.on('mousedown.zf.tooltip', function (e) {\n          _this.isClick = true;\n        });\n      }\n\n      this.$element.on({\n        // 'toggle.zf.trigger': this.toggle.bind(this),\n        // 'close.zf.trigger': this.hide.bind(this)\n        'close.zf.trigger': this.hide.bind(this)\n      });\n      this.$element.on('focus.zf.tooltip', function (e) {\n        isFocus = true;\n\n        if (_this.isClick) {\n          // If we're not showing open on clicks, we need to pretend a click-launched focus isn't\n          // a real focus, otherwise on hover and come back we get bad behavior\n          if (!_this.options.clickOpen) {\n            isFocus = false;\n          }\n\n          return false;\n        } else {\n          _this.show();\n        }\n      }).on('focusout.zf.tooltip', function (e) {\n        isFocus = false;\n        _this.isClick = false;\n\n        _this.hide();\n      }).on('resizeme.zf.trigger', function () {\n        if (_this.isActive) {\n          _this._setPosition();\n        }\n      });\n    }\n    /**\n     * adds a toggle method, in addition to the static show() & hide() functions\n     * @function\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (this.isActive) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n    /**\n     * Destroys an instance of tooltip, removes template element from the view.\n     * @function\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tooltip').removeClass(this.options.triggerClass).removeClass('top right left bottom').removeAttr('aria-describedby data-disable-hover data-resize data-toggle data-tooltip data-yeti-box');\n      this.template.remove();\n    }\n  }]);\n\n  return Tooltip;\n}(_foundation_positionable__WEBPACK_IMPORTED_MODULE_4__[\"Positionable\"]);\n\nTooltip.defaults = {\n  /**\n   * Time, in ms, before a tooltip should open on hover.\n   * @option\n   * @type {number}\n   * @default 200\n   */\n  hoverDelay: 200,\n\n  /**\n   * Time, in ms, a tooltip should take to fade into view.\n   * @option\n   * @type {number}\n   * @default 150\n   */\n  fadeInDuration: 150,\n\n  /**\n   * Time, in ms, a tooltip should take to fade out of view.\n   * @option\n   * @type {number}\n   * @default 150\n   */\n  fadeOutDuration: 150,\n\n  /**\n   * Disables hover events from opening the tooltip if set to true\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  disableHover: false,\n\n  /**\n   * Disable the tooltip for touch devices.\n   * This can be useful to make elements with a tooltip on it trigger their\n   * action on the first tap instead of displaying the tooltip.\n   * @option\n   * @type {booelan}\n   * @default false\n   */\n  disableForTouch: false,\n\n  /**\n   * Optional addtional classes to apply to the tooltip template on init.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  templateClasses: '',\n\n  /**\n   * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.\n   * @option\n   * @type {string}\n   * @default 'tooltip'\n   */\n  tooltipClass: 'tooltip',\n\n  /**\n   * Class applied to the tooltip anchor element.\n   * @option\n   * @type {string}\n   * @default 'has-tip'\n   */\n  triggerClass: 'has-tip',\n\n  /**\n   * Minimum breakpoint size at which to open the tooltip.\n   * @option\n   * @type {string}\n   * @default 'small'\n   */\n  showOn: 'small',\n\n  /**\n   * Custom template to be used to generate markup for tooltip.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  template: '',\n\n  /**\n   * Text displayed in the tooltip template on open.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  tipText: '',\n  touchCloseText: 'Tap to close.',\n\n  /**\n   * Allows the tooltip to remain open if triggered with a click or touch event.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  clickOpen: true,\n\n  /**\n   * Position of tooltip. Can be left, right, bottom, top, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  position: 'auto',\n\n  /**\n   * Alignment of tooltip relative to anchor. Can be left, right, bottom, top, center, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  alignment: 'auto',\n\n  /**\n   * Allow overlap of container/window. If false, tooltip will first try to\n   * position as defined by data-position and data-alignment, but reposition if\n   * it would cause an overflow.  @option\n   * @type {boolean}\n   * @default false\n   */\n  allowOverlap: false,\n\n  /**\n   * Allow overlap of only the bottom of the container. This is the most common\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\n   * screen but not otherwise influence or break out of the container.\n   * Less common for tooltips.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  allowBottomOverlap: false,\n\n  /**\n   * Distance, in pixels, the template should push away from the anchor on the Y axis.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  vOffset: 0,\n\n  /**\n   * Distance, in pixels, the template should push away from the anchor on the X axis\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  hOffset: 0,\n\n  /**\n   * Distance, in pixels, the template spacing auto-adjust for a vertical tooltip\n   * @option\n   * @type {number}\n   * @default 14\n   */\n  tooltipHeight: 14,\n\n  /**\n   * Distance, in pixels, the template spacing auto-adjust for a horizontal tooltip\n   * @option\n   * @type {number}\n   * @default 12\n   */\n  tooltipWidth: 12,\n\n  /**\n  * Allow HTML in tooltip. Warning: If you are loading user-generated content into tooltips,\n  * allowing HTML may open yourself up to XSS attacks.\n  * @option\n  * @type {boolean}\n  * @default false\n  */\n  allowHtml: false\n};\n/**\n * TODO utilize resize event trigger\n */\n\n\n\n//# sourceURL=webpack:///./js/foundation.tooltip.js?");/***/},/***/"./js/foundation.util.box.js":/*!***********************************!*\
	  !*** ./js/foundation.util.box.js ***!
	  \***********************************/ /*! exports provided: Box */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box\", function() { return Box; });\n\n\nvar Box = {\n  ImNotTouchingYou: ImNotTouchingYou,\n  OverlapArea: OverlapArea,\n  GetDimensions: GetDimensions,\n  GetExplicitOffsets: GetExplicitOffsets\n  /**\n   * Compares the dimensions of an element to a container and determines collision events with container.\n   * @function\n   * @param {jQuery} element - jQuery object to test for collisions.\n   * @param {jQuery} parent - jQuery object to use as bounding container.\n   * @param {Boolean} lrOnly - set to true to check left and right values only.\n   * @param {Boolean} tbOnly - set to true to check top and bottom values only.\n   * @default if no parent object passed, detects collisions with `window`.\n   * @returns {Boolean} - true if collision free, false if a collision in any direction.\n   */\n\n};\n\nfunction ImNotTouchingYou(element, parent, lrOnly, tbOnly, ignoreBottom) {\n  return OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) === 0;\n}\n\nfunction OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) {\n  var eleDims = GetDimensions(element),\n      topOver,\n      bottomOver,\n      leftOver,\n      rightOver;\n\n  if (parent) {\n    var parDims = GetDimensions(parent);\n    bottomOver = parDims.height + parDims.offset.top - (eleDims.offset.top + eleDims.height);\n    topOver = eleDims.offset.top - parDims.offset.top;\n    leftOver = eleDims.offset.left - parDims.offset.left;\n    rightOver = parDims.width + parDims.offset.left - (eleDims.offset.left + eleDims.width);\n  } else {\n    bottomOver = eleDims.windowDims.height + eleDims.windowDims.offset.top - (eleDims.offset.top + eleDims.height);\n    topOver = eleDims.offset.top - eleDims.windowDims.offset.top;\n    leftOver = eleDims.offset.left - eleDims.windowDims.offset.left;\n    rightOver = eleDims.windowDims.width - (eleDims.offset.left + eleDims.width);\n  }\n\n  bottomOver = ignoreBottom ? 0 : Math.min(bottomOver, 0);\n  topOver = Math.min(topOver, 0);\n  leftOver = Math.min(leftOver, 0);\n  rightOver = Math.min(rightOver, 0);\n\n  if (lrOnly) {\n    return leftOver + rightOver;\n  }\n\n  if (tbOnly) {\n    return topOver + bottomOver;\n  } // use sum of squares b/c we care about overlap area.\n\n\n  return Math.sqrt(topOver * topOver + bottomOver * bottomOver + leftOver * leftOver + rightOver * rightOver);\n}\n/**\n * Uses native methods to return an object of dimension values.\n * @function\n * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\n * @returns {Object} - nested object of integer pixel values\n * TODO - if element is window, return only those values.\n */\n\n\nfunction GetDimensions(elem) {\n  elem = elem.length ? elem[0] : elem;\n\n  if (elem === window || elem === document) {\n    throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");\n  }\n\n  var rect = elem.getBoundingClientRect(),\n      parRect = elem.parentNode.getBoundingClientRect(),\n      winRect = document.body.getBoundingClientRect(),\n      winY = window.pageYOffset,\n      winX = window.pageXOffset;\n  return {\n    width: rect.width,\n    height: rect.height,\n    offset: {\n      top: rect.top + winY,\n      left: rect.left + winX\n    },\n    parentDims: {\n      width: parRect.width,\n      height: parRect.height,\n      offset: {\n        top: parRect.top + winY,\n        left: parRect.left + winX\n      }\n    },\n    windowDims: {\n      width: winRect.width,\n      height: winRect.height,\n      offset: {\n        top: winY,\n        left: winX\n      }\n    }\n  };\n}\n/**\n * Returns an object of top and left integer pixel values for dynamically rendered elements,\n * such as: Tooltip, Reveal, and Dropdown. Maintained for backwards compatibility, and where\n * you don't know alignment, but generally from\n * 6.4 forward you should use GetExplicitOffsets, as GetOffsets conflates position and alignment.\n * @function\n * @param {jQuery} element - jQuery object for the element being positioned.\n * @param {jQuery} anchor - jQuery object for the element's anchor point.\n * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\n * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\n * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\n * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\n * TODO alter/rewrite to work with `em` values as well/instead of pixels\n */\n\n\nfunction GetExplicitOffsets(element, anchor, position, alignment, vOffset, hOffset, isOverflow) {\n  var $eleDims = GetDimensions(element),\n      $anchorDims = anchor ? GetDimensions(anchor) : null;\n  var topVal, leftVal;\n\n  if ($anchorDims !== null) {\n    // set position related attribute\n    switch (position) {\n      case 'top':\n        topVal = $anchorDims.offset.top - ($eleDims.height + vOffset);\n        break;\n\n      case 'bottom':\n        topVal = $anchorDims.offset.top + $anchorDims.height + vOffset;\n        break;\n\n      case 'left':\n        leftVal = $anchorDims.offset.left - ($eleDims.width + hOffset);\n        break;\n\n      case 'right':\n        leftVal = $anchorDims.offset.left + $anchorDims.width + hOffset;\n        break;\n    } // set alignment related attribute\n\n\n    switch (position) {\n      case 'top':\n      case 'bottom':\n        switch (alignment) {\n          case 'left':\n            leftVal = $anchorDims.offset.left + hOffset;\n            break;\n\n          case 'right':\n            leftVal = $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset;\n            break;\n\n          case 'center':\n            leftVal = isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2 + hOffset;\n            break;\n        }\n\n        break;\n\n      case 'right':\n      case 'left':\n        switch (alignment) {\n          case 'bottom':\n            topVal = $anchorDims.offset.top - vOffset + $anchorDims.height - $eleDims.height;\n            break;\n\n          case 'top':\n            topVal = $anchorDims.offset.top + vOffset;\n            break;\n\n          case 'center':\n            topVal = $anchorDims.offset.top + vOffset + $anchorDims.height / 2 - $eleDims.height / 2;\n            break;\n        }\n\n        break;\n    }\n  }\n\n  return {\n    top: topVal,\n    left: leftVal\n  };\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.box.js?");/***/},/***/"./js/foundation.util.imageLoader.js":/*!*******************************************!*\
	  !*** ./js/foundation.util.imageLoader.js ***!
	  \*******************************************/ /*! exports provided: onImagesLoaded */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onImagesLoaded\", function() { return onImagesLoaded; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n/**\n * Runs a callback function when images are fully loaded.\n * @param {Object} images - Image(s) to check if loaded.\n * @param {Func} callback - Function to execute when image is fully loaded.\n */\n\nfunction onImagesLoaded(images, callback) {\n  var self = this,\n      unloaded = images.length;\n\n  if (unloaded === 0) {\n    callback();\n  }\n\n  images.each(function () {\n    // Check if image is loaded\n    if (this.complete && typeof this.naturalWidth !== 'undefined') {\n      singleImageLoaded();\n    } else {\n      // If the above check failed, simulate loading on detached element.\n      var image = new Image(); // Still count image as loaded if it finalizes with an error.\n\n      var events = \"load.zf.images error.zf.images\";\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(image).one(events, function me(event) {\n        // Unbind the event listeners. We're using 'one' but only one of the two events will have fired.\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).off(events, me);\n        singleImageLoaded();\n      });\n      image.src = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('src');\n    }\n  });\n\n  function singleImageLoaded() {\n    unloaded--;\n\n    if (unloaded === 0) {\n      callback();\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.imageLoader.js?");/***/},/***/"./js/foundation.util.keyboard.js":/*!****************************************!*\
	  !*** ./js/foundation.util.keyboard.js ***!
	  \****************************************/ /*! exports provided: Keyboard */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Keyboard\", function() { return Keyboard; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/*******************************************\n *                                         *\n * This util was created by Marius Olbertz *\n * Please thank Marius on GitHub /owlbertz *\n * or the web http://www.mariusolbertz.de/ *\n *                                         *\n ******************************************/\n\n\n\n\nvar keyCodes = {\n  9: 'TAB',\n  13: 'ENTER',\n  27: 'ESCAPE',\n  32: 'SPACE',\n  35: 'END',\n  36: 'HOME',\n  37: 'ARROW_LEFT',\n  38: 'ARROW_UP',\n  39: 'ARROW_RIGHT',\n  40: 'ARROW_DOWN'\n};\nvar commands = {}; // Functions pulled out to be referenceable from internals\n\nfunction findFocusable($element) {\n  if (!$element) {\n    return false;\n  }\n\n  return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\n    if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).is(':visible') || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('tabindex') < 0) {\n      return false;\n    } //only have visible elements and those that have a tabindex greater or equal 0\n\n\n    return true;\n  });\n}\n\nfunction parseKey(event) {\n  var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase(); // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events\n\n  key = key.replace(/\\W+/, '');\n  if (event.shiftKey) key = \"SHIFT_\".concat(key);\n  if (event.ctrlKey) key = \"CTRL_\".concat(key);\n  if (event.altKey) key = \"ALT_\".concat(key); // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)\n\n  key = key.replace(/_$/, '');\n  return key;\n}\n\nvar Keyboard = {\n  keys: getKeyCodes(keyCodes),\n\n  /**\n   * Parses the (keyboard) event and returns a String that represents its key\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n   * @param {Event} event - the event generated by the event handler\n   * @return String key - String that represents the key pressed\n   */\n  parseKey: parseKey,\n\n  /**\n   * Handles the given (keyboard) event\n   * @param {Event} event - the event generated by the event handler\n   * @param {String} component - Foundation component's name, e.g. Slider or Reveal\n   * @param {Objects} functions - collection of functions that are to be executed\n   */\n  handleKey: function handleKey(event, component, functions) {\n    var commandList = commands[component],\n        keyCode = this.parseKey(event),\n        cmds,\n        command,\n        fn;\n    if (!commandList) return console.warn('Component not defined!'); // Ignore the event if it was already handled\n\n    if (event.zfIsKeyHandled === true) return; // This component does not differentiate between ltr and rtl\n\n    if (typeof commandList.ltr === 'undefined') {\n      cmds = commandList; // use plain list\n    } else {\n      // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\n      if (Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"rtl\"])()) cmds = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, commandList.ltr, commandList.rtl);else cmds = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, commandList.rtl, commandList.ltr);\n    }\n\n    command = cmds[keyCode];\n    fn = functions[command]; // Execute the handler if found\n\n    if (fn && typeof fn === 'function') {\n      var returnValue = fn.apply(); // Mark the event as \"handled\" to prevent future handlings\n\n      event.zfIsKeyHandled = true; // Execute function when event was handled\n\n      if (functions.handled || typeof functions.handled === 'function') {\n        functions.handled(returnValue);\n      }\n    } else {\n      // Execute function when event was not handled\n      if (functions.unhandled || typeof functions.unhandled === 'function') {\n        functions.unhandled();\n      }\n    }\n  },\n\n  /**\n   * Finds all focusable elements within the given `$element`\n   * @param {jQuery} $element - jQuery object to search within\n   * @return {jQuery} $focusable - all focusable elements within `$element`\n   */\n  findFocusable: findFocusable,\n\n  /**\n   * Returns the component name name\n   * @param {Object} component - Foundation component, e.g. Slider or Reveal\n   * @return String componentName\n   */\n  register: function register(componentName, cmds) {\n    commands[componentName] = cmds;\n  },\n  // TODO9438: These references to Keyboard need to not require global. Will 'this' work in this context?\n  //\n\n  /**\n   * Traps the focus in the given element.\n   * @param  {jQuery} $element  jQuery object to trap the foucs into.\n   */\n  trapFocus: function trapFocus($element) {\n    var $focusable = findFocusable($element),\n        $firstFocusable = $focusable.eq(0),\n        $lastFocusable = $focusable.eq(-1);\n    $element.on('keydown.zf.trapfocus', function (event) {\n      if (event.target === $lastFocusable[0] && parseKey(event) === 'TAB') {\n        event.preventDefault();\n        $firstFocusable.focus();\n      } else if (event.target === $firstFocusable[0] && parseKey(event) === 'SHIFT_TAB') {\n        event.preventDefault();\n        $lastFocusable.focus();\n      }\n    });\n  },\n\n  /**\n   * Releases the trapped focus from the given element.\n   * @param  {jQuery} $element  jQuery object to release the focus for.\n   */\n  releaseFocus: function releaseFocus($element) {\n    $element.off('keydown.zf.trapfocus');\n  }\n};\n/*\n * Constants for easier comparing.\n * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n */\n\nfunction getKeyCodes(kcs) {\n  var k = {};\n\n  for (var kc in kcs) {\n    k[kcs[kc]] = kcs[kc];\n  }\n\n  return k;\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.keyboard.js?");/***/},/***/"./js/foundation.util.mediaQuery.js":/*!******************************************!*\
	  !*** ./js/foundation.util.mediaQuery.js ***!
	  \******************************************/ /*! exports provided: MediaQuery */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MediaQuery\", function() { return MediaQuery; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n // Default set of media queries\n\nvar defaultQueries = {\n  'default': 'only screen',\n  landscape: 'only screen and (orientation: landscape)',\n  portrait: 'only screen and (orientation: portrait)',\n  retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\n}; // matchMedia() polyfill - Test a CSS media type/query in JS.\n// Authors & copyright © 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license\n\n/* eslint-disable */\n\nwindow.matchMedia || (window.matchMedia = function () {\n  \"use strict\"; // For browsers that support matchMedium api such as IE 9 and webkit\n\n  var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium\n\n  if (!styleMedia) {\n    var style = document.createElement('style'),\n        script = document.getElementsByTagName('script')[0],\n        info = null;\n    style.type = 'text/css';\n    style.id = 'matchmediajs-test';\n\n    if (!script) {\n      document.head.appendChild(style);\n    } else {\n      script.parentNode.insertBefore(style, script);\n    } // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n\n\n    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\n    styleMedia = {\n      matchMedium: function matchMedium(media) {\n        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }'; // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n\n        if (style.styleSheet) {\n          style.styleSheet.cssText = text;\n        } else {\n          style.textContent = text;\n        } // Test if media query is true or false\n\n\n        return info.width === '1px';\n      }\n    };\n  }\n\n  return function (media) {\n    return {\n      matches: styleMedia.matchMedium(media || 'all'),\n      media: media || 'all'\n    };\n  };\n}());\n/* eslint-enable */\n\nvar MediaQuery = {\n  queries: [],\n  current: '',\n\n  /**\n   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\n   * @function\n   * @private\n   */\n  _init: function _init() {\n    // make sure the initialization is only done once when calling _init() several times\n    if (this.isInitialized === true) {\n      return;\n    } else {\n      this.isInitialized = true;\n    }\n\n    var self = this;\n    var $meta = jquery__WEBPACK_IMPORTED_MODULE_0___default()('meta.foundation-mq');\n\n    if (!$meta.length) {\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()('<meta class=\"foundation-mq\">').appendTo(document.head);\n    }\n\n    var extractedStyles = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.foundation-mq').css('font-family');\n    var namedQueries;\n    namedQueries = parseStyleToObject(extractedStyles);\n    self.queries = []; // reset\n\n    for (var key in namedQueries) {\n      if (namedQueries.hasOwnProperty(key)) {\n        self.queries.push({\n          name: key,\n          value: \"only screen and (min-width: \".concat(namedQueries[key], \")\")\n        });\n      }\n    }\n\n    this.current = this._getCurrentSize();\n\n    this._watcher();\n  },\n\n  /**\n   * Reinitializes the media query helper.\n   * Useful if your CSS breakpoint configuration has just been loaded or has changed since the initialization.\n   * @function\n   * @private\n   */\n  _reInit: function _reInit() {\n    this.isInitialized = false;\n\n    this._init();\n  },\n\n  /**\n   * Checks if the screen is at least as wide as a breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint to check.\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\n   */\n  atLeast: function atLeast(size) {\n    var query = this.get(size);\n\n    if (query) {\n      return window.matchMedia(query).matches;\n    }\n\n    return false;\n  },\n\n  /**\n   * Checks if the screen is within the given breakpoint.\n   * If smaller than the breakpoint of larger than its upper limit it returns false.\n   * @function\n   * @param {String} size - Name of the breakpoint to check.\n   * @returns {Boolean} `true` if the breakpoint matches, `false` otherwise.\n   */\n  only: function only(size) {\n    return size === this._getCurrentSize();\n  },\n\n  /**\n   * Checks if the screen is within a breakpoint or smaller.\n   * @function\n   * @param {String} size - Name of the breakpoint to check.\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's larger.\n   */\n  upTo: function upTo(size) {\n    var nextSize = this.next(size); // If the next breakpoint does not match, the screen is smaller than\n    // the upper limit of this breakpoint.\n\n    if (nextSize) {\n      return !this.atLeast(nextSize);\n    } // If there is no next breakpoint, the \"size\" breakpoint does not have\n    // an upper limit and the screen will always be within it or smaller.\n\n\n    return true;\n  },\n\n  /**\n   * Checks if the screen matches to a breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.\n   */\n  is: function is(size) {\n    var parts = size.trim().split(' ').filter(function (p) {\n      return !!p.length;\n    });\n\n    var _parts = _slicedToArray(parts, 2),\n        bpSize = _parts[0],\n        _parts$ = _parts[1],\n        bpModifier = _parts$ === void 0 ? '' : _parts$; // Only the breakpont\n\n\n    if (bpModifier === 'only') {\n      return this.only(bpSize);\n    } // At least the breakpoint (included)\n\n\n    if (!bpModifier || bpModifier === 'up') {\n      return this.atLeast(bpSize);\n    } // Up to the breakpoint (included)\n\n\n    if (bpModifier === 'down') {\n      return this.upTo(bpSize);\n    }\n\n    throw new Error(\"\\n      Invalid breakpoint passed to MediaQuery.is().\\n      Expected a breakpoint name formatted like \\\"<size> <modifier>\\\", got \\\"\".concat(size, \"\\\".\\n    \"));\n  },\n\n  /**\n   * Gets the media query of a breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint to get.\n   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\n   */\n  get: function get(size) {\n    for (var i in this.queries) {\n      if (this.queries.hasOwnProperty(i)) {\n        var query = this.queries[i];\n        if (size === query.name) return query.value;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Get the breakpoint following the given breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint.\n   * @returns {String|null} - The name of the following breakpoint, or `null` if the passed breakpoint was the last one.\n   */\n  next: function next(size) {\n    var _this = this;\n\n    var queryIndex = this.queries.findIndex(function (q) {\n      return _this._getQueryName(q) === size;\n    });\n\n    if (queryIndex === -1) {\n      throw new Error(\"\\n        Unknown breakpoint \\\"\".concat(size, \"\\\" passed to MediaQuery.next().\\n        Ensure it is present in your Sass \\\"$breakpoints\\\" setting.\\n      \"));\n    }\n\n    var nextQuery = this.queries[queryIndex + 1];\n    return nextQuery ? nextQuery.name : null;\n  },\n\n  /**\n   * Returns the name of the breakpoint related to the given value.\n   * @function\n   * @private\n   * @param {String|Object} value - Breakpoint name or query object.\n   * @returns {String} Name of the breakpoint.\n   */\n  _getQueryName: function _getQueryName(value) {\n    if (typeof value === 'string') return value;\n    if (_typeof(value) === 'object') return value.name;\n    throw new TypeError(\"\\n      Invalid value passed to MediaQuery._getQueryName().\\n      Expected a breakpoint name (String) or a breakpoint query (Object), got \\\"\".concat(value, \"\\\" (\").concat(_typeof(value), \")\\n    \"));\n  },\n\n  /**\n   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\n   * @function\n   * @private\n   * @returns {String} Name of the current breakpoint.\n   */\n  _getCurrentSize: function _getCurrentSize() {\n    var matched;\n\n    for (var i = 0; i < this.queries.length; i++) {\n      var query = this.queries[i];\n\n      if (window.matchMedia(query.value).matches) {\n        matched = query;\n      }\n    }\n\n    return matched && this._getQueryName(matched);\n  },\n\n  /**\n   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\n   * @function\n   * @private\n   */\n  _watcher: function _watcher() {\n    var _this2 = this;\n\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off('resize.zf.mediaquery').on('resize.zf.mediaquery', function () {\n      var newSize = _this2._getCurrentSize(),\n          currentSize = _this2.current;\n\n      if (newSize !== currentSize) {\n        // Change the current media query\n        _this2.current = newSize; // Broadcast the media query change on the window\n\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\n      }\n    });\n  }\n}; // Thank you: https://github.com/sindresorhus/query-string\n\nfunction parseStyleToObject(str) {\n  var styleObject = {};\n\n  if (typeof str !== 'string') {\n    return styleObject;\n  }\n\n  str = str.trim().slice(1, -1); // browsers re-quote string style values\n\n  if (!str) {\n    return styleObject;\n  }\n\n  styleObject = str.split('&').reduce(function (ret, param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = parts[0];\n    var val = parts[1];\n    key = decodeURIComponent(key); // missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\n    val = typeof val === 'undefined' ? null : decodeURIComponent(val);\n\n    if (!ret.hasOwnProperty(key)) {\n      ret[key] = val;\n    } else if (Array.isArray(ret[key])) {\n      ret[key].push(val);\n    } else {\n      ret[key] = [ret[key], val];\n    }\n\n    return ret;\n  }, {});\n  return styleObject;\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.mediaQuery.js?");/***/},/***/"./js/foundation.util.motion.js":/*!**************************************!*\
	  !*** ./js/foundation.util.motion.js ***!
	  \**************************************/ /*! exports provided: Move, Motion */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Move\", function() { return Move; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Motion\", function() { return Motion; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n\n\n\n\n/**\n * Motion module.\n * @module foundation.motion\n */\n\nvar initClasses = ['mui-enter', 'mui-leave'];\nvar activeClasses = ['mui-enter-active', 'mui-leave-active'];\nvar Motion = {\n  animateIn: function animateIn(element, animation, cb) {\n    animate(true, element, animation, cb);\n  },\n  animateOut: function animateOut(element, animation, cb) {\n    animate(false, element, animation, cb);\n  }\n};\n\nfunction Move(duration, elem, fn) {\n  var anim,\n      prog,\n      start = null; // console.log('called');\n\n  if (duration === 0) {\n    fn.apply(elem);\n    elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n    return;\n  }\n\n  function move(ts) {\n    if (!start) start = ts; // console.log(start, ts);\n\n    prog = ts - start;\n    fn.apply(elem);\n\n    if (prog < duration) {\n      anim = window.requestAnimationFrame(move, elem);\n    } else {\n      window.cancelAnimationFrame(anim);\n      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n    }\n  }\n\n  anim = window.requestAnimationFrame(move);\n}\n/**\n * Animates an element in or out using a CSS transition class.\n * @function\n * @private\n * @param {Boolean} isIn - Defines if the animation is in or out.\n * @param {Object} element - jQuery or HTML object to animate.\n * @param {String} animation - CSS class to use.\n * @param {Function} cb - Callback to run when animation is finished.\n */\n\n\nfunction animate(isIn, element, animation, cb) {\n  element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).eq(0);\n  if (!element.length) return;\n  var initClass = isIn ? initClasses[0] : initClasses[1];\n  var activeClass = isIn ? activeClasses[0] : activeClasses[1]; // Set up the animation\n\n  reset();\n  element.addClass(animation).css('transition', 'none');\n  requestAnimationFrame(function () {\n    element.addClass(initClass);\n    if (isIn) element.show();\n  }); // Start the animation\n\n  requestAnimationFrame(function () {\n    // will trigger the browser to synchronously calculate the style and layout\n    // also called reflow or layout thrashing\n    // see https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n    element[0].offsetWidth;\n    element.css('transition', '').addClass(activeClass);\n  }); // Clean up the animation when it finishes\n\n  element.one(Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"transitionend\"])(element), finish); // Hides the element (for out animations), resets the element, and runs a callback\n\n  function finish() {\n    if (!isIn) element.hide();\n    reset();\n    if (cb) cb.apply(element);\n  } // Resets transitions and removes motion-specific classes\n\n\n  function reset() {\n    element[0].style.transitionDuration = 0;\n    element.removeClass(\"\".concat(initClass, \" \").concat(activeClass, \" \").concat(animation));\n  }\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.motion.js?");/***/},/***/"./js/foundation.util.nest.js":/*!************************************!*\
	  !*** ./js/foundation.util.nest.js ***!
	  \************************************/ /*! exports provided: Nest */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Nest\", function() { return Nest; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nvar Nest = {\n  Feather: function Feather(menu) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';\n    menu.attr('role', 'menubar');\n    menu.find('a').attr({\n      'role': 'menuitem'\n    });\n    var items = menu.find('li').attr({\n      'role': 'none'\n    }),\n        subMenuClass = \"is-\".concat(type, \"-submenu\"),\n        subItemClass = \"\".concat(subMenuClass, \"-item\"),\n        hasSubClass = \"is-\".concat(type, \"-submenu-parent\"),\n        applyAria = type !== 'accordion'; // Accordions handle their own ARIA attriutes.\n\n    items.each(function () {\n      var $item = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this),\n          $sub = $item.children('ul');\n\n      if ($sub.length) {\n        $item.addClass(hasSubClass);\n\n        if (applyAria) {\n          $item.attr({\n            'aria-haspopup': true,\n            'aria-label': $item.children('a:first').text()\n          }); // Note:  Drilldowns behave differently in how they hide, and so need\n          // additional attributes.  We should look if this possibly over-generalized\n          // utility (Nest) is appropriate when we rework menus in 6.4\n\n          if (type === 'drilldown') {\n            $item.attr({\n              'aria-expanded': false\n            });\n          }\n        }\n\n        $sub.addClass(\"submenu \".concat(subMenuClass)).attr({\n          'data-submenu': '',\n          'role': 'menubar'\n        });\n\n        if (type === 'drilldown') {\n          $sub.attr({\n            'aria-hidden': true\n          });\n        }\n      }\n\n      if ($item.parent('[data-submenu]').length) {\n        $item.addClass(\"is-submenu-item \".concat(subItemClass));\n      }\n    });\n    return;\n  },\n  Burn: function Burn(menu, type) {\n    var //items = menu.find('li'),\n    subMenuClass = \"is-\".concat(type, \"-submenu\"),\n        subItemClass = \"\".concat(subMenuClass, \"-item\"),\n        hasSubClass = \"is-\".concat(type, \"-submenu-parent\");\n    menu.find('>li, > li > ul, .menu, .menu > li, [data-submenu] > li').removeClass(\"\".concat(subMenuClass, \" \").concat(subItemClass, \" \").concat(hasSubClass, \" is-submenu-item submenu is-active\")).removeAttr('data-submenu').css('display', '');\n  }\n};\n\n\n//# sourceURL=webpack:///./js/foundation.util.nest.js?");/***/},/***/"./js/foundation.util.timer.js":/*!*************************************!*\
	  !*** ./js/foundation.util.timer.js ***!
	  \*************************************/ /*! exports provided: Timer */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Timer\", function() { return Timer; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\nfunction Timer(elem, options, cb) {\n  var _this = this,\n      duration = options.duration,\n      //options is an object for easily adding features later.\n  nameSpace = Object.keys(elem.data())[0] || 'timer',\n      remain = -1,\n      start,\n      timer;\n\n  this.isPaused = false;\n\n  this.restart = function () {\n    remain = -1;\n    clearTimeout(timer);\n    this.start();\n  };\n\n  this.start = function () {\n    this.isPaused = false; // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\n\n    clearTimeout(timer);\n    remain = remain <= 0 ? duration : remain;\n    elem.data('paused', false);\n    start = Date.now();\n    timer = setTimeout(function () {\n      if (options.infinite) {\n        _this.restart(); //rerun the timer.\n\n      }\n\n      if (cb && typeof cb === 'function') {\n        cb();\n      }\n    }, remain);\n    elem.trigger(\"timerstart.zf.\".concat(nameSpace));\n  };\n\n  this.pause = function () {\n    this.isPaused = true; //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\n\n    clearTimeout(timer);\n    elem.data('paused', true);\n    var end = Date.now();\n    remain = remain - (end - start);\n    elem.trigger(\"timerpaused.zf.\".concat(nameSpace));\n  };\n}\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.timer.js?");/***/},/***/"./js/foundation.util.touch.js":/*!*************************************!*\
	  !*** ./js/foundation.util.touch.js ***!
	  \*************************************/ /*! exports provided: Touch */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Touch\", function() { return Touch; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//**************************************************\n//**Work inspired by multiple jquery swipe plugins**\n//**Done by Yohai Ararat ***************************\n//**************************************************\n\nvar Touch = {};\nvar startPosX,\n    startPosY,\n    startTime,\n    elapsedTime,\n    startEvent,\n    isMoving = false,\n    didMoved = false;\n\nfunction onTouchEnd(e) {\n  this.removeEventListener('touchmove', onTouchMove);\n  this.removeEventListener('touchend', onTouchEnd); // If the touch did not move, consider it as a \"tap\"\n\n  if (!didMoved) {\n    var tapEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event('tap', startEvent || e);\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger(tapEvent);\n  }\n\n  startEvent = null;\n  isMoving = false;\n  didMoved = false;\n}\n\nfunction onTouchMove(e) {\n  if (jquery__WEBPACK_IMPORTED_MODULE_0___default.a.spotSwipe.preventDefault) {\n    e.preventDefault();\n  }\n\n  if (isMoving) {\n    var x = e.touches[0].pageX;\n    var y = e.touches[0].pageY;\n    var dx = startPosX - x;\n    var dy = startPosY - y;\n    var dir;\n    didMoved = true;\n    elapsedTime = new Date().getTime() - startTime;\n\n    if (Math.abs(dx) >= jquery__WEBPACK_IMPORTED_MODULE_0___default.a.spotSwipe.moveThreshold && elapsedTime <= jquery__WEBPACK_IMPORTED_MODULE_0___default.a.spotSwipe.timeThreshold) {\n      dir = dx > 0 ? 'left' : 'right';\n    } // else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\n    //   dir = dy > 0 ? 'down' : 'up';\n    // }\n\n\n    if (dir) {\n      e.preventDefault();\n      onTouchEnd.apply(this, arguments);\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event('swipe', Object.assign({}, e)), dir).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(\"swipe\".concat(dir), Object.assign({}, e)));\n    }\n  }\n}\n\nfunction onTouchStart(e) {\n  if (e.touches.length == 1) {\n    startPosX = e.touches[0].pageX;\n    startPosY = e.touches[0].pageY;\n    startEvent = e;\n    isMoving = true;\n    didMoved = false;\n    startTime = new Date().getTime();\n    this.addEventListener('touchmove', onTouchMove, false);\n    this.addEventListener('touchend', onTouchEnd, false);\n  }\n}\n\nfunction init() {\n  this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);\n}\n\nfunction teardown() {\n  this.removeEventListener('touchstart', onTouchStart);\n}\n\nvar SpotSwipe =\n/*#__PURE__*/\nfunction () {\n  function SpotSwipe($) {\n    _classCallCheck(this, SpotSwipe);\n\n    this.version = '1.0.0';\n    this.enabled = 'ontouchstart' in document.documentElement;\n    this.preventDefault = false;\n    this.moveThreshold = 75;\n    this.timeThreshold = 200;\n    this.$ = $;\n\n    this._init();\n  }\n\n  _createClass(SpotSwipe, [{\n    key: \"_init\",\n    value: function _init() {\n      var $ = this.$;\n      $.event.special.swipe = {\n        setup: init\n      };\n      $.event.special.tap = {\n        setup: init\n      };\n      $.each(['left', 'up', 'down', 'right'], function () {\n        $.event.special[\"swipe\".concat(this)] = {\n          setup: function setup() {\n            $(this).on('swipe', $.noop);\n          }\n        };\n      });\n    }\n  }]);\n\n  return SpotSwipe;\n}();\n/****************************************************\n * As far as I can tell, both setupSpotSwipe and    *\n * setupTouchHandler should be idempotent,          *\n * because they directly replace functions &        *\n * values, and do not add event handlers directly.  *\n ****************************************************/\n\n\nTouch.setupSpotSwipe = function ($) {\n  $.spotSwipe = new SpotSwipe($);\n};\n/****************************************************\n * Method for adding pseudo drag events to elements *\n ***************************************************/\n\n\nTouch.setupTouchHandler = function ($) {\n  $.fn.addTouch = function () {\n    this.each(function (i, el) {\n      $(el).bind('touchstart touchmove touchend touchcancel', function (event) {\n        //we pass the original event object because the jQuery event\n        //object is normalized to w3c specs and does not provide the TouchList\n        handleTouch(event);\n      });\n    });\n\n    var handleTouch = function handleTouch(event) {\n      var touches = event.changedTouches,\n          first = touches[0],\n          eventTypes = {\n        touchstart: 'mousedown',\n        touchmove: 'mousemove',\n        touchend: 'mouseup'\n      },\n          type = eventTypes[event.type],\n          simulatedEvent;\n\n      if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {\n        simulatedEvent = new window.MouseEvent(type, {\n          'bubbles': true,\n          'cancelable': true,\n          'screenX': first.screenX,\n          'screenY': first.screenY,\n          'clientX': first.clientX,\n          'clientY': first.clientY\n        });\n      } else {\n        simulatedEvent = document.createEvent('MouseEvent');\n        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0\n        /*left*/\n        , null);\n      }\n\n      first.target.dispatchEvent(simulatedEvent);\n    };\n  };\n};\n\nTouch.init = function ($) {\n  if (typeof $.spotSwipe === 'undefined') {\n    Touch.setupSpotSwipe($);\n    Touch.setupTouchHandler($);\n  }\n};\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.touch.js?");/***/},/***/"./js/foundation.util.triggers.js":/*!****************************************!*\
	  !*** ./js/foundation.util.triggers.js ***!
	  \****************************************/ /*! exports provided: Triggers */ /***/function(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Triggers\", function() { return Triggers; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foundation.core.utils */ \"./js/foundation.core.utils.js\");\n/* harmony import */ var _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./foundation.util.motion */ \"./js/foundation.util.motion.js\");\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\n\nvar MutationObserver = function () {\n  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\n\n  for (var i = 0; i < prefixes.length; i++) {\n    if (\"\".concat(prefixes[i], \"MutationObserver\") in window) {\n      return window[\"\".concat(prefixes[i], \"MutationObserver\")];\n    }\n  }\n\n  return false;\n}();\n\nvar triggers = function triggers(el, type) {\n  el.data(type).split(' ').forEach(function (id) {\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(id))[type === 'close' ? 'trigger' : 'triggerHandler'](\"\".concat(type, \".zf.trigger\"), [el]);\n  });\n};\n\nvar Triggers = {\n  Listeners: {\n    Basic: {},\n    Global: {}\n  },\n  Initializers: {}\n};\nTriggers.Listeners.Basic = {\n  openListener: function openListener() {\n    triggers(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'open');\n  },\n  closeListener: function closeListener() {\n    var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('close');\n\n    if (id) {\n      triggers(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'close');\n    } else {\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('close.zf.trigger');\n    }\n  },\n  toggleListener: function toggleListener() {\n    var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('toggle');\n\n    if (id) {\n      triggers(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'toggle');\n    } else {\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('toggle.zf.trigger');\n    }\n  },\n  closeableListener: function closeableListener(e) {\n    var animation = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('closable'); // Only close the first closable element. See https://git.io/zf-7833\n\n    e.stopPropagation();\n\n    if (animation !== '') {\n      _foundation_util_motion__WEBPACK_IMPORTED_MODULE_2__[\"Motion\"].animateOut(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), animation, function () {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('closed.zf');\n      });\n    } else {\n      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).fadeOut().trigger('closed.zf');\n    }\n  },\n  toggleFocusListener: function toggleFocusListener() {\n    var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('toggle-focus');\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"#\".concat(id)).triggerHandler('toggle.zf.trigger', [jquery__WEBPACK_IMPORTED_MODULE_0___default()(this)]);\n  }\n}; // Elements with [data-open] will reveal a plugin that supports it when clicked.\n\nTriggers.Initializers.addOpenListener = function ($elem) {\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.openListener);\n  $elem.on('click.zf.trigger', '[data-open]', Triggers.Listeners.Basic.openListener);\n}; // Elements with [data-close] will close a plugin that supports it when clicked.\n// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\n\n\nTriggers.Initializers.addCloseListener = function ($elem) {\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.closeListener);\n  $elem.on('click.zf.trigger', '[data-close]', Triggers.Listeners.Basic.closeListener);\n}; // Elements with [data-toggle] will toggle a plugin that supports it when clicked.\n\n\nTriggers.Initializers.addToggleListener = function ($elem) {\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.toggleListener);\n  $elem.on('click.zf.trigger', '[data-toggle]', Triggers.Listeners.Basic.toggleListener);\n}; // Elements with [data-closable] will respond to close.zf.trigger events.\n\n\nTriggers.Initializers.addCloseableListener = function ($elem) {\n  $elem.off('close.zf.trigger', Triggers.Listeners.Basic.closeableListener);\n  $elem.on('close.zf.trigger', '[data-closeable], [data-closable]', Triggers.Listeners.Basic.closeableListener);\n}; // Elements with [data-toggle-focus] will respond to coming in and out of focus\n\n\nTriggers.Initializers.addToggleFocusListener = function ($elem) {\n  $elem.off('focus.zf.trigger blur.zf.trigger', Triggers.Listeners.Basic.toggleFocusListener);\n  $elem.on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', Triggers.Listeners.Basic.toggleFocusListener);\n}; // More Global/complex listeners and triggers\n\n\nTriggers.Listeners.Global = {\n  resizeListener: function resizeListener($nodes) {\n    if (!MutationObserver) {\n      //fallback for IE 9\n      $nodes.each(function () {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).triggerHandler('resizeme.zf.trigger');\n      });\n    } //trigger all listening elements and signal a resize event\n\n\n    $nodes.attr('data-events', \"resize\");\n  },\n  scrollListener: function scrollListener($nodes) {\n    if (!MutationObserver) {\n      //fallback for IE 9\n      $nodes.each(function () {\n        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).triggerHandler('scrollme.zf.trigger');\n      });\n    } //trigger all listening elements and signal a scroll event\n\n\n    $nodes.attr('data-events', \"scroll\");\n  },\n  closeMeListener: function closeMeListener(e, pluginId) {\n    var plugin = e.namespace.split('.')[0];\n    var plugins = jquery__WEBPACK_IMPORTED_MODULE_0___default()(\"[data-\".concat(plugin, \"]\")).not(\"[data-yeti-box=\\\"\".concat(pluginId, \"\\\"]\"));\n    plugins.each(function () {\n      var _this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);\n\n      _this.triggerHandler('close.zf.trigger', [_this]);\n    });\n  } // Global, parses whole document.\n\n};\n\nTriggers.Initializers.addClosemeListener = function (pluginName) {\n  var yetiBoxes = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-yeti-box]'),\n      plugNames = ['dropdown', 'tooltip', 'reveal'];\n\n  if (pluginName) {\n    if (typeof pluginName === 'string') {\n      plugNames.push(pluginName);\n    } else if (_typeof(pluginName) === 'object' && typeof pluginName[0] === 'string') {\n      plugNames = plugNames.concat(pluginName);\n    } else {\n      console.error('Plugin names must be strings');\n    }\n  }\n\n  if (yetiBoxes.length) {\n    var listeners = plugNames.map(function (name) {\n      return \"closeme.zf.\".concat(name);\n    }).join(' ');\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(listeners).on(listeners, Triggers.Listeners.Global.closeMeListener);\n  }\n};\n\nfunction debounceGlobalListener(debounce, trigger, listener) {\n  var timer,\n      args = Array.prototype.slice.call(arguments, 3);\n  jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(trigger).on(trigger, function (e) {\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = setTimeout(function () {\n      listener.apply(null, args);\n    }, debounce || 10); //default time to emit scroll event\n  });\n}\n\nTriggers.Initializers.addResizeListener = function (debounce) {\n  var $nodes = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-resize]');\n\n  if ($nodes.length) {\n    debounceGlobalListener(debounce, 'resize.zf.trigger', Triggers.Listeners.Global.resizeListener, $nodes);\n  }\n};\n\nTriggers.Initializers.addScrollListener = function (debounce) {\n  var $nodes = jquery__WEBPACK_IMPORTED_MODULE_0___default()('[data-scroll]');\n\n  if ($nodes.length) {\n    debounceGlobalListener(debounce, 'scroll.zf.trigger', Triggers.Listeners.Global.scrollListener, $nodes);\n  }\n};\n\nTriggers.Initializers.addMutationEventsListener = function ($elem) {\n  if (!MutationObserver) {\n    return false;\n  }\n\n  var $nodes = $elem.find('[data-resize], [data-scroll], [data-mutate]'); //element callback\n\n  var listeningElementsMutation = function listeningElementsMutation(mutationRecordsList) {\n    var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(mutationRecordsList[0].target); //trigger the event handler for the element depending on type\n\n    switch (mutationRecordsList[0].type) {\n      case \"attributes\":\n        if ($target.attr(\"data-events\") === \"scroll\" && mutationRecordsList[0].attributeName === \"data-events\") {\n          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\n        }\n\n        if ($target.attr(\"data-events\") === \"resize\" && mutationRecordsList[0].attributeName === \"data-events\") {\n          $target.triggerHandler('resizeme.zf.trigger', [$target]);\n        }\n\n        if (mutationRecordsList[0].attributeName === \"style\") {\n          $target.closest(\"[data-mutate]\").attr(\"data-events\", \"mutate\");\n          $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n        }\n\n        break;\n\n      case \"childList\":\n        $target.closest(\"[data-mutate]\").attr(\"data-events\", \"mutate\");\n        $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n        break;\n\n      default:\n        return false;\n      //nothing\n    }\n  };\n\n  if ($nodes.length) {\n    //for each element that needs to listen for resizing, scrolling, or mutation add a single observer\n    for (var i = 0; i <= $nodes.length - 1; i++) {\n      var elementObserver = new MutationObserver(listeningElementsMutation);\n      elementObserver.observe($nodes[i], {\n        attributes: true,\n        childList: true,\n        characterData: false,\n        subtree: true,\n        attributeFilter: [\"data-events\", \"style\"]\n      });\n    }\n  }\n};\n\nTriggers.Initializers.addSimpleListeners = function () {\n  var $document = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document);\n  Triggers.Initializers.addOpenListener($document);\n  Triggers.Initializers.addCloseListener($document);\n  Triggers.Initializers.addToggleListener($document);\n  Triggers.Initializers.addCloseableListener($document);\n  Triggers.Initializers.addToggleFocusListener($document);\n};\n\nTriggers.Initializers.addGlobalListeners = function () {\n  var $document = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document);\n  Triggers.Initializers.addMutationEventsListener($document);\n  Triggers.Initializers.addResizeListener();\n  Triggers.Initializers.addScrollListener();\n  Triggers.Initializers.addClosemeListener();\n};\n\nTriggers.init = function ($, Foundation) {\n  Object(_foundation_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"onLoad\"])($(window), function () {\n    if ($.triggersInitialized !== true) {\n      Triggers.Initializers.addSimpleListeners();\n      Triggers.Initializers.addGlobalListeners();\n      $.triggersInitialized = true;\n    }\n  });\n\n  if (Foundation) {\n    Foundation.Triggers = Triggers; // Legacy included to be backwards compatible for now.\n\n    Foundation.IHearYou = Triggers.Initializers.addGlobalListeners;\n  }\n};\n\n\n\n//# sourceURL=webpack:///./js/foundation.util.triggers.js?");/***/},/***/"jquery":/*!********************************************************************************************!*\
	  !*** external {"root":["jQuery"],"amd":"jQuery","commonjs":"jQuery","commonjs2":"jQuery"} ***!
	  \********************************************************************************************/ /*! no static exports found */ /***/function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;\n\n//# sourceURL=webpack:///external_%7B%22root%22:%5B%22jQuery%22%5D,%22amd%22:%22jQuery%22,%22commonjs%22:%22jQuery%22,%22commonjs2%22:%22jQuery%22%7D?");/***/}/******/}));});
	});

	var foundation$1 = unwrapExports(foundation);

	return foundation$1;

}());

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm91bmRhdGlvbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL2pRdWVyeS9kaXN0L2pxdWVyeS5qcyIsInNyYy9qcy9mb3VuZGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My41LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIwLTA1LTA0VDIyOjQ5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjUuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNVxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMC0wMy0xNFxuICovXG4oIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoIHt9ICkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoTmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxcIiArXG5cdFx0XCJpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuXHRcdC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0cmV0dXJuIG5vbkhleCA/XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0bm9uSGV4IDpcblxuXHRcdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgK1xuXHRcdFx0XHRjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICggdGFyZ2V0WyBqKysgXSA9IGVsc1sgaSsrIF0gKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdCggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCByY29tYmluYXRvcnMudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoIFwifFwiICksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbIGkgXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5uZXh0U2libGluZyApICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuICggbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHhcIjtcblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQgKSA+IDM7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmIGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy50b3AgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHByb3BzLnRvcCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy5sZWZ0ID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy5sZWZ0ICs9IFwicHhcIjtcblx0XHRcdH1cblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwialF1ZXJ5XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImpRdWVyeVwiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwialF1ZXJ5XCIpKSA6IGZhY3Rvcnkocm9vdFtcImpRdWVyeVwiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh3aW5kb3csIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdG1wL2ZvdW5kYXRpb24tNi42LjMuY29tcGxldGUvanMvdmVuZG9yL2ZvdW5kYXRpb24uanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdG1wL2ZvdW5kYXRpb24tNi42LjMuY29tcGxldGUvanMvdmVuZG9yL2ZvdW5kYXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC90bXAvZm91bmRhdGlvbi02LjYuMy5jb21wbGV0ZS9qcy92ZW5kb3IvZm91bmRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gZXhwb3J0cyBwcm92aWRlZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLmNvcmUgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fYWJpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5hYmlkZSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmFiaWRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hY2NvcmRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5hY2NvcmRpb24gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5hY2NvcmRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2FjY29yZGlvbk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5hY2NvcmRpb25NZW51ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uYWNjb3JkaW9uTWVudS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fZHJpbGxkb3duX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24uZHJpbGxkb3duICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uZHJpbGxkb3duLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9kcm9wZG93bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uZHJvcGRvd24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2Ryb3Bkb3duTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duTWVudSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duTWVudS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fZXF1YWxpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLmVxdWFsaXplciAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmVxdWFsaXplci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25faW50ZXJjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24uaW50ZXJjaGFuZ2UgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5pbnRlcmNoYW5nZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fbWFnZWxsYW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ubWFnZWxsYW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5tYWdlbGxhbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fb2ZmY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLm9mZmNhbnZhcyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLm9mZmNhbnZhcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fb3JiaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ub3JiaXQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5vcmJpdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZU1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlTWVudS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZVRvZ2dsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlICovIFxcXCIuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmV2ZWFsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnJldmVhbCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnJldmVhbC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fc2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnNsaWRlciAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnNsaWRlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fc3RpY2t5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qcy9mb3VuZGF0aW9uLnN0aWNreSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnN0aWNreS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdGFic19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi50YWJzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udGFicy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdG9nZ2xlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi50b2dnbGVyICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udG9nZ2xlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdG9vbHRpcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanMvZm91bmRhdGlvbi50b29sdGlwICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udG9vbHRpcC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZUFjY29yZGlvblRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlQWNjb3JkaW9uVGFicy5qc1xcXCIpO1xcblxcblxcbl92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkZvdW5kYXRpb25cXFwiXS5hZGRUb0pxdWVyeShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbl92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkZvdW5kYXRpb25cXFwiXS5NZWRpYVF1ZXJ5ID0gX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl07XFxuXFxuX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSwgX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRm91bmRhdGlvblxcXCJdKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hYmlkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJBYmlkZVxcXCJdLCAnQWJpZGUnKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hY2NvcmRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiQWNjb3JkaW9uXFxcIl0sICdBY2NvcmRpb24nKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9hY2NvcmRpb25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcIkFjY29yZGlvbk1lbnVcXFwiXSwgJ0FjY29yZGlvbk1lbnUnKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9kcmlsbGRvd25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiRHJpbGxkb3duXFxcIl0sICdEcmlsbGRvd24nKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9kcm9wZG93bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJEcm9wZG93blxcXCJdLCAnRHJvcGRvd24nKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9kcm9wZG93bk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcXFwiRHJvcGRvd25NZW51XFxcIl0sICdEcm9wZG93bk1lbnUnKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9lcXVhbGl6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXFxcIkVxdWFsaXplclxcXCJdLCAnRXF1YWxpemVyJyk7XFxuXFxuX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRm91bmRhdGlvblxcXCJdLnBsdWdpbihfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25faW50ZXJjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcIkludGVyY2hhbmdlXFxcIl0sICdJbnRlcmNoYW5nZScpO1xcblxcbl92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkZvdW5kYXRpb25cXFwiXS5wbHVnaW4oX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX21hZ2VsbGFuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1xcXCJNYWdlbGxhblxcXCJdLCAnTWFnZWxsYW4nKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9vZmZjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXFxcIk9mZkNhbnZhc1xcXCJdLCAnT2ZmQ2FudmFzJyk7XFxuXFxuX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRm91bmRhdGlvblxcXCJdLnBsdWdpbihfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fb3JiaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bXFxcIk9yYml0XFxcIl0sICdPcmJpdCcpO1xcblxcbl92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkZvdW5kYXRpb25cXFwiXS5wbHVnaW4oX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVNZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fW1xcXCJSZXNwb25zaXZlTWVudVxcXCJdLCAnUmVzcG9uc2l2ZU1lbnUnKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9yZXNwb25zaXZlVG9nZ2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fW1xcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIl0sICdSZXNwb25zaXZlVG9nZ2xlJyk7XFxuXFxuX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRm91bmRhdGlvblxcXCJdLnBsdWdpbihfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmV2ZWFsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fW1xcXCJSZXZlYWxcXFwiXSwgJ1JldmVhbCcpO1xcblxcbl92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkZvdW5kYXRpb25cXFwiXS5wbHVnaW4oX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3NsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX1tcXFwiU2xpZGVyXFxcIl0sICdTbGlkZXInKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9zdGlja3lfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X19bXFxcIlN0aWNreVxcXCJdLCAnU3RpY2t5Jyk7XFxuXFxuX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRm91bmRhdGlvblxcXCJdLnBsdWdpbihfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fdGFic19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjBfX1tcXFwiVGFic1xcXCJdLCAnVGFicycpO1xcblxcbl92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl9jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkZvdW5kYXRpb25cXFwiXS5wbHVnaW4oX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX3RvZ2dsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIxX19bXFxcIlRvZ2dsZXJcXFwiXSwgJ1RvZ2dsZXInKTtcXG5cXG5fdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJGb3VuZGF0aW9uXFxcIl0ucGx1Z2luKF92YXJfd3d3X3ZpcnR1YWxfZHJ1Zl9odG1sX2ZvdW5kYXRpb25fY3VzdG9taXplcl9kYW5pZWxfcnVmX2RlX2ZvdW5kYXRpb25fc2l0ZXNfanNfZm91bmRhdGlvbl90b29sdGlwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fW1xcXCJUb29sdGlwXFxcIl0sICdUb29sdGlwJyk7XFxuXFxuX3Zhcl93d3dfdmlydHVhbF9kcnVmX2h0bWxfZm91bmRhdGlvbl9jdXN0b21pemVyX2RhbmllbF9ydWZfZGVfZm91bmRhdGlvbl9zaXRlc19qc19mb3VuZGF0aW9uX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiRm91bmRhdGlvblxcXCJdLnBsdWdpbihfdmFyX3d3d192aXJ0dWFsX2RydWZfaHRtbF9mb3VuZGF0aW9uX2N1c3RvbWl6ZXJfZGFuaWVsX3J1Zl9kZV9mb3VuZGF0aW9uX3NpdGVzX2pzX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZUFjY29yZGlvblRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIzX19bXFxcIlJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXFxcIl0sICdSZXNwb25zaXZlQWNjb3JkaW9uVGFicycpO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8vdG1wL2ZvdW5kYXRpb24tNi42LjMuY29tcGxldGUvanMvdmVuZG9yL2ZvdW5kYXRpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uYWJpZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5hYmlkZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWJpZGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFiaWRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBYmlkZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogQWJpZGUgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5hYmlkZVxcbiAqL1xcblxcbnZhciBBYmlkZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoQWJpZGUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gQWJpZGUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYmlkZSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQWJpZGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEFiaWRlLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBBYmlkZS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIEFiaWRlXFxuICAgICAqIEBmaXJlcyBBYmlkZSNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCkge1xcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHRydWUsIHt9LCBBYmlkZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcXG4gICAgICB0aGlzLmZvcm1ub3ZhbGlkYXRlID0gbnVsbDtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBYmlkZSc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFiaWRlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBBYmlkZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kaW5wdXRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLm1lcmdlKCAvLyBDb25zaWRlciBhcyBpbnB1dCB0byB2YWxpZGF0ZTpcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jykubm90KCdbdHlwZT1cXFwic3VibWl0XFxcIl0nKSwgLy8gKiBhbGwgaW5wdXQgZmllbGRzIGV4cGVjdCBzdWJtaXRcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ3RleHRhcmVhLCBzZWxlY3QnKSAvLyAqIGFsbCB0ZXh0YXJlYXMgYW5kIHNlbGVjdCBmaWVsZHNcXG4gICAgICApO1xcbiAgICAgIHRoaXMuJHN1Ym1pdHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1t0eXBlPVxcXCJzdWJtaXRcXFwiXScpO1xcbiAgICAgIHZhciAkZ2xvYmFsRXJyb3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKTsgLy8gQWRkIGExMXkgYXR0cmlidXRlcyB0byBhbGwgZmllbGRzXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hMTF5QXR0cmlidXRlcykge1xcbiAgICAgICAgdGhpcy4kaW5wdXRzLmVhY2goZnVuY3Rpb24gKGksIGlucHV0KSB7XFxuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkQTExeUF0dHJpYnV0ZXMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGlucHV0KSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgICRnbG9iYWxFcnJvcnMuZWFjaChmdW5jdGlvbiAoaSwgZXJyb3IpIHtcXG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGRHbG9iYWxFcnJvckExMXlBdHRyaWJ1dGVzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlcnJvcikpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEFiaWRlLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuYWJpZGUnKS5vbigncmVzZXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpczMucmVzZXRGb3JtKCk7XFxuICAgICAgfSkub24oJ3N1Ym1pdC56Zi5hYmlkZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczMudmFsaWRhdGVGb3JtKCk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kc3VibWl0cy5vZmYoJ2NsaWNrLnpmLmFiaWRlIGtleWRvd24uemYuYWJpZGUnKS5vbignY2xpY2suemYuYWJpZGUga2V5ZG93bi56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoIWUua2V5IHx8IGUua2V5ID09PSAnICcgfHwgZS5rZXkgPT09ICdFbnRlcicpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICBfdGhpczMuZm9ybW5vdmFsaWRhdGUgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2Zvcm1ub3ZhbGlkYXRlJykgIT09IG51bGw7XFxuXFxuICAgICAgICAgIF90aGlzMy4kZWxlbWVudC5zdWJtaXQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlT24gPT09ICdmaWVsZENoYW5nZScpIHtcXG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJ2NoYW5nZS56Zi5hYmlkZScpLm9uKCdjaGFuZ2UuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBfdGhpczMudmFsaWRhdGVJbnB1dChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZS50YXJnZXQpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSkge1xcbiAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignaW5wdXQuemYuYWJpZGUnKS5vbignaW5wdXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBfdGhpczMudmFsaWRhdGVJbnB1dChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZS50YXJnZXQpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlT25CbHVyKSB7XFxuICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdibHVyLnpmLmFiaWRlJykub24oJ2JsdXIuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBfdGhpczMudmFsaWRhdGVJbnB1dChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZS50YXJnZXQpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgQWJpZGUgdXBvbiBET00gY2hhbmdlXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVmbG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc3VibWl0dGVkIGZvcm0gc2hvdWxkIGJlIHZhbGlkYXRlZCBvciBub3QsIGNvbnNvZGVyaW5nIGZvcm1ub3ZhbGlkYXRlIGFuZCBpc0VuYWJsZWRcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfdmFsaWRhdGlvbklzRGlzYWJsZWRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRpb25Jc0Rpc2FibGVkKCkge1xcbiAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgIC8vIHdob2xlIHZhbGlkYXRpb24gZGlzYWJsZWRcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZm9ybW5vdmFsaWRhdGUgPT09ICdib29sZWFuJykge1xcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5ICRzdWJtaXRcXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1ub3ZhbGlkYXRlO1xcbiAgICAgIH0gLy8gdHJpZ2dlcmVkIGJ5IEVudGVyIGluIG5vbi1zdWJtaXQgaW5wdXRcXG5cXG5cXG4gICAgICByZXR1cm4gdGhpcy4kc3VibWl0cy5sZW5ndGggPyB0aGlzLiRzdWJtaXRzWzBdLmdldEF0dHJpYnV0ZSgnZm9ybW5vdmFsaWRhdGUnKSAhPT0gbnVsbCA6IGZhbHNlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBFbmFibGVzIHRoZSB3aG9sZSB2YWxpZGF0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJlbmFibGVWYWxpZGF0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVZhbGlkYXRpb24oKSB7XFxuICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEaXNhYmxlcyB0aGUgd2hvbGUgdmFsaWRhdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGlzYWJsZVZhbGlkYXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVZhbGlkYXRpb24oKSB7XFxuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgZm9ybSBlbGVtZW50IGhhcyB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIGFuZCBpZiBpdCdzIGNoZWNrZWQgb3Igbm90XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlcXVpcmVkQ2hlY2tcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWlyZWRDaGVjaygkZWwpIHtcXG4gICAgICBpZiAoISRlbC5hdHRyKCdyZXF1aXJlZCcpKSByZXR1cm4gdHJ1ZTtcXG4gICAgICB2YXIgaXNHb29kID0gdHJ1ZTtcXG5cXG4gICAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XFxuICAgICAgICBjYXNlICdjaGVja2JveCc6XFxuICAgICAgICAgIGlzR29vZCA9ICRlbFswXS5jaGVja2VkO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XFxuICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcXG4gICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XFxuICAgICAgICAgIHZhciBvcHQgPSAkZWwuZmluZCgnb3B0aW9uOnNlbGVjdGVkJyk7XFxuICAgICAgICAgIGlmICghb3B0Lmxlbmd0aCB8fCAhb3B0LnZhbCgpKSBpc0dvb2QgPSBmYWxzZTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAoISRlbC52YWwoKSB8fCAhJGVsLnZhbCgpLmxlbmd0aCkgaXNHb29kID0gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBpc0dvb2Q7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldDpcXG4gICAgICogLSBCYXNlZCBvbiAkZWwsIHRoZSBmaXJzdCBlbGVtZW50KHMpIGNvcnJlc3BvbmRpbmcgdG8gYGZvcm1FcnJvclNlbGVjdG9yYCBpbiB0aGlzIG9yZGVyOlxcbiAgICAgKiAgIDEuIFRoZSBlbGVtZW50J3MgZGlyZWN0IHNpYmxpbmcoJ3MpLlxcbiAgICAgKiAgIDIuIFRoZSBlbGVtZW50J3MgcGFyZW50J3MgY2hpbGRyZW4uXFxuICAgICAqIC0gRWxlbWVudChzKSB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtkYXRhLWZvcm0tZXJyb3ItZm9yXWAgc2V0IHdpdGggdGhlIGVsZW1lbnQncyBpZC5cXG4gICAgICpcXG4gICAgICogVGhpcyBhbGxvd3MgZm9yIG11bHRpcGxlIGZvcm0gZXJyb3JzIHBlciBpbnB1dCwgdGhvdWdoIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBmb3JtIGVycm9ycyB3aWxsIGJlIHNob3duLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgcmVmZXJlbmNlIHRvIGZpbmQgdGhlIGZvcm0gZXJyb3Igc2VsZWN0b3IuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IFtmYWlsZWRWYWxpZGF0b3JzXSAtIExpc3Qgb2YgZmFpbGVkIHZhbGlkYXRvcnMuXFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGpRdWVyeSBvYmplY3Qgd2l0aCB0aGUgc2VsZWN0b3IuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaW5kRm9ybUVycm9yXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRGb3JtRXJyb3IoJGVsLCBmYWlsZWRWYWxpZGF0b3JzKSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGlkID0gJGVsLmxlbmd0aCA/ICRlbFswXS5pZCA6ICcnO1xcbiAgICAgIHZhciAkZXJyb3IgPSAkZWwuc2libGluZ3ModGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTtcXG5cXG4gICAgICBpZiAoISRlcnJvci5sZW5ndGgpIHtcXG4gICAgICAgICRlcnJvciA9ICRlbC5wYXJlbnQoKS5maW5kKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpZCkge1xcbiAgICAgICAgJGVycm9yID0gJGVycm9yLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWZvcm0tZXJyb3ItZm9yPVxcXFxcXFwiXFxcIi5jb25jYXQoaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoISFmYWlsZWRWYWxpZGF0b3JzKSB7XFxuICAgICAgICAkZXJyb3IgPSAkZXJyb3Iubm90KCdbZGF0YS1mb3JtLWVycm9yLW9uXScpO1xcbiAgICAgICAgZmFpbGVkVmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XFxuICAgICAgICAgICRlcnJvciA9ICRlcnJvci5hZGQoJGVsLnNpYmxpbmdzKFxcXCJbZGF0YS1mb3JtLWVycm9yLW9uPVxcXFxcXFwiXFxcIi5jb25jYXQodiwgXFxcIlxcXFxcXFwiXVxcXCIpKSk7XFxuICAgICAgICAgICRlcnJvciA9ICRlcnJvci5hZGQoX3RoaXM0LiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWZvcm0tZXJyb3ItZm9yPVxcXFxcXFwiXFxcIi5jb25jYXQoaWQsIFxcXCJcXFxcXFxcIl1bZGF0YS1mb3JtLWVycm9yLW9uPVxcXFxcXFwiXFxcIikuY29uY2F0KHYsIFxcXCJcXFxcXFxcIl1cXFwiKSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkZXJyb3I7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGlzIG9yZGVyOlxcbiAgICAgKiAyLiBUaGUgPGxhYmVsPiB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtmb3I9XFxcInNvbWVJbnB1dElkXFxcIl1gXFxuICAgICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZpbmRMYWJlbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTGFiZWwoJGVsKSB7XFxuICAgICAgdmFyIGlkID0gJGVsWzBdLmlkO1xcbiAgICAgIHZhciAkbGFiZWwgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImxhYmVsW2Zvcj1cXFxcXFxcIlxcXCIuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcblxcbiAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuICRlbC5jbG9zZXN0KCdsYWJlbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gJGxhYmVsO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIHNldCBvZiBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIGEgc2V0IG9mIHJhZGlvIGVscyBpbiB0aGlzIG9yZGVyXFxuICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cXFwic29tZUlucHV0SWRcXFwiXWBcXG4gICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZmluZFJhZGlvTGFiZWxzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRSYWRpb0xhYmVscygkZWxzKSB7XFxuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGxhYmVscyA9ICRlbHMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgdmFyIGlkID0gZWwuaWQ7XFxuXFxuICAgICAgICB2YXIgJGxhYmVsID0gX3RoaXM1LiRlbGVtZW50LmZpbmQoXFxcImxhYmVsW2Zvcj1cXFxcXFxcIlxcXCIuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcblxcbiAgICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICAgICRsYWJlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCkuY2xvc2VzdCgnbGFiZWwnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAkbGFiZWxbMF07XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShsYWJlbHMpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIHNldCBvZiBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIGEgc2V0IG9mIGNoZWNrYm94IGVscyBpbiB0aGlzIG9yZGVyXFxuICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cXFwic29tZUlucHV0SWRcXFwiXWBcXG4gICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZmluZENoZWNrYm94TGFiZWxzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDaGVja2JveExhYmVscygkZWxzKSB7XFxuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGxhYmVscyA9ICRlbHMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgdmFyIGlkID0gZWwuaWQ7XFxuXFxuICAgICAgICB2YXIgJGxhYmVsID0gX3RoaXM2LiRlbGVtZW50LmZpbmQoXFxcImxhYmVsW2Zvcj1cXFxcXFxcIlxcXCIuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcblxcbiAgICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICAgICRsYWJlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCkuY2xvc2VzdCgnbGFiZWwnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAkbGFiZWxbMF07XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShsYWJlbHMpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIHRoZSBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyB0byB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSBjbGFzcyB0b1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBbZmFpbGVkVmFsaWRhdG9yc10gLSBMaXN0IG9mIGZhaWxlZCB2YWxpZGF0b3JzLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVycm9yQ2xhc3NlcygkZWwsIGZhaWxlZFZhbGlkYXRvcnMpIHtcXG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcXG4gICAgICB2YXIgJGZvcm1FcnJvciA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwsIGZhaWxlZFZhbGlkYXRvcnMpO1xcblxcbiAgICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICAkbGFiZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZm9ybUVycm9yLmxlbmd0aCkge1xcbiAgICAgICAgJGZvcm1FcnJvci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cih7XFxuICAgICAgICAnZGF0YS1pbnZhbGlkJzogJycsXFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogdHJ1ZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIFtmb3JdIGFuZCBbcm9sZT1hbGVydF0gYXR0cmlidXRlcyB0byBhbGwgZm9ybSBlcnJvciB0YXJnZXR0aW5nICRlbCxcXG4gICAgICogYW5kIFthcmlhLWRlc2NyaWJlZGJ5XSBhdHRyaWJ1dGUgdG8gJGVsIHRvd2FyZCB0aGUgZmlyc3QgZm9ybSBlcnJvci5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3RcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZEExMXlBdHRyaWJ1dGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEExMXlBdHRyaWJ1dGVzKCRlbCkge1xcbiAgICAgIHZhciAkZXJyb3JzID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XFxuICAgICAgdmFyICRsYWJlbHMgPSAkZXJyb3JzLmZpbHRlcignbGFiZWwnKTtcXG4gICAgICB2YXIgJGVycm9yID0gJGVycm9ycy5maXJzdCgpO1xcbiAgICAgIGlmICghJGVycm9ycy5sZW5ndGgpIHJldHVybjsgLy8gU2V0IFthcmlhLWRlc2NyaWJlZGJ5XSBvbiB0aGUgaW5wdXQgdG93YXJkIHRoZSBmaXJzdCBmb3JtIGVycm9yIGlmIGl0IGlzIG5vdCBzZXRcXG5cXG4gICAgICBpZiAodHlwZW9mICRlbC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JykgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IGVycm9yIElEIG9yIGNyZWF0ZSBvbmVcXG4gICAgICAgIHZhciBlcnJvcklkID0gJGVycm9yLmF0dHIoJ2lkJyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGVycm9ySWQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIGVycm9ySWQgPSBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnYWJpZGUtZXJyb3InKTtcXG4gICAgICAgICAgJGVycm9yLmF0dHIoJ2lkJywgZXJyb3JJZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkZWwuYXR0cignYXJpYS1kZXNjcmliZWRieScsIGVycm9ySWQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGxhYmVscy5maWx0ZXIoJ1tmb3JdJykubGVuZ3RoIDwgJGxhYmVscy5sZW5ndGgpIHtcXG4gICAgICAgIC8vIEdldCB0aGUgaW5wdXQgSUQgb3IgY3JlYXRlIG9uZVxcbiAgICAgICAgdmFyIGVsZW1JZCA9ICRlbC5hdHRyKCdpZCcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtSWQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIGVsZW1JZCA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdhYmlkZS1pbnB1dCcpO1xcbiAgICAgICAgICAkZWwuYXR0cignaWQnLCBlbGVtSWQpO1xcbiAgICAgICAgfSAvLyBGb3IgZWFjaCBsYWJlbCB0YXJnZXRpbmcgJGVsLCBzZXQgW2Zvcl0gaWYgaXQgaXMgbm90IHNldC5cXG5cXG5cXG4gICAgICAgICRsYWJlbHMuZWFjaChmdW5jdGlvbiAoaSwgbGFiZWwpIHtcXG4gICAgICAgICAgdmFyICRsYWJlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShsYWJlbCk7XFxuICAgICAgICAgIGlmICh0eXBlb2YgJGxhYmVsLmF0dHIoJ2ZvcicpID09PSAndW5kZWZpbmVkJykgJGxhYmVsLmF0dHIoJ2ZvcicsIGVsZW1JZCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IC8vIEZvciBlYWNoIGVycm9yIHRhcmdldGluZyAkZWwsIHNldCBbcm9sZT1hbGVydF0gaWYgaXQgaXMgbm90IHNldC5cXG5cXG5cXG4gICAgICAkZXJyb3JzLmVhY2goZnVuY3Rpb24gKGksIGxhYmVsKSB7XFxuICAgICAgICB2YXIgJGxhYmVsID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGxhYmVsKTtcXG4gICAgICAgIGlmICh0eXBlb2YgJGxhYmVsLmF0dHIoJ3JvbGUnKSA9PT0gJ3VuZGVmaW5lZCcpICRsYWJlbC5hdHRyKCdyb2xlJywgJ2FsZXJ0Jyk7XFxuICAgICAgfSkuZW5kKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgW2FyaWEtbGl2ZV0gYXR0cmlidXRlIHRvIHRoZSBnaXZlbiBnbG9iYWwgZm9ybSBlcnJvciAkZWwuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgYXR0cmlidXRlIHRvXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhZGRHbG9iYWxFcnJvckExMXlBdHRyaWJ1dGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEdsb2JhbEVycm9yQTExeUF0dHJpYnV0ZXMoJGVsKSB7XFxuICAgICAgaWYgKHR5cGVvZiAkZWwuYXR0cignYXJpYS1saXZlJykgPT09ICd1bmRlZmluZWQnKSAkZWwuYXR0cignYXJpYS1saXZlJywgdGhpcy5vcHRpb25zLmExMXlFcnJvckxldmVsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIENTUyBlcnJvciBjbGFzc2VzIGV0YyBmcm9tIGFuIGVudGlyZSByYWRpbyBidXR0b24gZ3JvdXBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXFxuICAgICAqXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcXG4gICAgICB2YXIgJGVscyA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiOnJhZGlvW25hbWU9XFxcXFxcXCJcXFwiLmNvbmNhdChncm91cE5hbWUsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgICAgdmFyICRsYWJlbHMgPSB0aGlzLmZpbmRSYWRpb0xhYmVscygkZWxzKTtcXG4gICAgICB2YXIgJGZvcm1FcnJvcnMgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVscyk7XFxuXFxuICAgICAgaWYgKCRsYWJlbHMubGVuZ3RoKSB7XFxuICAgICAgICAkbGFiZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGZvcm1FcnJvcnMubGVuZ3RoKSB7XFxuICAgICAgICAkZm9ybUVycm9ycy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgQ1NTIGVycm9yIGNsYXNzZXMgZXRjIGZyb20gYW4gZW50aXJlIGNoZWNrYm94IGdyb3VwXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIGNoZWNrYm94IGdyb3VwXFxuICAgICAqXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZW1vdmVDaGVja2JveEVycm9yQ2xhc3Nlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGVja2JveEVycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcXG4gICAgICB2YXIgJGVscyA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiOmNoZWNrYm94W25hbWU9XFxcXFxcXCJcXFwiLmNvbmNhdChncm91cE5hbWUsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgICAgdmFyICRsYWJlbHMgPSB0aGlzLmZpbmRDaGVja2JveExhYmVscygkZWxzKTtcXG4gICAgICB2YXIgJGZvcm1FcnJvcnMgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVscyk7XFxuXFxuICAgICAgaWYgKCRsYWJlbHMubGVuZ3RoKSB7XFxuICAgICAgICAkbGFiZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGZvcm1FcnJvcnMubGVuZ3RoKSB7XFxuICAgICAgICAkZm9ybUVycm9ycy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIGZyb20gdGhlIGxhYmVsLCBpbnB1dCwgYW5kIHRoZSBmb3JtXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVtb3ZlRXJyb3JDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVycm9yQ2xhc3NlcygkZWwpIHtcXG4gICAgICAvLyByYWRpb3MgbmVlZCB0byBjbGVhciBhbGwgb2YgdGhlIGVsc1xcbiAgICAgIGlmICgkZWxbMF0udHlwZSA9PSAncmFkaW8nKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVSYWRpb0Vycm9yQ2xhc3NlcygkZWwuYXR0cignbmFtZScpKTtcXG4gICAgICB9IC8vIGNoZWNrYm94ZXMgbmVlZCB0byBjbGVhciBhbGwgb2YgdGhlIGVsc1xcbiAgICAgIGVsc2UgaWYgKCRlbFswXS50eXBlID09ICdjaGVja2JveCcpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hlY2tib3hFcnJvckNsYXNzZXMoJGVsLmF0dHIoJ25hbWUnKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XFxuICAgICAgdmFyICRmb3JtRXJyb3IgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVsKTtcXG5cXG4gICAgICBpZiAoJGxhYmVsLmxlbmd0aCkge1xcbiAgICAgICAgJGxhYmVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGZvcm1FcnJvci5sZW5ndGgpIHtcXG4gICAgICAgICRmb3JtRXJyb3IucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcXG4gICAgICB9XFxuXFxuICAgICAgJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIHRvIGZpbmQgaW5wdXRzIGFuZCBwcm9jZWVkcyB0byB2YWxpZGF0ZSB0aGVtIGluIHdheXMgc3BlY2lmaWMgdG8gdGhlaXIgdHlwZS5cXG4gICAgICogSWdub3JlcyBpbnB1dHMgd2l0aCBkYXRhLWFiaWRlLWlnbm9yZSwgdHlwZT1cXFwiaGlkZGVuXFxcIiBvciBkaXNhYmxlZCBhdHRyaWJ1dGVzIHNldFxcbiAgICAgKiBAZmlyZXMgQWJpZGUjaW52YWxpZFxcbiAgICAgKiBAZmlyZXMgQWJpZGUjdmFsaWRcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYW4gSFRNTCBpbnB1dFxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZ29vZFRvR28gLSBJZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsaWRhdGVJbnB1dFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0KCRlbCkge1xcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xcblxcbiAgICAgIHZhciBjbGVhclJlcXVpcmUgPSB0aGlzLnJlcXVpcmVkQ2hlY2soJGVsKSxcXG4gICAgICAgICAgdmFsaWRhdG9yID0gJGVsLmF0dHIoJ2RhdGEtdmFsaWRhdG9yJyksXFxuICAgICAgICAgIGZhaWxlZFZhbGlkYXRvcnMgPSBbXSxcXG4gICAgICAgICAgbWFuYWdlRXJyb3JDbGFzc2VzID0gdHJ1ZTsgLy8gc2tpcCB2YWxpZGF0aW9uIGlmIGRpc2FibGVkXFxuXFxuICAgICAgaWYgKHRoaXMuX3ZhbGlkYXRpb25Jc0Rpc2FibGVkKCkpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0gLy8gZG9uJ3QgdmFsaWRhdGUgaWdub3JlZCBpbnB1dHMgb3IgaGlkZGVuIGlucHV0cyBvciBkaXNhYmxlZCBpbnB1dHNcXG5cXG5cXG4gICAgICBpZiAoJGVsLmlzKCdbZGF0YS1hYmlkZS1pZ25vcmVdJykgfHwgJGVsLmlzKCdbdHlwZT1cXFwiaGlkZGVuXFxcIl0nKSB8fCAkZWwuaXMoJ1tkaXNhYmxlZF0nKSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAoJGVsWzBdLnR5cGUpIHtcXG4gICAgICAgIGNhc2UgJ3JhZGlvJzpcXG4gICAgICAgICAgdGhpcy52YWxpZGF0ZVJhZGlvKCRlbC5hdHRyKCduYW1lJykpIHx8IGZhaWxlZFZhbGlkYXRvcnMucHVzaCgncmVxdWlyZWQnKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdjaGVja2JveCc6XFxuICAgICAgICAgIHRoaXMudmFsaWRhdGVDaGVja2JveCgkZWwuYXR0cignbmFtZScpKSB8fCBmYWlsZWRWYWxpZGF0b3JzLnB1c2goJ3JlcXVpcmVkJyk7IC8vIHZhbGlkYXRlQ2hlY2tib3goKSBhZGRzL3JlbW92ZXMgZXJyb3IgY2xhc3Nlc1xcblxcbiAgICAgICAgICBtYW5hZ2VFcnJvckNsYXNzZXMgPSBmYWxzZTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdzZWxlY3QnOlxcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XFxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxcbiAgICAgICAgICBjbGVhclJlcXVpcmUgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdyZXF1aXJlZCcpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIGNsZWFyUmVxdWlyZSB8fCBmYWlsZWRWYWxpZGF0b3JzLnB1c2goJ3JlcXVpcmVkJyk7XFxuICAgICAgICAgIHRoaXMudmFsaWRhdGVUZXh0KCRlbCkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdwYXR0ZXJuJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh2YWxpZGF0b3IpIHtcXG4gICAgICAgIHZhciByZXF1aXJlZCA9ICRlbC5hdHRyKCdyZXF1aXJlZCcpID8gdHJ1ZSA6IGZhbHNlO1xcbiAgICAgICAgdmFsaWRhdG9yLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAodikge1xcbiAgICAgICAgICBfdGhpczcub3B0aW9ucy52YWxpZGF0b3JzW3ZdKCRlbCwgcmVxdWlyZWQsICRlbC5wYXJlbnQoKSkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKHYpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZWwuYXR0cignZGF0YS1lcXVhbHRvJykpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy52YWxpZGF0b3JzLmVxdWFsVG8oJGVsKSB8fCBmYWlsZWRWYWxpZGF0b3JzLnB1c2goJ2VxdWFsVG8nKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGdvb2RUb0dvID0gZmFpbGVkVmFsaWRhdG9ycy5sZW5ndGggPT09IDA7XFxuICAgICAgdmFyIG1lc3NhZ2UgPSAoZ29vZFRvR28gPyAndmFsaWQnIDogJ2ludmFsaWQnKSArICcuemYuYWJpZGUnO1xcblxcbiAgICAgIGlmIChnb29kVG9Hbykge1xcbiAgICAgICAgLy8gUmUtdmFsaWRhdGUgaW5wdXRzIHRoYXQgZGVwZW5kIG9uIHRoaXMgb25lIHdpdGggZXF1YWx0b1xcbiAgICAgICAgdmFyIGRlcGVuZGVudEVsZW1lbnRzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbHRvPVxcXFxcXFwiXFxcIi5jb25jYXQoJGVsLmF0dHIoJ2lkJyksIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgICAgICBpZiAoZGVwZW5kZW50RWxlbWVudHMubGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAgIGRlcGVuZGVudEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykudmFsKCkpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlSW5wdXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobWFuYWdlRXJyb3JDbGFzc2VzKSB7XFxuICAgICAgICB0aGlzLnJlbW92ZUVycm9yQ2xhc3NlcygkZWwpO1xcblxcbiAgICAgICAgaWYgKCFnb29kVG9Hbykge1xcbiAgICAgICAgICB0aGlzLmFkZEVycm9yQ2xhc3NlcygkZWwsIGZhaWxlZFZhbGlkYXRvcnMpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpbnB1dCBpcyBkb25lIGNoZWNraW5nIGZvciB2YWxpZGF0aW9uLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgdmFsaWQuemYuYWJpZGVgIG9yIGBpbnZhbGlkLnpmLmFiaWRlYFxcbiAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBpbnB1dC5cXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjdmFsaWRcXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjaW52YWxpZFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgICRlbC50cmlnZ2VyKG1lc3NhZ2UsIFskZWxdKTtcXG4gICAgICByZXR1cm4gZ29vZFRvR287XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gYW5kIGlmIHRoZXJlIGFyZSBhbnkgaW52YWxpZCBpbnB1dHMsIGl0IHdpbGwgZGlzcGxheSB0aGUgZm9ybSBlcnJvciBlbGVtZW50XFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBub0Vycm9yIC0gdHJ1ZSBpZiBubyBlcnJvcnMgd2VyZSBkZXRlY3RlZC4uLlxcbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXFxuICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtaW52YWxpZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsaWRhdGVGb3JtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybSgpIHtcXG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcXG5cXG4gICAgICB2YXIgYWNjID0gW107XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB2YXIgY2hlY2tib3hHcm91cE5hbWU7IC8vIFJlbWVtYmVyIGZpcnN0IGZvcm0gc3VibWlzc2lvbiB0byBwcmV2ZW50IHNwZWNpZmljIGNoZWNrYm94IHZhbGlkYXRpb24gKG1vcmUgdGhhbiBvbmUgcmVxdWlyZWQpIHVudGlsIGZvcm0gZ290IGluaXRpYWxseSBzdWJtaXR0ZWRcXG5cXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xcbiAgICAgIH0gLy8gc2tpcCB2YWxpZGF0aW9uIGlmIGRpc2FibGVkXFxuXFxuXFxuICAgICAgaWYgKHRoaXMuX3ZhbGlkYXRpb25Jc0Rpc2FibGVkKCkpIHtcXG4gICAgICAgIHRoaXMuZm9ybW5vdmFsaWRhdGUgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIE9ubHkgdXNlIG9uZSBjaGVja2JveCBwZXIgZ3JvdXAgc2luY2UgdmFsaWRhdGVDaGVja2JveCgpIGl0ZXJhdGVzIG92ZXIgYWxsIGFzc29jaWF0ZWQgY2hlY2tib3hlc1xcbiAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKVswXS50eXBlID09PSAnY2hlY2tib3gnKSB7XFxuICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuYXR0cignbmFtZScpID09PSBjaGVja2JveEdyb3VwTmFtZSkgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIGNoZWNrYm94R3JvdXBOYW1lID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmF0dHIoJ25hbWUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFjYy5wdXNoKF90aGlzLnZhbGlkYXRlSW5wdXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKSk7XFxuICAgICAgfSk7XFxuICAgICAgdmFyIG5vRXJyb3IgPSBhY2MuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuZWFjaChmdW5jdGlvbiAoaSwgZWxlbSkge1xcbiAgICAgICAgdmFyICRlbGVtID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW0pOyAvLyBFbnN1cmUgYTExeSBhdHRyaWJ1dGVzIGFyZSBzZXRcXG5cXG4gICAgICAgIGlmIChfdGhpczgub3B0aW9ucy5hMTF5QXR0cmlidXRlcykgX3RoaXM4LmFkZEdsb2JhbEVycm9yQTExeUF0dHJpYnV0ZXMoJGVsZW0pOyAvLyBTaG93IG9yIGhpZGUgdGhlIGVycm9yXFxuXFxuICAgICAgICAkZWxlbS5jc3MoJ2Rpc3BsYXknLCBub0Vycm9yID8gJ25vbmUnIDogJ2Jsb2NrJyk7XFxuICAgICAgfSk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBpcyBmaW5pc2hlZCB2YWxpZGF0aW5nLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgZm9ybXZhbGlkLnpmLmFiaWRlYCBvciBgZm9ybWludmFsaWQuemYuYWJpZGVgLlxcbiAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGZvcm0uXFxuICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm12YWxpZFxcbiAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtaW52YWxpZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigobm9FcnJvciA/ICdmb3JtdmFsaWQnIDogJ2Zvcm1pbnZhbGlkJykgKyAnLnpmLmFiaWRlJywgW3RoaXMuJGVsZW1lbnRdKTtcXG4gICAgICByZXR1cm4gbm9FcnJvcjtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgdGV4dCBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB0aGUgcGF0dGVybiBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZS4gSWYgbm8gbWF0Y2hpbmcgcGF0dGVybiBpcyBmb3VuZCwgcmV0dXJucyB0cnVlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGEgdGV4dCBpbnB1dCBIVE1MIGVsZW1lbnRcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSBzdHJpbmcgdmFsdWUgb2Ygb25lIG9mIHRoZSBSZWdFeCBwYXR0ZXJucyBpbiBBYmlkZS5vcHRpb25zLnBhdHRlcm5zXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIHBhdHRlcm4gc3BlY2lmaWVkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ2YWxpZGF0ZVRleHRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVUZXh0KCRlbCwgcGF0dGVybikge1xcbiAgICAgIC8vIEEgcGF0dGVybiBjYW4gYmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgYmUgaW5mZXJlZCBmcm9tIHRoZSBpbnB1dCdzIFxcXCJwYXR0ZXJuXFxcIiBhdHRyaWJ1dGUsIG9yIGl0J3MgXFxcInR5cGVcXFwiIGF0dHJpYnV0ZVxcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuIHx8ICRlbC5hdHRyKCdkYXRhLXBhdHRlcm4nKSB8fCAkZWwuYXR0cigncGF0dGVybicpIHx8ICRlbC5hdHRyKCd0eXBlJyk7XFxuICAgICAgdmFyIGlucHV0VGV4dCA9ICRlbC52YWwoKTtcXG4gICAgICB2YXIgdmFsaWQgPSB0cnVlO1xcblxcbiAgICAgIGlmIChpbnB1dFRleHQubGVuZ3RoKSB7XFxuICAgICAgICAvLyBJZiB0aGUgcGF0dGVybiBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgaXMgaW4gQWJpZGUncyBsaXN0IG9mIHBhdHRlcm5zLCB0aGVuIHRlc3QgdGhhdCByZWdleHBcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF0dGVybnMuaGFzT3duUHJvcGVydHkocGF0dGVybikpIHtcXG4gICAgICAgICAgdmFsaWQgPSB0aGlzLm9wdGlvbnMucGF0dGVybnNbcGF0dGVybl0udGVzdChpbnB1dFRleHQpO1xcbiAgICAgICAgfSAvLyBJZiB0aGUgcGF0dGVybiBuYW1lIGlzbid0IGFsc28gdGhlIHR5cGUgYXR0cmlidXRlIG9mIHRoZSBmaWVsZCwgdGhlbiB0ZXN0IGl0IGFzIGEgcmVnZXhwXFxuICAgICAgICBlbHNlIGlmIChwYXR0ZXJuICE9PSAkZWwuYXR0cigndHlwZScpKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBuZXcgUmVnRXhwKHBhdHRlcm4pLnRlc3QoaW5wdXRUZXh0KTtcXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdmFsaWQ7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHJhZGlvIGlucHV0IGlzIHZhbGlkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlcXVpcmVkIGFuZCBzZWxlY3RlZC4gQWx0aG91Z2ggdGhlIGZ1bmN0aW9uIHRhcmdldHMgYSBzaW5nbGUgYDxpbnB1dD5gLCBpdCB2YWxpZGF0ZXMgYnkgY2hlY2tpbmcgdGhlIGByZXF1aXJlZGAgYW5kIGBjaGVja2VkYCBwcm9wZXJ0aWVzIG9mIGFsbCByYWRpbyBidXR0b25zIGluIGl0cyBncm91cC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXQgbGVhc3Qgb25lIHJhZGlvIGlucHV0IGhhcyBiZWVuIHNlbGVjdGVkIChpZiBpdCdzIHJlcXVpcmVkKVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsaWRhdGVSYWRpb1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVJhZGlvKGdyb3VwTmFtZSkge1xcbiAgICAgIC8vIElmIGF0IGxlYXN0IG9uZSByYWRpbyBpbiB0aGUgZ3JvdXAgaGFzIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZSwgdGhlIGdyb3VwIGlzIGNvbnNpZGVyZWQgcmVxdWlyZWRcXG4gICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcXG4gICAgICB2YXIgJGdyb3VwID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCI6cmFkaW9bbmFtZT1cXFxcXFxcIlxcXCIuY29uY2F0KGdyb3VwTmFtZSwgXFxcIlxcXFxcXFwiXVxcXCIpKTtcXG4gICAgICB2YXIgdmFsaWQgPSBmYWxzZSxcXG4gICAgICAgICAgcmVxdWlyZWQgPSBmYWxzZTsgLy8gRm9yIHRoZSBncm91cCB0byBiZSByZXF1aXJlZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIHJlcXVpcmVkXFxuXFxuICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcXG4gICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZSkuYXR0cigncmVxdWlyZWQnKSkge1xcbiAgICAgICAgICByZXF1aXJlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgaWYgKCFyZXF1aXJlZCkgdmFsaWQgPSB0cnVlO1xcblxcbiAgICAgIGlmICghdmFsaWQpIHtcXG4gICAgICAgIC8vIEZvciB0aGUgZ3JvdXAgdG8gYmUgdmFsaWQsIGF0IGxlYXN0IG9uZSByYWRpbyBuZWVkcyB0byBiZSBjaGVja2VkXFxuICAgICAgICAkZ3JvdXAuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xcbiAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUpLnByb3AoJ2NoZWNrZWQnKSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB2YWxpZDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgY2hlY2tib3ggaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgaXQgaXMgcmVxdWlyZWQgYW5kIGNoZWNrZWQuIEFsdGhvdWdoIHRoZSBmdW5jdGlvbiB0YXJnZXRzIGEgc2luZ2xlIGA8aW5wdXQ+YCwgaXQgdmFsaWRhdGVzIGJ5IGNoZWNraW5nIHRoZSBgcmVxdWlyZWRgIGFuZCBgY2hlY2tlZGAgcHJvcGVydGllcyBvZiBhbGwgY2hlY2tib3hlcyBpbiBpdHMgZ3JvdXAuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIGNoZWNrYm94IGdyb3VwXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXQgbGVhc3Qgb25lIGNoZWNrYm94IGlucHV0IGhhcyBiZWVuIGNoZWNrZWQgKGlmIGl0J3MgcmVxdWlyZWQpXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ2YWxpZGF0ZUNoZWNrYm94XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlQ2hlY2tib3goZ3JvdXBOYW1lKSB7XFxuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XFxuXFxuICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGNoZWNrYm94IGluIHRoZSBncm91cCBoYXMgdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLCB0aGUgZ3JvdXAgaXMgY29uc2lkZXJlZCByZXF1aXJlZFxcbiAgICAgIC8vIFBlciBXM0Mgc3BlYywgYWxsIGNoZWNrYm94ZXMgaW4gYSBncm91cCBzaG91bGQgaGF2ZSBgcmVxdWlyZWRgLCBidXQgd2UncmUgYmVpbmcgbmljZVxcbiAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIjpjaGVja2JveFtuYW1lPVxcXFxcXFwiXFxcIi5jb25jYXQoZ3JvdXBOYW1lLCBcXFwiXFxcXFxcXCJdXFxcIikpO1xcbiAgICAgIHZhciB2YWxpZCA9IGZhbHNlLFxcbiAgICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxcbiAgICAgICAgICBtaW5SZXF1aXJlZCA9IDEsXFxuICAgICAgICAgIGNoZWNrZWQgPSAwOyAvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHJlcXVpcmVkLCBhdCBsZWFzdCBvbmUgY2hlY2tib3ggbmVlZHMgdG8gYmUgcmVxdWlyZWRcXG5cXG4gICAgICAkZ3JvdXAuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xcbiAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlKS5hdHRyKCdyZXF1aXJlZCcpKSB7XFxuICAgICAgICAgIHJlcXVpcmVkID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBpZiAoIXJlcXVpcmVkKSB2YWxpZCA9IHRydWU7XFxuXFxuICAgICAgaWYgKCF2YWxpZCkge1xcbiAgICAgICAgLy8gQ291bnQgY2hlY2tlZCBjaGVja2JveGVzIHdpdGhpbiB0aGUgZ3JvdXBcXG4gICAgICAgIC8vIFVzZSBkYXRhLW1pbi1yZXF1aXJlZCBpZiBhdmFpbGFibGUgKGRlZmF1bHQ6IDEpXFxuICAgICAgICAkZ3JvdXAuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xcbiAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUpLnByb3AoJ2NoZWNrZWQnKSkge1xcbiAgICAgICAgICAgIGNoZWNrZWQrKztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodHlwZW9mIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlKS5hdHRyKCdkYXRhLW1pbi1yZXF1aXJlZCcpICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIG1pblJlcXVpcmVkID0gcGFyc2VJbnQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUpLmF0dHIoJ2RhdGEtbWluLXJlcXVpcmVkJykpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTsgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgdGhlIG1pblJlcXVpcmVkIGFtb3VudCBvZiBjaGVja2JveGVzIGhhdmUgdG8gYmUgY2hlY2tlZFxcblxcbiAgICAgICAgaWYgKGNoZWNrZWQgPj0gbWluUmVxdWlyZWQpIHtcXG4gICAgICAgICAgdmFsaWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gU2tpcCB2YWxpZGF0aW9uIGlmIG1vcmUgdGhhbiAxIGNoZWNrYm94IGhhdmUgdG8gYmUgY2hlY2tlZCBBTkQgaWYgdGhlIGZvcm0gaGFzbid0IGdvdCBzdWJtaXR0ZWQgeWV0IChvdGhlcndpc2UgaXQgd2lsbCBhbHJlYWR5IHNob3cgYW4gZXJyb3IgZHVyaW5nIHRoZSBmaXJzdCBmaWxsIGluKVxcblxcblxcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkICE9PSB0cnVlICYmIG1pblJlcXVpcmVkID4gMSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSAvLyBSZWZyZXNoIGVycm9yIGNsYXNzIGZvciBhbGwgaW5wdXRcXG5cXG5cXG4gICAgICAkZ3JvdXAuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xcbiAgICAgICAgaWYgKCF2YWxpZCkge1xcbiAgICAgICAgICBfdGhpczkuYWRkRXJyb3JDbGFzc2VzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlKSwgWydyZXF1aXJlZCddKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIF90aGlzOS5yZW1vdmVFcnJvckNsYXNzZXMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUpKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdmFsaWQ7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERldGVybWluZXMgaWYgYSBzZWxlY3RlZCBpbnB1dCBwYXNzZXMgYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi4gTXVsdGlwbGUgdmFsaWRhdGlvbnMgY2FuIGJlIHVzZWQsIGlmIHBhc3NlZCB0byB0aGUgZWxlbWVudCB3aXRoIGBkYXRhLXZhbGlkYXRvcj1cXFwiZm9vIGJhciBiYXpcXFwiYCBpbiBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0ZWQuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgaW5wdXQgZWxlbWVudC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbGlkYXRvcnMgLSBhIHN0cmluZyBvZiBmdW5jdGlvbiBuYW1lcyBtYXRjaGluZyBmdW5jdGlvbnMgaW4gdGhlIEFiaWRlLm9wdGlvbnMudmFsaWRhdG9ycyBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVxdWlyZWQgLSBzZWxmIGV4cGxhbmF0b3J5P1xcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHZhbGlkYXRpb25zIHBhc3NlZC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm1hdGNoVmFsaWRhdGlvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3JzLCByZXF1aXJlZCkge1xcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcXG5cXG4gICAgICByZXF1aXJlZCA9IHJlcXVpcmVkID8gdHJ1ZSA6IGZhbHNlO1xcbiAgICAgIHZhciBjbGVhciA9IHZhbGlkYXRvcnMuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczEwLm9wdGlvbnMudmFsaWRhdG9yc1t2XSgkZWwsIHJlcXVpcmVkLCAkZWwucGFyZW50KCkpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBjbGVhci5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlc2V0cyBmb3JtIGlucHV0cyBhbmQgc3R5bGVzXFxuICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtcmVzZXRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlc2V0Rm9ybVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEZvcm0oKSB7XFxuICAgICAgdmFyICRmb3JtID0gdGhpcy4kZWxlbWVudCxcXG4gICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucztcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIi5cXFwiLmNvbmNhdChvcHRzLmxhYmVsRXJyb3JDbGFzcyksICRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiLlxcXCIuY29uY2F0KG9wdHMuaW5wdXRFcnJvckNsYXNzKSwgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmlucHV0RXJyb3JDbGFzcyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJcXFwiLmNvbmNhdChvcHRzLmZvcm1FcnJvclNlbGVjdG9yLCBcXFwiLlxcXCIpLmNvbmNhdChvcHRzLmZvcm1FcnJvckNsYXNzKSkucmVtb3ZlQ2xhc3Mob3B0cy5mb3JtRXJyb3JDbGFzcyk7XFxuICAgICAgJGZvcm0uZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJzppbnB1dCcsICRmb3JtKS5ub3QoJzpidXR0b24sIDpzdWJtaXQsIDpyZXNldCwgOmhpZGRlbiwgOnJhZGlvLCA6Y2hlY2tib3gsIFtkYXRhLWFiaWRlLWlnbm9yZV0nKS52YWwoJycpLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxcbiAgICAgIH0pO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnOmlucHV0OnJhZGlvJywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSkuYXR0cih7XFxuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXFxuICAgICAgfSk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCc6aW5wdXQ6Y2hlY2tib3gnLCAkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKS5hdHRyKHtcXG4gICAgICAgICdkYXRhLWludmFsaWQnOiBudWxsLFxcbiAgICAgICAgJ2FyaWEtaW52YWxpZCc6IG51bGxcXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBmb3JtIGhhcyBiZWVuIHJlc2V0LlxcbiAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtcmVzZXRcXG4gICAgICAgKi9cXG5cXG4gICAgICAkZm9ybS50cmlnZ2VyKCdmb3JtcmVzZXQuemYuYWJpZGUnLCBbJGZvcm1dKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgQWJpZGUuXFxuICAgICAqIFJlbW92ZXMgZXJyb3Igc3R5bGVzIGFuZCBjbGFzc2VzIGZyb20gZWxlbWVudHMsIHdpdGhvdXQgcmVzZXR0aW5nIHRoZWlyIHZhbHVlcy5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5hYmlkZScpLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XFxuICAgICAgdGhpcy4kaW5wdXRzLm9mZignLmFiaWRlJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5yZW1vdmVFcnJvckNsYXNzZXMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLiRzdWJtaXRzLm9mZignLmFiaWRlJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBBYmlkZTtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlBsdWdpblxcXCJdKTtcXG4vKipcXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cXG4gKi9cXG5cXG5cXG5BYmlkZS5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogVGhlIGRlZmF1bHQgZXZlbnQgdG8gdmFsaWRhdGUgaW5wdXRzLiBDaGVja2JveGVzIGFuZCByYWRpb3MgdmFsaWRhdGUgaW1tZWRpYXRlbHkuXFxuICAgKiBSZW1vdmUgb3IgY2hhbmdlIHRoaXMgdmFsdWUgZm9yIG1hbnVhbCB2YWxpZGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUgez9zdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnZmllbGRDaGFuZ2UnXFxuICAgKi9cXG4gIHZhbGlkYXRlT246ICdmaWVsZENoYW5nZScsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXQgbGFiZWxzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy1pbnZhbGlkLWxhYmVsJ1xcbiAgICovXFxuICBsYWJlbEVycm9yQ2xhc3M6ICdpcy1pbnZhbGlkLWxhYmVsJyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byBpbnB1dHMgb24gZmFpbGVkIHZhbGlkYXRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2lzLWludmFsaWQtaW5wdXQnXFxuICAgKi9cXG4gIGlucHV0RXJyb3JDbGFzczogJ2lzLWludmFsaWQtaW5wdXQnLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBzZWxlY3RvciB0byB1c2UgdG8gdGFyZ2V0IEZvcm0gRXJyb3JzIGZvciBzaG93L2hpZGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJy5mb3JtLWVycm9yJ1xcbiAgICovXFxuICBmb3JtRXJyb3JTZWxlY3RvcjogJy5mb3JtLWVycm9yJyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYWRkZWQgdG8gRm9ybSBFcnJvcnMgb24gZmFpbGVkIHZhbGlkYXRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2lzLXZpc2libGUnXFxuICAgKi9cXG4gIGZvcm1FcnJvckNsYXNzOiAnaXMtdmlzaWJsZScsXFxuXFxuICAvKipcXG4gICAqIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgaW5zZXJ0IHdoZW4gcG9zc2libGU6XFxuICAgKiAtIGBbYXJpYS1kZXNjcmliZWRieV1gIG9uIGZpZWxkc1xcbiAgICogLSBgW3JvbGU9YWxlcnRdYCBvbiBmb3JtIGVycm9ycyBhbmQgYFtmb3JdYCBvbiBmb3JtIGVycm9yIGxhYmVsc1xcbiAgICogLSBgW2FyaWEtbGl2ZV1gIG9uIGdsb2JhbCBlcnJvcnMgYFtkYXRhLWFiaWRlLWVycm9yXWAgKHNlZSBvcHRpb24gYGExMXlFcnJvckxldmVsYCkuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYTExeUF0dHJpYnV0ZXM6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIFthcmlhLWxpdmVdIGF0dHJpYnV0ZSB2YWx1ZSB0byBiZSBhcHBsaWVkIG9uIGdsb2JhbCBlcnJvcnMgYFtkYXRhLWFiaWRlLWVycm9yXWAuXFxuICAgKiBPcHRpb25zIGFyZTogJ2Fzc2VydGl2ZScsICdwb2xpdGUnIGFuZCAnb2ZmJy9udWxsXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9BUklBX0xpdmVfUmVnaW9uc1xcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhc3NlcnRpdmUnXFxuICAgKi9cXG4gIGExMXlFcnJvckxldmVsOiAnYXNzZXJ0aXZlJyxcXG5cXG4gIC8qKlxcbiAgICogU2V0IHRvIHRydWUgdG8gdmFsaWRhdGUgdGV4dCBpbnB1dHMgb24gYW55IHZhbHVlIGNoYW5nZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgbGl2ZVZhbGlkYXRlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogU2V0IHRvIHRydWUgdG8gdmFsaWRhdGUgaW5wdXRzIG9uIGJsdXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHZhbGlkYXRlT25CbHVyOiBmYWxzZSxcXG4gIHBhdHRlcm5zOiB7XFxuICAgIGFscGhhOiAvXlthLXpBLVpdKyQvLFxcbiAgICBhbHBoYV9udW1lcmljOiAvXlthLXpBLVowLTldKyQvLFxcbiAgICBpbnRlZ2VyOiAvXlstK10/XFxcXGQrJC8sXFxuICAgIG51bWJlcjogL15bLStdP1xcXFxkKig/OltcXFxcLlxcXFwsXVxcXFxkKyk/JC8sXFxuICAgIC8vIGFtZXgsIHZpc2EsIGRpbmVyc1xcbiAgICBjYXJkOiAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoPzoyMjJbMS05XXwyWzMtNl1bMC05XXsyfXwyN1swLTFdWzAtOV18MjcyMClbMC05XXsxMn18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcXFxkezN9KVxcXFxkezExfSkkLyxcXG4gICAgY3Z2OiAvXihbMC05XSl7Myw0fSQvLFxcbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9zdGF0ZXMtb2YtdGhlLXR5cGUtYXR0cmlidXRlLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcXG4gICAgZW1haWw6IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcXFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyxcXG4gICAgLy8gRnJvbSBDb21tb25SZWdleEpTIChAdGFseXNzb25vYylcXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RhbHlzc29ub2MvQ29tbW9uUmVnZXhKUy9ibG9iL2UyOTAxYjlmNTcyMjJiYzE0MDY5ZGM4ZjA1OThkNWY0MTI1NTU0MTEvbGliL2NvbW1vbnJlZ2V4LmpzI0w3NlxcbiAgICAvLyBGb3IgbW9yZSByZXN0cmljdGl2ZSBVUkwgUmVnZXhzLCBzZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4LlxcbiAgICB1cmw6IC9eKCg/OihodHRwcz98ZnRwcz98ZmlsZXxzc2h8c2Z0cCk6XFxcXC9cXFxcL3x3d3dcXFxcZHswLDN9Wy5dfFthLXowLTkuXFxcXC1dK1suXVthLXpdezIsNH1cXFxcLykoPzpbXlxcXFxzKCk8Pl0rfFxcXFwoKD86W15cXFxccygpPD5dK3woPzpcXFxcKFteXFxcXHMoKTw+XStcXFxcKSkpKlxcXFwpKSsoPzpcXFxcKCg/OlteXFxcXHMoKTw+XSt8KD86XFxcXChbXlxcXFxzKCk8Pl0rXFxcXCkpKSpcXFxcKXxbXlxcXFxzYCEoKVxcXFxbXFxcXF17fTs6XFxcXCdcXFwiLiw8Pj9cXFxceGFiXFxcXHhiYlxcXFx1MjAxY1xcXFx1MjAxZFxcXFx1MjAxOFxcXFx1MjAxOV0pKSQvLFxcbiAgICAvLyBhYmMuZGVcXG4gICAgZG9tYWluOiAvXihbYS16QS1aMC05XShbYS16QS1aMC05XFxcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcXFwuKStbYS16QS1aXXsyLDh9JC8sXFxuICAgIGRhdGV0aW1lOiAvXihbMC0yXVswLTldezN9KVxcXFwtKFswLTFdWzAtOV0pXFxcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSlcXFxcOihbMC01XVswLTldKShafChbXFxcXC1cXFxcK10oWzAtMV1bMC05XSlcXFxcOjAwKSkkLyxcXG4gICAgLy8gWVlZWS1NTS1ERFxcbiAgICBkYXRlOiAvKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyxcXG4gICAgLy8gSEg6TU06U1NcXG4gICAgdGltZTogL14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLFxcbiAgICBkYXRlSVNPOiAvXlxcXFxkezR9W1xcXFwvXFxcXC1dXFxcXGR7MSwyfVtcXFxcL1xcXFwtXVxcXFxkezEsMn0kLyxcXG4gICAgLy8gTU0vREQvWVlZWVxcbiAgICBtb250aF9kYXlfeWVhcjogL14oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXVxcXFxkezR9JC8sXFxuICAgIC8vIEREL01NL1lZWVlcXG4gICAgZGF5X21vbnRoX3llYXI6IC9eKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcXFwvLl1cXFxcZHs0fSQvLFxcbiAgICAvLyAjRkZGIG9yICNGRkZGRkZcXG4gICAgY29sb3I6IC9eIz8oW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pJC8sXFxuICAgIC8vIERvbWFpbiB8fCBVUkxcXG4gICAgd2Vic2l0ZToge1xcbiAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QodGV4dCkge1xcbiAgICAgICAgcmV0dXJuIEFiaWRlLmRlZmF1bHRzLnBhdHRlcm5zWydkb21haW4nXS50ZXN0KHRleHQpIHx8IEFiaWRlLmRlZmF1bHRzLnBhdHRlcm5zWyd1cmwnXS50ZXN0KHRleHQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogT3B0aW9uYWwgdmFsaWRhdGlvbiBmdW5jdGlvbnMgdG8gYmUgdXNlZC4gYGVxdWFsVG9gIGJlaW5nIHRoZSBvbmx5IGRlZmF1bHQgaW5jbHVkZWQgZnVuY3Rpb24uXFxuICAgKiBGdW5jdGlvbnMgc2hvdWxkIHJldHVybiBvbmx5IGEgYm9vbGVhbiBpZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LiBGdW5jdGlvbnMgYXJlIGdpdmVuIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxcbiAgICogZWwgOiBUaGUgalF1ZXJ5IGVsZW1lbnQgdG8gdmFsaWRhdGUuXFxuICAgKiByZXF1aXJlZCA6IEJvb2xlYW4gdmFsdWUgb2YgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBiZSBwcmVzZW50IG9yIG5vdC5cXG4gICAqIHBhcmVudCA6IFRoZSBkaXJlY3QgcGFyZW50IG9mIHRoZSBpbnB1dC5cXG4gICAqIEBvcHRpb25cXG4gICAqL1xcbiAgdmFsaWRhdG9yczoge1xcbiAgICBlcXVhbFRvOiBmdW5jdGlvbiBlcXVhbFRvKGVsLCByZXF1aXJlZCwgcGFyZW50KSB7XFxuICAgICAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiI1xcXCIuY29uY2F0KGVsLmF0dHIoJ2RhdGEtZXF1YWx0bycpKSkudmFsKCkgPT09IGVsLnZhbCgpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLmFiaWRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5hY2NvcmRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBBY2NvcmRpb24gKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkFjY29yZGlvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWNjb3JkaW9uOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogQWNjb3JkaW9uIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqL1xcblxcbnZhciBBY2NvcmRpb24gPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEFjY29yZGlvbiwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBBY2NvcmRpb24oKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvcmRpb24pO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFjY29yZGlvbikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoQWNjb3JkaW9uLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBBY2NvcmRpb25cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGEgcGxhaW4gb2JqZWN0IHdpdGggc2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9ucy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIEFjY29yZGlvbi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0FjY29yZGlvbic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0ucmVnaXN0ZXIoJ0FjY29yZGlvbicsIHtcXG4gICAgICAgICdFTlRFUic6ICd0b2dnbGUnLFxcbiAgICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXFxuICAgICAgICAnQVJST1dfRE9XTic6ICduZXh0JyxcXG4gICAgICAgICdBUlJPV19VUCc6ICdwcmV2aW91cydcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGFjY29yZGlvbiBieSBhbmltYXRpbmcgdGhlIHByZXNldCBhY3RpdmUgcGFuZShzKS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3JvbGUnLCAndGFibGlzdCcpO1xcbiAgICAgIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1hY2NvcmRpb24taXRlbV0nKTtcXG4gICAgICB0aGlzLiR0YWJzLmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAncHJlc2VudGF0aW9uJ1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbiAoaWR4LCBlbCkge1xcbiAgICAgICAgdmFyICRlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCksXFxuICAgICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxcbiAgICAgICAgICAgIGlkID0gJGNvbnRlbnRbMF0uaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ2FjY29yZGlvbicpLFxcbiAgICAgICAgICAgIGxpbmtJZCA9IGVsLmlkID8gXFxcIlxcXCIuY29uY2F0KGVsLmlkLCBcXFwiLWxhYmVsXFxcIikgOiBcXFwiXFxcIi5jb25jYXQoaWQsIFxcXCItbGFiZWxcXFwiKTtcXG4gICAgICAgICRlbC5maW5kKCdhOmZpcnN0JykuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXFxuICAgICAgICAgICdyb2xlJzogJ3RhYicsXFxuICAgICAgICAgICdpZCc6IGxpbmtJZCxcXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxcbiAgICAgICAgfSk7XFxuICAgICAgICAkY29udGVudC5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLFxcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxcbiAgICAgICAgICAnaWQnOiBpZFxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgdmFyICRpbml0QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xcblxcbiAgICAgIGlmICgkaW5pdEFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIC8vIFNhdmUgdXAgdGhlIGluaXRpYWwgaGFzaCB0byByZXR1cm4gdG8gaXQgbGF0ZXIgd2hlbiBnb2luZyBiYWNrIGluIGhpc3RvcnlcXG4gICAgICAgIHRoaXMuX2luaXRpYWxBbmNob3IgPSAkaW5pdEFjdGl2ZS5wcmV2KCdhJykuYXR0cignaHJlZicpO1xcblxcbiAgICAgICAgdGhpcy5fb3BlblNpbmdsZVRhYigkaW5pdEFjdGl2ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYW5jaG9yID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XFxuXFxuICAgICAgICBpZiAoIWFuY2hvci5sZW5ndGgpIHtcXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIHN0aWxsIGluaXRpYWxpemluZyBhbmQgdGhlcmUgaXMgbm8gYW5jaG9yLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cXG4gICAgICAgICAgaWYgKF90aGlzMi5faXNJbml0aWFsaXppbmcpIHJldHVybjsgLy8gT3RoZXJ3aXNlLCBtb3ZlIHRvIHRoZSBpbml0aWFsIGFuY2hvclxcblxcbiAgICAgICAgICBpZiAoX3RoaXMyLl9pbml0aWFsQW5jaG9yKSBhbmNob3IgPSBfdGhpczIuX2luaXRpYWxBbmNob3I7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgJGFuY2hvciA9IGFuY2hvciAmJiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoYW5jaG9yKTtcXG5cXG4gICAgICAgIHZhciAkbGluayA9IGFuY2hvciAmJiBfdGhpczIuJGVsZW1lbnQuZmluZChcXFwiW2hyZWYkPVxcXFxcXFwiXFxcIi5jb25jYXQoYW5jaG9yLCBcXFwiXFxcXFxcXCJdXFxcIikpOyAvLyBXaGV0aGVyIHRoZSBhbmNob3IgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGZvdW5kIGlzIHBhcnQgb2YgdGhpcyBlbGVtZW50XFxuXFxuXFxuICAgICAgICB2YXIgaXNPd25BbmNob3IgPSAhISgkYW5jaG9yLmxlbmd0aCAmJiAkbGluay5sZW5ndGgpO1xcblxcbiAgICAgICAgaWYgKGlzT3duQW5jaG9yKSB7XFxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFuY2hvciBmb3IgdGhlIGhhc2gsIG9wZW4gaXQgKGlmIG5vdCBhbHJlYWR5IGFjdGl2ZSlcXG4gICAgICAgICAgaWYgKCRhbmNob3IgJiYgJGxpbmsgJiYgJGxpbmsubGVuZ3RoKSB7XFxuICAgICAgICAgICAgaWYgKCEkbGluay5wYXJlbnQoJ1tkYXRhLWFjY29yZGlvbi1pdGVtXScpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICAgICAgX3RoaXMyLl9vcGVuU2luZ2xlVGFiKCRhbmNob3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBPdGhlcndpc2UsIGNsb3NlIGV2ZXJ5dGhpbmdcXG4gICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBfdGhpczIuX2Nsb3NlQWxsVGFicygpO1xcbiAgICAgICAgICAgIH0gLy8gUm9sbCB1cCBhIGxpdHRsZSB0byBzaG93IHRoZSB0aXRsZXNcXG5cXG5cXG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmRlZXBMaW5rU211ZGdlKSB7XFxuICAgICAgICAgICAgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwib25Mb2FkXFxcIl0pKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xcblxcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogb2Zmc2V0LnRvcCAtIF90aGlzMi5vcHRpb25zLmRlZXBMaW5rU211ZGdlT2Zmc2V0XFxuICAgICAgICAgICAgICB9LCBfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZURlbGF5KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBkZWVwbGlua2VkIGF0IHBhZ2Vsb2FkXFxuICAgICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jZGVlcGxpbmtcXG4gICAgICAgICAgICovXFxuXFxuXFxuICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkZWVwbGluay56Zi5hY2NvcmRpb24nLCBbJGxpbmssICRhbmNob3JdKTtcXG4gICAgICAgIH1cXG4gICAgICB9OyAvL3VzZSBicm93c2VyIHRvIG9wZW4gYSB0YWIsIGlmIGl0IGV4aXN0cyBpbiB0aGlzIHRhYnNldFxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgdGhpcy5faXNJbml0aWFsaXppbmcgPSBmYWxzZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBhY2NvcmRpb24uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRlbGVtID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpO1xcbiAgICAgICAgdmFyICR0YWJDb250ZW50ID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xcblxcbiAgICAgICAgaWYgKCR0YWJDb250ZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICAkZWxlbS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uJykub24oJ2NsaWNrLnpmLmFjY29yZGlvbicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XFxuICAgICAgICAgIH0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJLZXlib2FyZFxcXCJdLmhhbmRsZUtleShlLCAnQWNjb3JkaW9uJywge1xcbiAgICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ubmV4dCgpLmZpbmQoJ2EnKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHtcXG4gICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcXG4gICAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ucHJldigpLmZpbmQoJ2EnKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHtcXG4gICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGVkIGNvbnRlbnQgcGFuZSdzIG9wZW4vY2xvc2Ugc3RhdGUuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0galF1ZXJ5IG9iamVjdCBvZiB0aGUgcGFuZSB0byB0b2dnbGUgKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpIHtcXG4gICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KCdbZGF0YS1hY2NvcmRpb25dJykuaXMoJ1tkaXNhYmxlZF0nKSkge1xcbiAgICAgICAgY29uc29sZS5pbmZvKCdDYW5ub3QgdG9nZ2xlIGFuIGFjY29yZGlvbiB0aGF0IGlzIGRpc2FibGVkLicpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHtcXG4gICAgICAgIHRoaXMudXAoJHRhcmdldCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZG93bigkdGFyZ2V0KTtcXG4gICAgICB9IC8vZWl0aGVyIHJlcGxhY2Ugb3IgdXBkYXRlIGJyb3dzZXIgaGlzdG9yeVxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIHZhciBhbmNob3IgPSAkdGFyZ2V0LnByZXYoJ2EnKS5hdHRyKCdocmVmJyk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcXG4gICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBhbmNob3IpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBhbmNob3IpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgdGhlIGFjY29yZGlvbiB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHBhbmUgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI2Rvd25cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJkb3duXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd24oJHRhcmdldCkge1xcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKS5pcygnW2Rpc2FibGVkXScpKSB7XFxuICAgICAgICBjb25zb2xlLmluZm8oJ0Nhbm5vdCBjYWxsIGRvd24gb24gYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHRoaXMuX29wZW5UYWIoJHRhcmdldCk7ZWxzZSB0aGlzLl9vcGVuU2luZ2xlVGFiKCR0YXJnZXQpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICogSXQgbWF5IGJlIGlnbm9yZWQgaWYgdGhlIEFjY29yZGlvbiBvcHRpb25zIGRvbid0IGFsbG93IGl0LlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gY2xvc2UgKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiN1cFxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInVwXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwKCR0YXJnZXQpIHtcXG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5pcygnW2Rpc2FibGVkXScpKSB7XFxuICAgICAgICBjb25zb2xlLmluZm8oJ0Nhbm5vdCBjYWxsIHVwIG9uIGFuIGFjY29yZGlvbiB0aGF0IGlzIGRpc2FibGVkLicpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gRG9uJ3QgY2xvc2UgdGhlIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBjbG9zZWRcXG5cXG5cXG4gICAgICB2YXIgJHRhcmdldEl0ZW0gPSAkdGFyZ2V0LnBhcmVudCgpO1xcbiAgICAgIGlmICghJHRhcmdldEl0ZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSByZXR1cm47IC8vIERvbid0IGNsb3NlIHRoZSBpdGVtIGlmIHRoZXJlIGlzIG5vIG90aGVyIGFjdGl2ZSBpdGVtICh1bmxlc3Mgd2l0aCBgYWxsb3dBbGxDbG9zZWRgKVxcblxcbiAgICAgIHZhciAkb3RoZXJzSXRlbXMgPSAkdGFyZ2V0SXRlbS5zaWJsaW5ncygpO1xcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkICYmICEkb3RoZXJzSXRlbXMuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSByZXR1cm47XFxuXFxuICAgICAgdGhpcy5fY2xvc2VUYWIoJHRhcmdldCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE1ha2UgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YCB0aGUgb25seSBvcGVuZWQgdGFiLCBjbG9zaW5nIGFsbCBvdGhlcnMgdGFicy5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gdGFiIHRvIG9wZW4gKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfb3BlblNpbmdsZVRhYlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblNpbmdsZVRhYigkdGFyZ2V0KSB7XFxuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvdGhlcnMgYWN0aXZlIHRhYnMuXFxuICAgICAgdmFyICRhY3RpdmVDb250ZW50cyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XFxuXFxuICAgICAgaWYgKCRhY3RpdmVDb250ZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX2Nsb3NlVGFiKCRhY3RpdmVDb250ZW50cy5ub3QoJHRhcmdldCkpO1xcbiAgICAgIH0gLy8gVGhlbiBvcGVuIHRoZSB0YXJnZXQuXFxuXFxuXFxuICAgICAgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gdGFiIHRvIG9wZW4gKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX29wZW5UYWJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5UYWIoJHRhcmdldCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIHZhciAkdGFyZ2V0SXRlbSA9ICR0YXJnZXQucGFyZW50KCk7XFxuICAgICAgdmFyIHRhcmdldENvbnRlbnRJZCA9ICR0YXJnZXQuYXR0cignYXJpYS1sYWJlbGxlZGJ5Jyk7XFxuICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcXG4gICAgICAkdGFyZ2V0SXRlbS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIjXFxcIi5jb25jYXQodGFyZ2V0Q29udGVudElkKSkuYXR0cih7XFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWUsXFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHRydWVcXG4gICAgICB9KTtcXG4gICAgICAkdGFyZ2V0LmZpbmlzaCgpLnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0YWIgaXMgZG9uZSBvcGVuaW5nLlxcbiAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkb3duXFxuICAgICAgICAgKi9cXG4gICAgICAgIF90aGlzMy4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gY2xvc2UgKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiN1cFxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9jbG9zZVRhYlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xvc2VUYWIoJHRhcmdldCkge1xcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xcblxcbiAgICAgIHZhciAkdGFyZ2V0SXRlbSA9ICR0YXJnZXQucGFyZW50KCk7XFxuICAgICAgdmFyIHRhcmdldENvbnRlbnRJZCA9ICR0YXJnZXQuYXR0cignYXJpYS1sYWJlbGxlZGJ5Jyk7XFxuICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcbiAgICAgICR0YXJnZXRJdGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdCh0YXJnZXRDb250ZW50SWQpKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGZhbHNlXFxuICAgICAgfSk7XFxuICAgICAgJHRhcmdldC5maW5pc2goKS5zbGlkZVVwKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXFxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI3VwXFxuICAgICAgICAgKi9cXG4gICAgICAgIF90aGlzNC4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgYWxsIGFjdGl2ZSB0YWJzXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jdXBcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfY2xvc2VBbGxUYWJzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZUFsbFRhYnMoKSB7XFxuICAgICAgdmFyICRhY3RpdmVUYWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLmlzLWFjdGl2ZScpLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKTtcXG5cXG4gICAgICBpZiAoJGFjdGl2ZVRhYnMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLl9jbG9zZVRhYigkYWN0aXZlVGFicyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKS5zdG9wKHRydWUpLnNsaWRlVXAoMCkuY3NzKCdkaXNwbGF5JywgJycpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignLnpmLmFjY29yZGlvbicpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZignaGFzaGNoYW5nZScsIHRoaXMuX2NoZWNrRGVlcExpbmspO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEFjY29yZGlvbjtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5BY2NvcmRpb24uZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYW4gYWNjb3JkaW9uIHBhbmUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMjUwXFxuICAgKi9cXG4gIHNsaWRlU3BlZWQ6IDI1MCxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIG11bHRpRXhwYW5kOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFsbG93QWxsQ2xvc2VkOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogTGluayB0aGUgbG9jYXRpb24gaGFzaCB0byB0aGUgb3BlbiBwYW5lLlxcbiAgICogU2V0IHRoZSBsb2NhdGlvbiBoYXNoIHdoZW4gdGhlIG9wZW5lZCBwYW5lIGNoYW5nZXMsIGFuZCBvcGVuIGFuZCBzY3JvbGwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcGFuZSB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkZWVwTGluazogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgYWRqdXN0IHRoZSBkZWVwIGxpbmsgc2Nyb2xsIHRvIG1ha2Ugc3VyZSB0aGUgdG9wIG9mIHRoZSBhY2NvcmRpb24gcGFuZWwgaXMgdmlzaWJsZVxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkZWVwTGlua1NtdWRnZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIElmIGBkZWVwTGlua1NtdWRnZWAgaXMgZW5hYmxlZCwgYW5pbWF0aW9uIHRpbWUgKG1zKSBmb3IgdGhlIGRlZXAgbGluayBhZGp1c3RtZW50XFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMzAwXFxuICAgKi9cXG4gIGRlZXBMaW5rU211ZGdlRGVsYXk6IDMwMCxcXG5cXG4gIC8qKlxcbiAgICogSWYgYGRlZXBMaW5rU211ZGdlYCBpcyBlbmFibGVkLCB0aGUgb2Zmc2V0IGZvciBzY3JvbGxUb1R0b3AgdG8gcHJldmVudCBvdmVybGFwIGJ5IGEgc3RpY2t5IGVsZW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgcGFnZVxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgZGVlcExpbmtTbXVkZ2VPZmZzZXQ6IDAsXFxuXFxuICAvKipcXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgdXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgb3BlbiBhY2NvcmRpb25cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdXBkYXRlSGlzdG9yeTogZmFsc2VcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uYWNjb3JkaW9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQWNjb3JkaW9uTWVudSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQWNjb3JkaW9uTWVudVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWNjb3JkaW9uTWVudTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5uZXN0ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBBY2NvcmRpb25NZW51IG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uTWVudVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcXG4gKi9cXG5cXG52YXIgQWNjb3JkaW9uTWVudSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoQWNjb3JkaW9uTWVudSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBBY2NvcmRpb25NZW51KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWNjb3JkaW9uTWVudSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQWNjb3JkaW9uTWVudSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoQWNjb3JkaW9uTWVudSwgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBBY2NvcmRpb25NZW51XFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgQWNjb3JkaW9uTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0FjY29yZGlvbk1lbnUnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdBY2NvcmRpb25NZW51Jywge1xcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICdvcGVuJyxcXG4gICAgICAgICdBUlJPV19VUCc6ICd1cCcsXFxuICAgICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcXG4gICAgICAgICdBUlJPV19MRUZUJzogJ2Nsb3NlJyxcXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2VBbGwnXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gbWVudSBieSBoaWRpbmcgYWxsIG5lc3RlZCBtZW51cy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJOZXN0XFxcIl0uRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnYWNjb3JkaW9uJyk7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykubm90KCcuaXMtYWN0aXZlJykuc2xpZGVVcCgwKTsgLy8uZmluZCgnYScpLmNzcygncGFkZGluZy1sZWZ0JywgJzFyZW0nKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAndHJlZScsXFxuICAgICAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiB0aGlzLm9wdGlvbnMubXVsdGlPcGVuXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kbWVudUxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50Jyk7XFxuICAgICAgdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGxpbmtJZCA9IHRoaXMuaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ2FjYy1tZW51LWxpbmsnKSxcXG4gICAgICAgICAgICAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyksXFxuICAgICAgICAgICAgc3ViSWQgPSAkc3ViWzBdLmlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdhY2MtbWVudScpLFxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gJHN1Yi5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XFxuXFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wYXJlbnRMaW5rKSB7XFxuICAgICAgICAgIHZhciAkYW5jaG9yID0gJGVsZW0uY2hpbGRyZW4oJ2EnKTtcXG4gICAgICAgICAgJGFuY2hvci5jbG9uZSgpLnByZXBlbmRUbygkc3ViKS53cmFwKCc8bGkgZGF0YS1pcy1wYXJlbnQtbGluayBjbGFzcz1cXFwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtYWNjb3JkaW9uLXN1Ym1lbnUtaXRlbVxcXCI+PC9saT4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2hhcy1zdWJtZW51LXRvZ2dsZScpO1xcbiAgICAgICAgICAkZWxlbS5jaGlsZHJlbignYScpLmFmdGVyKCc8YnV0dG9uIGlkPVxcXCInICsgbGlua0lkICsgJ1xcXCIgY2xhc3M9XFxcInN1Ym1lbnUtdG9nZ2xlXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCInICsgc3ViSWQgKyAnXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCInICsgaXNBY3RpdmUgKyAnXFxcIiB0aXRsZT1cXFwiJyArIF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZVRleHQgKyAnXFxcIj48c3BhbiBjbGFzcz1cXFwic3VibWVudS10b2dnbGUtdGV4dFxcXCI+JyArIF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZVRleHQgKyAnPC9zcGFuPjwvYnV0dG9uPicpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgJGVsZW0uYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzdWJJZCxcXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGlzQWN0aXZlLFxcbiAgICAgICAgICAgICdpZCc6IGxpbmtJZFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICRzdWIuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsXFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6ICFpc0FjdGl2ZSxcXG4gICAgICAgICAgJ3JvbGUnOiAnZ3JvdXAnLFxcbiAgICAgICAgICAnaWQnOiBzdWJJZFxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAndHJlZWl0ZW0nXFxuICAgICAgfSk7XFxuICAgICAgdmFyIGluaXRQYW5lcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpO1xcblxcbiAgICAgIGlmIChpbml0UGFuZXMubGVuZ3RoKSB7XFxuICAgICAgICBpbml0UGFuZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLmRvd24oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBtZW51LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRzdWJtZW51ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xcblxcbiAgICAgICAgaWYgKCRzdWJtZW51Lmxlbmd0aCkge1xcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCcuc3VibWVudS10b2dnbGUnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnKS5vbignY2xpY2suemYuYWNjb3JkaW9uTWVudScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpLm9uKCdjbGljay56Zi5hY2NvcmRpb25NZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkc3VibWVudSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb25NZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCxcXG4gICAgICAgICAgICAkdGFyZ2V0ID0gJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XFxuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpICsgMSwgJGVsZW1lbnRzLmxlbmd0aCAtIDEpKS5maW5kKCdhJykuZmlyc3QoKTtcXG5cXG4gICAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XTp2aXNpYmxlJykubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAvLyBoYXMgb3BlbiBzdWIgbWVudVxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnQuZmluZCgnbGk6Zmlyc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5pcygnOmZpcnN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgICAgIC8vIGlzIGZpcnN0IGVsZW1lbnQgb2Ygc3ViIG1lbnVcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIC8vIGlmIHByZXZpb3VzIGVsZW1lbnQgaGFzIG9wZW4gc3ViIG1lbnVcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpbmQoJ2xpOmxhc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5pcygnOmxhc3QtY2hpbGQnKSkge1xcbiAgICAgICAgICAgICAgLy8gaXMgbGFzdCBlbGVtZW50IG9mIHN1YiBtZW51XFxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkubmV4dCgnbGknKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ0FjY29yZGlvbk1lbnUnLCB7XFxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XFxuICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICAgICAgX3RoaXMuZG93bigkdGFyZ2V0KTtcXG5cXG4gICAgICAgICAgICAgICR0YXJnZXQuZmluZCgnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgICAgaWYgKCR0YXJnZXQubGVuZ3RoICYmICEkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHtcXG4gICAgICAgICAgICAgIC8vIGNsb3NlIGFjdGl2ZSBzdWIgb2YgdGhpcyBpdGVtXFxuICAgICAgICAgICAgICBfdGhpcy51cCgkdGFyZ2V0KTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIC8vIGNsb3NlIGN1cnJlbnRseSBvcGVuIHN1YlxcbiAgICAgICAgICAgICAgX3RoaXMudXAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpKTtcXG5cXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgdXA6IGZ1bmN0aW9uIHVwKCkge1xcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkb3duOiBmdW5jdGlvbiBkb3duKCkge1xcbiAgICAgICAgICAgICRuZXh0RWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSk7XFxuXFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGNsb3NlQWxsOiBmdW5jdGlvbiBjbG9zZUFsbCgpIHtcXG4gICAgICAgICAgICBfdGhpcy5oaWRlQWxsKCk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQocHJldmVudERlZmF1bHQpIHtcXG4gICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pOyAvLy5hdHRyKCd0YWJpbmRleCcsIDApO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImhpZGVBbGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUFsbCgpIHtcXG4gICAgICB0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIGFsbCBwYW5lcyBvZiB0aGUgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzaG93QWxsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dBbGwoKSB7XFxuICAgICAgdGhpcy5kb3duKHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2Ugc3RhdGUgb2YgYSBzdWJtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSB0aGUgc3VibWVudSB0byB0b2dnbGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRvZ2dsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xcbiAgICAgIGlmICghJHRhcmdldC5pcygnOmFuaW1hdGVkJykpIHtcXG4gICAgICAgIGlmICghJHRhcmdldC5pcygnOmhpZGRlbicpKSB7XFxuICAgICAgICAgIHRoaXMudXAoJHRhcmdldCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLmRvd24oJHRhcmdldCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gU3ViLW1lbnUgdG8gb3Blbi5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZG93blxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZG93blxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICAvLyBJZiBoYXZpbmcgbXVsdGlwbGUgc3VibWVudXMgYWN0aXZlIGlzIGRpc2FibGVkLCBjbG9zZSBhbGwgdGhlIHN1Ym1lbnVzXFxuICAgICAgLy8gdGhhdCBhcmUgbm90IHBhcmVudHMgb3IgY2hpbGRyZW4gb2YgdGhlIHRhcmdldGVkIHN1Ym1lbnUuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlPcGVuKSB7XFxuICAgICAgICAvLyBUaGUgXFxcImJyYW5jaFxcXCIgb2YgdGhlIHRhcmdldHRlZCBzdWJtZW51LCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCB0b1xcbiAgICAgICAgLy8gdGhlIGFjdGl2ZSBzdWJtZW51cyBuZXN0ZWQgaW4gaXQuXFxuICAgICAgICB2YXIgJHRhcmdldEJyYW5jaCA9ICR0YXJnZXQucGFyZW50c1VudGlsKHRoaXMuJGVsZW1lbnQpLmFkZCgkdGFyZ2V0KS5hZGQoJHRhcmdldC5maW5kKCcuaXMtYWN0aXZlJykpOyAvLyBBbGwgdGhlIGFjdGl2ZSBzdWJtZW51cyB0aGF0IGFyZSBub3QgaW4gdGhlIGJyYW5jaC5cXG5cXG4gICAgICAgIHZhciAkb3RoZXJzQWN0aXZlU3VibWVudXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5ub3QoJHRhcmdldEJyYW5jaCk7XFxuICAgICAgICB0aGlzLnVwKCRvdGhlcnNBY3RpdmVTdWJtZW51cyk7XFxuICAgICAgfVxcblxcbiAgICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgICR0YXJnZXQucHJldignLnN1Ym1lbnUtdG9nZ2xlJykuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICR0YXJnZXQucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgICR0YXJnZXQuc2xpZGVEb3duKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBvcGVuaW5nLlxcbiAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbk1lbnUjZG93blxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb25NZW51JywgWyR0YXJnZXRdKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIHRoZSBzdWItbWVudSBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC4gQWxsIHN1Yi1tZW51cyBpbnNpZGUgdGhlIHRhcmdldCB3aWxsIGJlIGNsb3NlZCBhcyB3ZWxsLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIGNsb3NlLlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSN1cFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidXBcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXAoJHRhcmdldCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIHZhciAkc3VibWVudXMgPSAkdGFyZ2V0LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJyk7XFxuICAgICAgdmFyICRhbGxtZW51cyA9ICR0YXJnZXQuYWRkKCRzdWJtZW51cyk7XFxuICAgICAgJHN1Ym1lbnVzLnNsaWRlVXAoMCk7XFxuICAgICAgJGFsbG1lbnVzLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xcbiAgICAgICAgJGFsbG1lbnVzLnByZXYoJy5zdWJtZW51LXRvZ2dsZScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICRhbGxtZW51cy5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkdGFyZ2V0LnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXFxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpczMuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFjY29yZGlvbiBtZW51LlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNkZXN0cm95ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5zbGlkZURvd24oMCkuY3NzKCdkaXNwbGF5JywgJycpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtaXMtcGFyZW50LWxpbmtdJykuZGV0YWNoKCk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJy5oYXMtc3VibWVudS10b2dnbGUnKS5yZW1vdmVDbGFzcygnaGFzLXN1Ym1lbnUtdG9nZ2xlJyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJy5zdWJtZW51LXRvZ2dsZScpLnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX25lc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiTmVzdFxcXCJdLkJ1cm4odGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQWNjb3JkaW9uTWVudTtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5BY2NvcmRpb25NZW51LmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBBZGRzIHRoZSBwYXJlbnQgbGluayB0byB0aGUgc3VibWVudS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgcGFyZW50TGluazogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDI1MFxcbiAgICovXFxuICBzbGlkZVNwZWVkOiAyNTAsXFxuXFxuICAvKipcXG4gICAqIEFkZHMgYSBzZXBhcmF0ZSBzdWJtZW51IHRvZ2dsZSBidXR0b24uIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgaXRlbSB0byBoYXZlIGEgbGluay5cXG4gICAqIEBvcHRpb25cXG4gICAqIEBleGFtcGxlIHRydWVcXG4gICAqL1xcbiAgc3VibWVudVRvZ2dsZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIFRoZSB0ZXh0IHVzZWQgZm9yIHRoZSBzdWJtZW51IHRvZ2dsZSBpZiBlbmFibGVkLiBUaGlzIGlzIHVzZWQgZm9yIHNjcmVlbiByZWFkZXJzIG9ubHkuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgKi9cXG4gIHN1Ym1lbnVUb2dnbGVUZXh0OiAnVG9nZ2xlIG1lbnUnLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgbWVudSB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgbXVsdGlPcGVuOiB0cnVlXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24uY29yZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBGb3VuZGF0aW9uICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJGb3VuZGF0aW9uXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBGb3VuZGF0aW9uOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5cXG5cXG5cXG52YXIgRk9VTkRBVElPTl9WRVJTSU9OID0gJzYuNi4zJzsgLy8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XFxuLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxcblxcbnZhciBGb3VuZGF0aW9uID0ge1xcbiAgdmVyc2lvbjogRk9VTkRBVElPTl9WRVJTSU9OLFxcblxcbiAgLyoqXFxuICAgKiBTdG9yZXMgaW5pdGlhbGl6ZWQgcGx1Z2lucy5cXG4gICAqL1xcbiAgX3BsdWdpbnM6IHt9LFxcblxcbiAgLyoqXFxuICAgKiBTdG9yZXMgZ2VuZXJhdGVkIHVuaXF1ZSBpZHMgZm9yIHBsdWdpbiBpbnN0YW5jZXNcXG4gICAqL1xcbiAgX3V1aWRzOiBbXSxcXG5cXG4gIC8qKlxcbiAgICogRGVmaW5lcyBhIEZvdW5kYXRpb24gcGx1Z2luLCBhZGRpbmcgaXQgdG8gdGhlIGBGb3VuZGF0aW9uYCBuYW1lc3BhY2UgYW5kIHRoZSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB3aGVuIHJlZmxvd2luZy5cXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cXG4gICAqL1xcbiAgcGx1Z2luOiBmdW5jdGlvbiBwbHVnaW4oX3BsdWdpbiwgbmFtZSkge1xcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIGFkZGluZyB0byBnbG9iYWwgRm91bmRhdGlvbiBvYmplY3RcXG4gICAgLy8gRXhhbXBsZXM6IEZvdW5kYXRpb24uUmV2ZWFsLCBGb3VuZGF0aW9uLk9mZkNhbnZhc1xcbiAgICB2YXIgY2xhc3NOYW1lID0gbmFtZSB8fCBmdW5jdGlvbk5hbWUoX3BsdWdpbik7IC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gc3RvcmluZyB0aGUgcGx1Z2luLCBhbHNvIHVzZWQgdG8gY3JlYXRlIHRoZSBpZGVudGlmeWluZyBkYXRhIGF0dHJpYnV0ZSBmb3IgdGhlIHBsdWdpblxcbiAgICAvLyBFeGFtcGxlczogZGF0YS1yZXZlYWwsIGRhdGEtb2ZmLWNhbnZhc1xcblxcbiAgICB2YXIgYXR0ck5hbWUgPSBoeXBoZW5hdGUoY2xhc3NOYW1lKTsgLy8gQWRkIHRvIHRoZSBGb3VuZGF0aW9uIG9iamVjdCBhbmQgdGhlIHBsdWdpbnMgbGlzdCAoZm9yIHJlZmxvd2luZylcXG5cXG4gICAgdGhpcy5fcGx1Z2luc1thdHRyTmFtZV0gPSB0aGlzW2NsYXNzTmFtZV0gPSBfcGx1Z2luO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBQb3B1bGF0ZXMgdGhlIF91dWlkcyBhcnJheSB3aXRoIHBvaW50ZXJzIHRvIGVhY2ggaW5kaXZpZHVhbCBwbHVnaW4gaW5zdGFuY2UuXFxuICAgKiBBZGRzIHRoZSBgemZQbHVnaW5gIGRhdGEtYXR0cmlidXRlIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZCBwbHVnaW5zIHRvIGFsbG93IHVzZSBvZiAkKHNlbGVjdG9yKS5mb3VuZGF0aW9uKG1ldGhvZCkgY2FsbHMuXFxuICAgKiBBbHNvIGZpcmVzIHRoZSBpbml0aWFsaXphdGlvbiBldmVudCBmb3IgZWFjaCBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLCBwYXNzZWQgYXMgYSBjYW1lbENhc2VkIHN0cmluZy5cXG4gICAqIEBmaXJlcyBQbHVnaW4jaW5pdFxcbiAgICovXFxuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4ocGx1Z2luLCBuYW1lKSB7XFxuICAgIHZhciBwbHVnaW5OYW1lID0gbmFtZSA/IGh5cGhlbmF0ZShuYW1lKSA6IGZ1bmN0aW9uTmFtZShwbHVnaW4uY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7XFxuICAgIHBsdWdpbi51dWlkID0gT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgcGx1Z2luTmFtZSk7XFxuXFxuICAgIGlmICghcGx1Z2luLiRlbGVtZW50LmF0dHIoXFxcImRhdGEtXFxcIi5jb25jYXQocGx1Z2luTmFtZSkpKSB7XFxuICAgICAgcGx1Z2luLiRlbGVtZW50LmF0dHIoXFxcImRhdGEtXFxcIi5jb25jYXQocGx1Z2luTmFtZSksIHBsdWdpbi51dWlkKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKSB7XFxuICAgICAgcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgcGx1Z2luKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cXG4gICAgICogQGV2ZW50IFBsdWdpbiNpbml0XFxuICAgICAqL1xcblxcblxcbiAgICBwbHVnaW4uJGVsZW1lbnQudHJpZ2dlcihcXFwiaW5pdC56Zi5cXFwiLmNvbmNhdChwbHVnaW5OYW1lKSk7XFxuXFxuICAgIHRoaXMuX3V1aWRzLnB1c2gocGx1Z2luLnV1aWQpO1xcblxcbiAgICByZXR1cm47XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIFJlbW92ZXMgdGhlIHBsdWdpbnMgdXVpZCBmcm9tIHRoZSBfdXVpZHMgYXJyYXkuXFxuICAgKiBSZW1vdmVzIHRoZSB6ZlBsdWdpbiBkYXRhIGF0dHJpYnV0ZSwgYXMgd2VsbCBhcyB0aGUgZGF0YS1wbHVnaW4tbmFtZSBhdHRyaWJ1dGUuXFxuICAgKiBBbHNvIGZpcmVzIHRoZSBkZXN0cm95ZWQgZXZlbnQgZm9yIHRoZSBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxcbiAgICogQGZpcmVzIFBsdWdpbiNkZXN0cm95ZWRcXG4gICAqL1xcbiAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gdW5yZWdpc3RlclBsdWdpbihwbHVnaW4pIHtcXG4gICAgdmFyIHBsdWdpbk5hbWUgPSBoeXBoZW5hdGUoZnVuY3Rpb25OYW1lKHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpLmNvbnN0cnVjdG9yKSk7XFxuXFxuICAgIHRoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHBsdWdpbi51dWlkKSwgMSk7XFxuXFxuICAgIHBsdWdpbi4kZWxlbWVudC5yZW1vdmVBdHRyKFxcXCJkYXRhLVxcXCIuY29uY2F0KHBsdWdpbk5hbWUpKS5yZW1vdmVEYXRhKCd6ZlBsdWdpbicpXFxuICAgIC8qKlxcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxcbiAgICAgKiBAZXZlbnQgUGx1Z2luI2Rlc3Ryb3llZFxcbiAgICAgKi9cXG4gICAgLnRyaWdnZXIoXFxcImRlc3Ryb3llZC56Zi5cXFwiLmNvbmNhdChwbHVnaW5OYW1lKSk7XFxuXFxuICAgIGZvciAodmFyIHByb3AgaW4gcGx1Z2luKSB7XFxuICAgICAgcGx1Z2luW3Byb3BdID0gbnVsbDsgLy9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxcbiAgICB9XFxuXFxuICAgIHJldHVybjtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEBmdW5jdGlvblxcbiAgICogQ2F1c2VzIG9uZSBvciBtb3JlIGFjdGl2ZSBwbHVnaW5zIHRvIHJlLWluaXRpYWxpemUsIHJlc2V0dGluZyBldmVudCBsaXN0ZW5lcnMsIHJlY2FsY3VsYXRpbmcgcG9zaXRpb25zLCBldGMuXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2lucyAtIG9wdGlvbmFsIHN0cmluZyBvZiBhbiBpbmRpdmlkdWFsIHBsdWdpbiBrZXksIGF0dGFpbmVkIGJ5IGNhbGxpbmcgYCQoZWxlbWVudCkuZGF0YSgncGx1Z2luTmFtZScpYCwgb3Igc3RyaW5nIG9mIGEgcGx1Z2luIGNsYXNzIGkuZS4gYCdkcm9wZG93bidgXFxuICAgKiBAZGVmYXVsdCBJZiBubyBhcmd1bWVudCBpcyBwYXNzZWQsIHJlZmxvdyBhbGwgY3VycmVudGx5IGFjdGl2ZSBwbHVnaW5zLlxcbiAgICovXFxuICByZUluaXQ6IGZ1bmN0aW9uIHJlSW5pdChwbHVnaW5zKSB7XFxuICAgIHZhciBpc0pRID0gcGx1Z2lucyBpbnN0YW5jZW9mIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYTtcXG5cXG4gICAgdHJ5IHtcXG4gICAgICBpZiAoaXNKUSkge1xcbiAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ3pmUGx1Z2luJykuX2luaXQoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgdHlwZSA9IF90eXBlb2YocGx1Z2lucyksXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgIGZucyA9IHtcXG4gICAgICAgICAgJ29iamVjdCc6IGZ1bmN0aW9uIG9iamVjdChwbGdzKSB7XFxuICAgICAgICAgICAgcGxncy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XFxuICAgICAgICAgICAgICBwID0gaHlwaGVuYXRlKHApO1xcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS0nICsgcCArICddJykuZm91bmRhdGlvbignX2luaXQnKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uIHN0cmluZygpIHtcXG4gICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xcbiAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEtJyArIHBsdWdpbnMgKyAnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICd1bmRlZmluZWQnOiBmdW5jdGlvbiB1bmRlZmluZWQoKSB7XFxuICAgICAgICAgICAgdGhpc1snb2JqZWN0J10oT2JqZWN0LmtleXMoX3RoaXMuX3BsdWdpbnMpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGZuc1t0eXBlXShwbHVnaW5zKTtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICByZXR1cm4gcGx1Z2lucztcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIC0galF1ZXJ5IG9iamVjdCBjb250YWluaW5nIHRoZSBlbGVtZW50IHRvIGNoZWNrIGluc2lkZS4gQWxzbyBjaGVja3MgdGhlIGVsZW1lbnQgaXRzZWxmLCB1bmxlc3MgaXQncyB0aGUgYGRvY3VtZW50YCBvYmplY3QuXFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGx1Z2lucyAtIEEgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUuIExlYXZlIHRoaXMgb3V0IHRvIGluaXRpYWxpemUgZXZlcnl0aGluZy5cXG4gICAqL1xcbiAgcmVmbG93OiBmdW5jdGlvbiByZWZsb3coZWxlbSwgcGx1Z2lucykge1xcbiAgICAvLyBJZiBwbHVnaW5zIGlzIHVuZGVmaW5lZCwganVzdCBncmFiIGV2ZXJ5dGhpbmdcXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIHBsdWdpbnMgPSBPYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTtcXG4gICAgfSAvLyBJZiBwbHVnaW5zIGlzIGEgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggb25lIGl0ZW1cXG4gICAgZWxzZSBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBwbHVnaW5zID0gW3BsdWdpbnNdO1xcbiAgICAgIH1cXG5cXG4gICAgdmFyIF90aGlzID0gdGhpczsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcGx1Z2luXFxuXFxuXFxuICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHBsdWdpblxcbiAgICAgIHZhciBwbHVnaW4gPSBfdGhpcy5fcGx1Z2luc1tuYW1lXTsgLy8gTG9jYWxpemUgdGhlIHNlYXJjaCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIGVsZW0sIGFzIHdlbGwgYXMgZWxlbSBpdHNlbGYsIHVubGVzcyBlbGVtID09PSBkb2N1bWVudFxcblxcbiAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbGVtKS5maW5kKCdbZGF0YS0nICsgbmFtZSArICddJykuYWRkQmFjaygnW2RhdGEtJyArIG5hbWUgKyAnXScpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdHlwZW9mIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpID09PSAndW5kZWZpbmVkJztcXG4gICAgICB9KTsgLy8gRm9yIGVhY2ggcGx1Z2luIGZvdW5kLCBpbml0aWFsaXplIGl0XFxuXFxuICAgICAgJGVsZW0uZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGVsID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIG9wdHMgPSB7XFxuICAgICAgICAgIHJlZmxvdzogdHJ1ZVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmICgkZWwuYXR0cignZGF0YS1vcHRpb25zJykpIHtcXG4gICAgICAgICAgJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uLCBfaW5kZXgpIHtcXG4gICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9uLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGVsLnRyaW0oKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAob3B0WzBdKSBvcHRzW29wdFswXV0gPSBwYXJzZVZhbHVlKG9wdFsxXSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgJGVsLmRhdGEoJ3pmUGx1Z2luJywgbmV3IHBsdWdpbihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksIG9wdHMpKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH0sXFxuICBnZXRGbk5hbWU6IGZ1bmN0aW9uTmFtZSxcXG4gIGFkZFRvSnF1ZXJ5OiBmdW5jdGlvbiBhZGRUb0pxdWVyeSgkKSB7XFxuICAgIC8vIFRPRE86IGNvbnNpZGVyIG5vdCBtYWtpbmcgdGhpcyBhIGpRdWVyeSBmdW5jdGlvblxcbiAgICAvLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxcbiAgICAgKi9cXG4gICAgdmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbiBmb3VuZGF0aW9uKG1ldGhvZCkge1xcbiAgICAgIHZhciB0eXBlID0gX3R5cGVvZihtZXRob2QpLFxcbiAgICAgICAgICAkbm9KUyA9ICQoJy5uby1qcycpO1xcblxcbiAgICAgIGlmICgkbm9KUy5sZW5ndGgpIHtcXG4gICAgICAgICRub0pTLnJlbW92ZUNsYXNzKCduby1qcycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vbmVlZHMgdG8gaW5pdGlhbGl6ZSB0aGUgRm91bmRhdGlvbiBvYmplY3QsIG9yIGFuIGluZGl2aWR1YWwgcGx1Z2luLlxcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgLy9hbiBpbmRpdmlkdWFsIG1ldGhvZCB0byBpbnZva2Ugb24gYSBwbHVnaW4gb3IgZ3JvdXAgb2YgcGx1Z2luc1xcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxcblxcbiAgICAgICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsgLy9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBwbHVnQ2xhc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwbHVnQ2xhc3NbbWV0aG9kXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgLy9tYWtlIHN1cmUgYm90aCB0aGUgY2xhc3MgYW5kIG1ldGhvZCBleGlzdFxcbiAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXFxuICAgICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkocGx1Z0NsYXNzLCBhcmdzKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgICAgICAgICAvL290aGVyd2lzZSBsb29wIHRocm91Z2ggdGhlIGpRdWVyeSBjb2xsZWN0aW9uIGFuZCBpbnZva2UgdGhlIG1ldGhvZCBvbiBlYWNoXFxuICAgICAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXFxuICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwiV2UncmUgc29ycnksICdcXFwiICsgbWV0aG9kICsgXFxcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFxcXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCBcXFwiLmNvbmNhdCh0eXBlLCBcXFwiIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS5cXFwiKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbiAgICAkLmZuLmZvdW5kYXRpb24gPSBmb3VuZGF0aW9uO1xcbiAgICByZXR1cm4gJDtcXG4gIH1cXG59O1xcbkZvdW5kYXRpb24udXRpbCA9IHtcXG4gIC8qKlxcbiAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxcbiAgICogQHJldHVybnMgZnVuY3Rpb25cXG4gICAqL1xcbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGRlbGF5KSB7XFxuICAgIHZhciB0aW1lciA9IG51bGw7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxcbiAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xcblxcbiAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXG4gICAgICAgICAgdGltZXIgPSBudWxsO1xcbiAgICAgICAgfSwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG59O1xcbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjsgLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxcblxcbihmdW5jdGlvbiAoKSB7XFxuICBpZiAoIURhdGUubm93IHx8ICF3aW5kb3cuRGF0ZS5ub3cpIHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICB9O1xcbiAgdmFyIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xcbiAgICB2YXIgdnAgPSB2ZW5kb3JzW2ldO1xcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnAgKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdnAgKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XFxuICB9XFxuXFxuICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XFxuICAgIHZhciBsYXN0VGltZSA9IDA7XFxuXFxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcXG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcXG4gICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpO1xcbiAgICAgIH0sIG5leHRUaW1lIC0gbm93KTtcXG4gICAgfTtcXG5cXG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xcbiAgfVxcbiAgLyoqXFxuICAgKiBQb2x5ZmlsbCBmb3IgcGVyZm9ybWFuY2Uubm93LCByZXF1aXJlZCBieSByQUZcXG4gICAqL1xcblxcblxcbiAgaWYgKCF3aW5kb3cucGVyZm9ybWFuY2UgfHwgIXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpIHtcXG4gICAgd2luZG93LnBlcmZvcm1hbmNlID0ge1xcbiAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxcbiAgICAgIG5vdzogZnVuY3Rpb24gbm93KCkge1xcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG59KSgpO1xcblxcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcXG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XFxuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxcbiAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xcbiAgICB9XFxuXFxuICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcXG4gICAgICAgIGZOT1AgPSBmdW5jdGlvbiBmTk9QKCkge30sXFxuICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiBmQm91bmQoKSB7XFxuICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XFxuICAgIH07XFxuXFxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xcbiAgICAgIC8vIG5hdGl2ZSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZVxcbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XFxuICAgIH1cXG5cXG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XFxuICAgIHJldHVybiBmQm91bmQ7XFxuICB9O1xcbn0gLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XFxuXFxuXFxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKSB7XFxuICBpZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xcbiAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxcXFxzKFteKF17MSx9KVxcXFwoLztcXG4gICAgdmFyIHJlc3VsdHMgPSBmdW5jTmFtZVJlZ2V4LmV4ZWMoZm4udG9TdHJpbmcoKSk7XFxuICAgIHJldHVybiByZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSA/IHJlc3VsdHNbMV0udHJpbSgpIDogXFxcIlxcXCI7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5wcm90b3R5cGUgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiBmbi5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZVZhbHVlKHN0cikge1xcbiAgaWYgKCd0cnVlJyA9PT0gc3RyKSByZXR1cm4gdHJ1ZTtlbHNlIGlmICgnZmFsc2UnID09PSBzdHIpIHJldHVybiBmYWxzZTtlbHNlIGlmICghaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XFxuICByZXR1cm4gc3RyO1xcbn0gLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2VcXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcXG5cXG5cXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uY29yZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBQbHVnaW4gKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlBsdWdpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGx1Z2luOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5cXG4gLy8gQWJzdHJhY3QgY2xhc3MgZm9yIHByb3ZpZGluZyBsaWZlY3ljbGUgaG9va3MuIEV4cGVjdCBwbHVnaW5zIHRvIGRlZmluZSBBVCBMRUFTVFxcbi8vIHtmdW5jdGlvbn0gX3NldHVwIChyZXBsYWNlcyBwcmV2aW91cyBjb25zdHJ1Y3RvciksXFxuLy8ge2Z1bmN0aW9ufSBfZGVzdHJveSAocmVwbGFjZXMgcHJldmlvdXMgZGVzdHJveSlcXG5cXG52YXIgUGx1Z2luID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gUGx1Z2luKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsdWdpbik7XFxuXFxuICAgIHRoaXMuX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpO1xcblxcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGdldFBsdWdpbk5hbWUodGhpcyk7XFxuICAgIHRoaXMudXVpZCA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsIHBsdWdpbk5hbWUpO1xcblxcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiLmNvbmNhdChwbHVnaW5OYW1lKSkpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoXFxcImRhdGEtXFxcIi5jb25jYXQocGx1Z2luTmFtZSksIHRoaXMudXVpZCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgdGhpcyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQuXFxuICAgICAqIEBldmVudCBQbHVnaW4jaW5pdFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJpbml0LnpmLlxcXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhQbHVnaW4sIFt7XFxuICAgIGtleTogXFxcImRlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLl9kZXN0cm95KCk7XFxuXFxuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBnZXRQbHVnaW5OYW1lKHRoaXMpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cihcXFwiZGF0YS1cXFwiLmNvbmNhdChwbHVnaW5OYW1lKSkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXFxuICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcXG4gICAgICAgKi9cXG4gICAgICAudHJpZ2dlcihcXFwiZGVzdHJveWVkLnpmLlxcXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcXG5cXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMpIHtcXG4gICAgICAgIHRoaXNbcHJvcF0gPSBudWxsOyAvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUGx1Z2luO1xcbn0oKTsgLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2VcXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcXG5cXG5cXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFBsdWdpbk5hbWUob2JqKSB7XFxuICByZXR1cm4gaHlwaGVuYXRlKG9iai5jbGFzc05hbWUpO1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcnRsLCBHZXRZb0RpZ2l0cywgUmVnRXhwRXNjYXBlLCB0cmFuc2l0aW9uZW5kLCBvbkxvYWQsIGlnbm9yZU1vdXNlZGlzYXBwZWFyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJydGxcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJ0bDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiR2V0WW9EaWdpdHNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEdldFlvRGlnaXRzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJSZWdFeHBFc2NhcGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJlZ0V4cEVzY2FwZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidHJhbnNpdGlvbmVuZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJhbnNpdGlvbmVuZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib25Mb2FkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvbkxvYWQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImlnbm9yZU1vdXNlZGlzYXBwZWFyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpZ25vcmVNb3VzZWRpc2FwcGVhcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcblxcbiAvLyBDb3JlIEZvdW5kYXRpb24gVXRpbGl0aWVzLCB1dGlsaXplZCBpbiBhIG51bWJlciBvZiBwbGFjZXMuXFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGJvb2xlYW4gZm9yIFJUTCBzdXBwb3J0XFxuICovXFxuXFxuZnVuY3Rpb24gcnRsKCkge1xcbiAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCcpLmF0dHIoJ2RpcicpID09PSAncnRsJztcXG59XFxuLyoqXFxuICogcmV0dXJucyBhIHJhbmRvbSBiYXNlLTM2IHVpZCB3aXRoIG5hbWVzcGFjaW5nXFxuICogQGZ1bmN0aW9uXFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIG51bWJlciBvZiByYW5kb20gYmFzZS0zNiBkaWdpdHMgZGVzaXJlZC4gSW5jcmVhc2UgZm9yIG1vcmUgcmFuZG9tIHN0cmluZ3MuXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIG5hbWUgb2YgcGx1Z2luIHRvIGJlIGluY29ycG9yYXRlZCBpbiB1aWQsIG9wdGlvbmFsLlxcbiAqIEBkZWZhdWx0IHtTdHJpbmd9ICcnIC0gaWYgbm8gcGx1Z2luIG5hbWUgaXMgcHJvdmlkZWQsIG5vdGhpbmcgaXMgYXBwZW5kZWQgdG8gdGhlIHVpZC5cXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIHVuaXF1ZSBpZFxcbiAqL1xcblxcblxcbmZ1bmN0aW9uIEdldFlvRGlnaXRzKCkge1xcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogNjtcXG4gIHZhciBuYW1lc3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcXG4gIHZhciBzdHIgPSAnJztcXG4gIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xcbiAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICBzdHIgKz0gY2hhcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnNMZW5ndGgpXTtcXG4gIH1cXG5cXG4gIHJldHVybiBuYW1lc3BhY2UgPyBcXFwiXFxcIi5jb25jYXQoc3RyLCBcXFwiLVxcXCIpLmNvbmNhdChuYW1lc3BhY2UpIDogc3RyO1xcbn1cXG4vKipcXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgYXMgYSByZWdleHAgcGF0dGVyblxcbiAqIEBmdW5jdGlvblxcbiAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzkzMTA3NTIvNDMxNzM4NFxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBlc2NhcGUuXFxuICogQHJldHVybnMge1N0cmluZ30gLSBlc2NhcGVkIHN0cmluZ1xcbiAqL1xcblxcblxcbmZ1bmN0aW9uIFJlZ0V4cEVzY2FwZShzdHIpIHtcXG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxcXF17fSgpKis/LixcXFxcXFxcXF4kfCNcXFxcc10vZywgJ1xcXFxcXFxcJCYnKTtcXG59XFxuXFxuZnVuY3Rpb24gdHJhbnNpdGlvbmVuZCgkZWxlbSkge1xcbiAgdmFyIHRyYW5zaXRpb25zID0ge1xcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXFxuICAgICdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxcbiAgICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnXFxuICB9O1xcbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXG4gICAgICBlbmQ7XFxuXFxuICBmb3IgKHZhciB0cmFuc2l0aW9uIGluIHRyYW5zaXRpb25zKSB7XFxuICAgIGlmICh0eXBlb2YgZWxlbS5zdHlsZVt0cmFuc2l0aW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBlbmQgPSB0cmFuc2l0aW9uc1t0cmFuc2l0aW9uXTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGVuZCkge1xcbiAgICByZXR1cm4gZW5kO1xcbiAgfSBlbHNlIHtcXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgJGVsZW0udHJpZ2dlckhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCBbJGVsZW1dKTtcXG4gICAgfSwgMSk7XFxuICAgIHJldHVybiAndHJhbnNpdGlvbmVuZCc7XFxuICB9XFxufVxcbi8qKlxcbiAqIFJldHVybiBhbiBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3Igd2luZG93IGxvYWQuXFxuICpcXG4gKiBJZiBgJGVsZW1gIGlzIHBhc3NlZCwgYW4gZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgb24gYCRlbGVtYC4gSWYgd2luZG93IGlzIGFscmVhZHkgbG9hZGVkLCB0aGUgZXZlbnQgd2lsbCBzdGlsbCBiZSB0cmlnZ2VyZWQuXFxuICogSWYgYGhhbmRsZXJgIGlzIHBhc3NlZCwgYXR0YWNoIGl0IHRvIHRoZSBldmVudCBvbiBgJGVsZW1gLlxcbiAqIENhbGxpbmcgYG9uTG9hZGAgd2l0aG91dCBoYW5kbGVyIGFsbG93cyB5b3UgdG8gZ2V0IHRoZSBldmVudCB0eXBlIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYmVmb3JlIGF0dGFjaGluZyB0aGUgaGFuZGxlciBieSB5b3Vyc2VsZi5cXG4gKiBAZnVuY3Rpb25cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbXSAkZWxlbSAtIGpRdWVyeSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBpZiBwYXNzZWQuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW10gaGFuZGxlciAtIGZ1bmN0aW9uIHRvIGF0dGFjaCB0byB0aGUgZXZlbnQuXFxuICogQHJldHVybnMge1N0cmluZ30gLSBldmVudCB0eXBlIHRoYXQgc2hvdWxkIG9yIHdpbGwgYmUgdHJpZ2dlcmVkLlxcbiAqL1xcblxcblxcbmZ1bmN0aW9uIG9uTG9hZCgkZWxlbSwgaGFuZGxlcikge1xcbiAgdmFyIGRpZExvYWQgPSBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnO1xcbiAgdmFyIGV2ZW50VHlwZSA9IChkaWRMb2FkID8gJ19kaWRMb2FkJyA6ICdsb2FkJykgKyAnLnpmLnV0aWwub25Mb2FkJztcXG5cXG4gIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xcbiAgICByZXR1cm4gJGVsZW0udHJpZ2dlckhhbmRsZXIoZXZlbnRUeXBlKTtcXG4gIH07XFxuXFxuICBpZiAoJGVsZW0pIHtcXG4gICAgaWYgKGhhbmRsZXIpICRlbGVtLm9uZShldmVudFR5cGUsIGhhbmRsZXIpO1xcbiAgICBpZiAoZGlkTG9hZCkgc2V0VGltZW91dChjYik7ZWxzZSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbmUoJ2xvYWQnLCBjYik7XFxuICB9XFxuXFxuICByZXR1cm4gZXZlbnRUeXBlO1xcbn1cXG4vKipcXG4gKiBSZXR1bnMgYW4gaGFuZGxlciBmb3IgdGhlIGBtb3VzZWxlYXZlYCB0aGF0IGlnbm9yZSBkaXNhcHBlYXJlZCBtb3VzZXMuXFxuICpcXG4gKiBJZiB0aGUgbW91c2UgXFxcImRpc2FwcGVhcmVkXFxcIiBmcm9tIHRoZSBkb2N1bWVudCAobGlrZSB3aGVuIGdvaW5nIG9uIGEgYnJvd3NlciBVSSBlbGVtZW50LCBTZWUgaHR0cHM6Ly9naXQuaW8vemYtMTE0MTApLFxcbiAqIHRoZSBldmVudCBpcyBpZ25vcmVkLlxcbiAqIC0gSWYgdGhlIGBpZ25vcmVMZWF2ZVdpbmRvd2AgaXMgYHRydWVgLCB0aGUgZXZlbnQgaXMgaWdub3JlZCB3aGVuIHRoZSB1c2VyIGFjdHVhbGx5IGxlZnQgdGhlIHdpbmRvd1xcbiAqICAgKGxpa2UgYnkgc3dpdGNoaW5nIHRvIGFuIG90aGVyIHdpbmRvdyB3aXRoIFtBbHRdK1tUYWJdKS5cXG4gKiAtIElmIHRoZSBgaWdub3JlUmVhcHBlYXJgIGlzIGB0cnVlYCwgdGhlIGV2ZW50IHdpbGwgYmUgaWdub3JlZCB3aGVuIHRoZSBtb3VzZSB3aWxsIHJlYXBwZWFyIGxhdGVyIG9uIHRoZSBkb2N1bWVudFxcbiAqICAgb3V0c2lkZSBvZiB0aGUgZWxlbWVudCBpdCBsZWZ0LlxcbiAqXFxuICogQGZ1bmN0aW9uXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbXSBoYW5kbGVyIC0gaGFuZGxlciBmb3IgdGhlIGZpbHRlcmVkIGBtb3VzZWxlYXZlYCBldmVudCB0byB3YXRjaC5cXG4gKiBAcGFyYW0ge09iamVjdH0gW10gb3B0aW9ucyAtIG9iamVjdCBvZiBvcHRpb25zOlxcbiAqIC0ge0Jvb2xlYW59IFtmYWxzZV0gaWdub3JlTGVhdmVXaW5kb3cgLSBhbHNvIGlnbm9yZSB3aGVuIHRoZSB1c2VyIHN3aXRjaGVkIHdpbmRvd3MuXFxuICogLSB7Qm9vbGVhbn0gW2ZhbHNlXSBpZ25vcmVSZWFwcGVhciAtIGFsc28gaWdub3JlIHdoZW4gdGhlIG1vdXNlIHJlYXBwZWFyZWQgb3V0c2lkZSBvZiB0aGUgZWxlbWVudCBpdCBsZWZ0LlxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBmaWx0ZXJlZCBoYW5kbGVyIHRvIHVzZSB0byBsaXN0ZW4gb24gdGhlIGBtb3VzZWxlYXZlYCBldmVudC5cXG4gKi9cXG5cXG5cXG5mdW5jdGlvbiBpZ25vcmVNb3VzZWRpc2FwcGVhcihoYW5kbGVyKSB7XFxuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXFxuICAgICAgX3JlZiRpZ25vcmVMZWF2ZVdpbmRvID0gX3JlZi5pZ25vcmVMZWF2ZVdpbmRvdyxcXG4gICAgICBpZ25vcmVMZWF2ZVdpbmRvdyA9IF9yZWYkaWdub3JlTGVhdmVXaW5kbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZUxlYXZlV2luZG8sXFxuICAgICAgX3JlZiRpZ25vcmVSZWFwcGVhciA9IF9yZWYuaWdub3JlUmVhcHBlYXIsXFxuICAgICAgaWdub3JlUmVhcHBlYXIgPSBfcmVmJGlnbm9yZVJlYXBwZWFyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlUmVhcHBlYXI7XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gbGVhdmVFdmVudEhhbmRsZXIoZUxlYXZlKSB7XFxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcXG4gICAgICByZXN0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgfVxcblxcbiAgICB2YXIgY2FsbGJhY2sgPSBoYW5kbGVyLmJpbmQuYXBwbHkoaGFuZGxlciwgW3RoaXMsIGVMZWF2ZV0uY29uY2F0KHJlc3QpKTsgLy8gVGhlIG1vdXNlIGxlZnQ6IGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGlmIHRoZSBtb3VzZSBlbnRlcmVkIGVsc2V3aGVyZVxcblxcbiAgICBpZiAoZUxlYXZlLnJlbGF0ZWRUYXJnZXQgIT09IG51bGwpIHtcXG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcXG4gICAgfSAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIHRoZSBtb3VzZSBhY3R1YWxseSBsZWZ0IHRoZSB3aW5kb3cuXFxuICAgIC8vIEluIGZpcmVmb3ggaWYgdGhlIHVzZXIgc3dpdGNoZWQgYmV0d2VlbiB3aW5kb3dzLCB0aGUgd2luZG93IHNpbGwgaGF2ZSB0aGUgZm9jdXMgYnkgdGhlIHRpbWVcXG4gICAgLy8gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC4gV2UgaGF2ZSB0byBkZWJvdW5jZSB0aGUgZXZlbnQgdG8gdGVzdCB0aGlzIGNhc2UuXFxuXFxuXFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gbGVhdmVFdmVudERlYm91bmNlcigpIHtcXG4gICAgICBpZiAoIWlnbm9yZUxlYXZlV2luZG93ICYmIGRvY3VtZW50Lmhhc0ZvY3VzICYmICFkb2N1bWVudC5oYXNGb2N1cygpKSB7XFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcXG4gICAgICB9IC8vIE90aGVyd2lzZSwgd2FpdCBmb3IgdGhlIG1vdXNlIHRvIHJlZWFwZWFyIG91dHNpZGUgb2YgdGhlIGVsZW1lbnQsXFxuXFxuXFxuICAgICAgaWYgKCFpZ25vcmVSZWFwcGVhcikge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KS5vbmUoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiByZWVudGVyRXZlbnRIYW5kbGVyKGVSZWVudGVyKSB7XFxuICAgICAgICAgIGlmICghanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVMZWF2ZS5jdXJyZW50VGFyZ2V0KS5oYXMoZVJlZW50ZXIudGFyZ2V0KS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAvLyBGaWxsIHdoZXJlIHRoZSBtb3VzZSBmaW5hbGx5IGVudGVyZWQuXFxuICAgICAgICAgICAgZUxlYXZlLnJlbGF0ZWRUYXJnZXQgPSBlUmVlbnRlci50YXJnZXQ7XFxuICAgICAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LCAwKTtcXG4gIH07XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi5kcmlsbGRvd24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24uZHJpbGxkb3duLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRHJpbGxkb3duICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJEcmlsbGRvd25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERyaWxsZG93bjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5uZXN0ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuYm94ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5ib3guanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRHJpbGxkb3duIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICovXFxuXFxudmFyIERyaWxsZG93biA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoRHJpbGxkb3duLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIERyaWxsZG93bigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyaWxsZG93bik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHJpbGxkb3duKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhEcmlsbGRvd24sIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJpbGxkb3duIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBEcmlsbGRvd25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgRHJpbGxkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnRHJpbGxkb3duJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignRHJpbGxkb3duJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXFxuICAgICAgICAnVEFCJzogJ2Rvd24nLFxcbiAgICAgICAgJ1NISUZUX1RBQic6ICd1cCdcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJOZXN0XFxcIl0uRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQXBwbHlDbGFzcykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZHJpbGxkb3duJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAncm9sZSc6ICd0cmVlJyxcXG4gICAgICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IGZhbHNlXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCdhJyk7XFxuICAgICAgdGhpcy4kc3VibWVudXMgPSB0aGlzLiRzdWJtZW51QW5jaG9ycy5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYXR0cigncm9sZScsICdncm91cCcpO1xcbiAgICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5ub3QoJy5qcy1kcmlsbGRvd24tYmFjaycpLmF0dHIoJ3JvbGUnLCAndHJlZWl0ZW0nKS5maW5kKCdhJyk7IC8vIFNldCB0aGUgbWFpbiBtZW51IGFzIGN1cnJlbnQgYnkgZGVmYXVsdCAodW5sZXNzIGEgc3VibWVudSBpcyBzZWxlY3RlZClcXG4gICAgICAvLyBVc2VkIHRvIHNldCB0aGUgd3JhcHBlciBoZWlnaHQgd2hlbiB0aGUgZHJpbGxkb3duIGlzIGNsb3NlZC9yZW9wZW5lZCBmcm9tIGFueSAoc3ViKW1lbnVcXG5cXG4gICAgICB0aGlzLiRjdXJyZW50TWVudSA9IHRoaXMuJGVsZW1lbnQ7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1kcmlsbGRvd24nKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnZHJpbGxkb3duJykpO1xcblxcbiAgICAgIHRoaXMuX3ByZXBhcmVNZW51KCk7XFxuXFxuICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcXG5cXG4gICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBwcmVwYXJlcyBkcmlsbGRvd24gbWVudSBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgdG8gbGlua3MgYW5kIGVsZW1lbnRzXFxuICAgICAqIHNldHMgYSBtaW4gaGVpZ2h0IHRvIHByZXZlbnQgY29udGVudCBqdW1waW5nXFxuICAgICAqIHdyYXBzIHRoZSBlbGVtZW50IGlmIG5vdCBhbHJlYWR5IHdyYXBwZWRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcHJlcGFyZU1lbnVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVNZW51KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIGlmKCF0aGlzLm9wdGlvbnMuaG9sZE9wZW4pe1xcbiAgICAgIC8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcXG4gICAgICAvLyB9XFxuXFxuXFxuICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGxpbmsgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyk7XFxuICAgICAgICB2YXIgJHN1YiA9ICRsaW5rLnBhcmVudCgpO1xcblxcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluaykge1xcbiAgICAgICAgICAkbGluay5jbG9uZSgpLnByZXBlbmRUbygkc3ViLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKS53cmFwKCc8bGkgZGF0YS1pcy1wYXJlbnQtbGluayBjbGFzcz1cXFwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtZHJpbGxkb3duLXN1Ym1lbnUtaXRlbVxcXCIgcm9sZT1cXFwibm9uZVxcXCI+PC9saT4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicsICRsaW5rLmF0dHIoJ2hyZWYnKSkucmVtb3ZlQXR0cignaHJlZicpLmF0dHIoJ3RhYmluZGV4JywgMCk7XFxuICAgICAgICAkbGluay5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICAgJ3RhYmluZGV4JzogMCxcXG4gICAgICAgICAgJ3JvbGUnOiAnZ3JvdXAnXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIF90aGlzLl9ldmVudHMoJGxpbmspO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRtZW51ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICRiYWNrID0gJG1lbnUuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrJyk7XFxuXFxuICAgICAgICBpZiAoISRiYWNrLmxlbmd0aCkge1xcbiAgICAgICAgICBzd2l0Y2ggKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvblBvc2l0aW9uKSB7XFxuICAgICAgICAgICAgY2FzZSBcXFwiYm90dG9tXFxcIjpcXG4gICAgICAgICAgICAgICRtZW51LmFwcGVuZChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b24pO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBcXFwidG9wXFxcIjpcXG4gICAgICAgICAgICAgICRtZW51LnByZXBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJVbnN1cHBvcnRlZCBiYWNrQnV0dG9uUG9zaXRpb24gdmFsdWUgJ1xcXCIgKyBfdGhpcy5vcHRpb25zLmJhY2tCdXR0b25Qb3NpdGlvbiArIFxcXCInXFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLl9iYWNrKCRtZW51KTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLiRzdWJtZW51cy5hZGRDbGFzcygnaW52aXNpYmxlJyk7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xcbiAgICAgICAgdGhpcy4kc3VibWVudXMuYWRkQ2xhc3MoJ2RyaWxsZG93bi1zdWJtZW51LWNvdmVyLXByZXZpb3VzJyk7XFxuICAgICAgfSAvLyBjcmVhdGUgYSB3cmFwcGVyIG9uIGVsZW1lbnQgaWYgaXQgZG9lc24ndCBleGlzdC5cXG5cXG5cXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWRyaWxsZG93bicpKSB7XFxuICAgICAgICB0aGlzLiR3cmFwcGVyID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMub3B0aW9ucy53cmFwcGVyKS5hZGRDbGFzcygnaXMtZHJpbGxkb3duJyk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVIZWlnaHQpIHRoaXMuJHdyYXBwZXIuYWRkQ2xhc3MoJ2FuaW1hdGUtaGVpZ2h0Jyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LndyYXAodGhpcy4kd3JhcHBlcik7XFxuICAgICAgfSAvLyBzZXQgd3JhcHBlclxcblxcblxcbiAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgpO1xcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3Jlc2l6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHtcXG4gICAgICAgICdtYXgtd2lkdGgnOiAnbm9uZScsXFxuICAgICAgICAnbWluLWhlaWdodCc6ICdub25lJ1xcbiAgICAgIH0pOyAvLyBfZ2V0TWF4RGltcyBoYXMgc2lkZSBlZmZlY3RzIChib28pIGJ1dCBjYWxsaW5nIGl0IHNob3VsZCB1cGRhdGUgYWxsIG90aGVyIG5lY2Vzc2FyeSBoZWlnaHRzICYgd2lkdGhzXFxuXFxuICAgICAgdGhpcy4kd3JhcHBlci5jc3ModGhpcy5fZ2V0TWF4RGltcygpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byBlbGVtZW50cyBpbiB0aGUgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IG1lbnUgaXRlbSB0byBhZGQgaGFuZGxlcnMgdG8uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoJGVsZW0pIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywgJ2xpJykuaGFzQ2xhc3MoJ2lzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpKSB7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0gLy8gaWYoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldC5maXJzdEVsZW1lbnRDaGlsZCl7XFxuICAgICAgICAvLyAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIC8vIH1cXG5cXG5cXG4gICAgICAgIF90aGlzLl9zaG93KCRlbGVtLnBhcmVudCgnbGknKSk7XFxuXFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgICAgdmFyICRib2R5ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdib2R5Jyk7XFxuICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XFxuXFxuICAgICAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBtZW51IGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlZ2lzdGVyRXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3RlckV2ZW50cygpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFRvcCkge1xcbiAgICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxUb3AuYmluZCh0aGlzKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ29wZW4uemYuZHJpbGxkb3duIGhpZGUuemYuZHJpbGxkb3duIGNsb3NlLnpmLmRyaWxsZG93biBjbG9zZWQuemYuZHJpbGxkb3duJywgdGhpcy5fYmluZEhhbmRsZXIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgdGhpcy5fcmVzaXplLmJpbmQodGhpcykpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTY3JvbGwgdG8gVG9wIG9mIEVsZW1lbnQgb3IgZGF0YS1zY3JvbGwtdG9wLWVsZW1lbnRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jc2Nyb2xsbWVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zY3JvbGxUb3BcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Njcm9sbFRvcCgpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHZhciAkc2Nyb2xsVG9wRWxlbWVudCA9IF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wRWxlbWVudCAhPSAnJyA/IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShfdGhpcy5vcHRpb25zLnNjcm9sbFRvcEVsZW1lbnQpIDogX3RoaXMuJGVsZW1lbnQsXFxuICAgICAgICAgIHNjcm9sbFBvcyA9IHBhcnNlSW50KCRzY3JvbGxUb3BFbGVtZW50Lm9mZnNldCgpLnRvcCArIF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wT2Zmc2V0LCAxMCk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHtcXG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsUG9zXFxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIGFmdGVyIHRoZSBtZW51IGhhcyBzY3JvbGxlZFxcbiAgICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jc2Nyb2xsbWVcXG4gICAgICAgICAgKi9cXG4gICAgICAgIGlmICh0aGlzID09PSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2h0bWwnKVswXSkgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignc2Nyb2xsbWUuemYuZHJpbGxkb3duJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMga2V5ZG93biBldmVudCBsaXN0ZW5lciB0byBgbGlgJ3MgaW4gdGhlIG1lbnUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfa2V5Ym9hcmRFdmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tleWJvYXJkRXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjayA+IGEsIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtID4gYScpKS5vbigna2V5ZG93bi56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKSxcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQsXFxuICAgICAgICAgICAgJG5leHRFbGVtZW50O1xcbiAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5pcygkZWxlbWVudCkpIHtcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ0RyaWxsZG93bicsIHtcXG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW1lbnQucGFyZW50KCdsaScpKTtcXG5cXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5ub3QoJy5qcy1kcmlsbGRvd24tYmFjayBhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcXG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcXG5cXG4gICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLm9uZShPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJ0cmFuc2l0aW9uZW5kXFxcIl0pKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmNoaWxkcmVuKCdhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSwgMSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHVwOiBmdW5jdGlvbiB1cCgpIHtcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTsgLy8gRG9uJ3QgdGFwIGZvY3VzIG9uIGZpcnN0IGVsZW1lbnQgaW4gcm9vdCB1bFxcblxcbiAgICAgICAgICAgIHJldHVybiAhJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaTpmaXJzdC1jaGlsZCA+IGEnKSk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRvd246IGZ1bmN0aW9uIGRvd24oKSB7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7IC8vIERvbid0IHRhcCBmb2N1cyBvbiBsYXN0IGVsZW1lbnQgaW4gcm9vdCB1bFxcblxcbiAgICAgICAgICAgIHJldHVybiAhJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaTpsYXN0LWNoaWxkID4gYScpKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgICAgIC8vIERvbid0IGNsb3NlIG9uIGVsZW1lbnQgaW4gcm9vdCB1bFxcbiAgICAgICAgICAgIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaSA+IGEnKSkpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpKTtcXG5cXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKCdhJykuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XFxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluayAmJiAkZWxlbWVudC5hdHRyKCdocmVmJykpIHtcXG4gICAgICAgICAgICAgIC8vIExpbmsgd2l0aCBocmVmXFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJG1lbnVJdGVtcykpIHtcXG4gICAgICAgICAgICAgIC8vIG5vdCBtZW51IGl0ZW0gbWVhbnMgYmFjayBidXR0b25cXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpO1xcblxcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH0sIDEpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcXG4gICAgICAgICAgICAgIC8vIFN1YiBtZW51IGl0ZW1cXG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XFxuXFxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykub25lKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcInRyYW5zaXRpb25lbmRcXFwiXSkoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykubm90KCcuanMtZHJpbGxkb3duLWJhY2sgYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTsgLy8gZW5kIGtleWJvYXJkQWNjZXNzXFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyBhbGwgb3BlbiBlbGVtZW50cywgYW5kIHJldHVybnMgdG8gcm9vdCBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZVxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2Nsb3NlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hpZGVBbGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGVBbGwoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdmFyICRlbGVtID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZlJyk7XFxuICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgIHZhciBjYWxjSGVpZ2h0ID0gJGVsZW0ucGFyZW50KCkuY2xvc2VzdCgndWwnKS5kYXRhKCdjYWxjSGVpZ2h0Jyk7XFxuICAgICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XFxuICAgICAgICAgIGhlaWdodDogY2FsY0hlaWdodFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgY2xvc2luZy5cXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZS56Zi5kcmlsbGRvd24nKTtcXG4gICAgICAkZWxlbS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbSksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGZ1bGx5IGNsb3NlZC5cXG4gICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jY2xvc2VkXFxuICAgICAgICAgKi9cXG5cXG4gICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYuZHJpbGxkb3duJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgZm9yIGVhY2ggYGJhY2tgIGJ1dHRvbiwgYW5kIGNsb3NlcyBvcGVuIG1lbnVzLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyaWxsZG93biNiYWNrXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGFkZCBgYmFja2AgZXZlbnQuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYmFja1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmFjaygkZWxlbSkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKTtcXG4gICAgICAkZWxlbS5jaGlsZHJlbignLmpzLWRyaWxsZG93bi1iYWNrJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbW91c2V1cCBvbiBiYWNrJyk7XFxuICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7IC8vIElmIHRoZXJlIGlzIGEgcGFyZW50IHN1Ym1lbnUsIGNhbGwgc2hvd1xcblxcblxcbiAgICAgICAgdmFyIHBhcmVudFN1Yk1lbnUgPSAkZWxlbS5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKTtcXG5cXG4gICAgICAgIGlmIChwYXJlbnRTdWJNZW51Lmxlbmd0aCkge1xcbiAgICAgICAgICBfdGhpcy5fc2hvdyhwYXJlbnRTdWJNZW51KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBtZW51IGl0ZW1zIHcvbyBzdWJtZW51cyB0byBjbG9zZSBvcGVuIG1lbnVzIG9uIGNsaWNrLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9tZW51TGlua0V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWVudUxpbmtFdmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRtZW51SXRlbXMubm90KCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50Jykub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpcy5faGlkZUFsbCgpO1xcbiAgICAgICAgfSwgMCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzc2VzIGZvciBzdWJtZW51IHRvIHNob3cgaXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IHN1Ym1lbnUgKGB1bGAgdGFnKVxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXIgLSB0cmlnZ2VyIGRyaWxsZG93biBldmVudFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFNob3dTdWJNZW51Q2xhc3Nlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2hvd1N1Yk1lbnVDbGFzc2VzKCRlbGVtLCB0cmlnZ2VyKSB7XFxuICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKS5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcXG4gICAgICAkZWxlbS5wYXJlbnQoJ2xpJykuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcblxcbiAgICAgIGlmICh0cmlnZ2VyID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBDU1MgY2xhc3NlcyBmb3Igc3VibWVudSB0byBoaWRlIGl0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIHRhcmdldCBzdWJtZW51IChgdWxgIHRhZylcXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyIC0gdHJpZ2dlciBkcmlsbGRvd24gZXZlbnRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zZXRIaWRlU3ViTWVudUNsYXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhpZGVTdWJNZW51Q2xhc3NlcygkZWxlbSwgdHJpZ2dlcikge1xcbiAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5hZGRDbGFzcygnaW52aXNpYmxlJykuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcXG4gICAgICAkZWxlbS5wYXJlbnQoJ2xpJykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcXG5cXG4gICAgICBpZiAodHJpZ2dlciA9PT0gdHJ1ZSkge1xcbiAgICAgICAgJGVsZW0udHJpZ2dlcignaGlkZS56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIGEgc3BlY2lmaWMgZHJpbGxkb3duIChzdWIpbWVudSBubyBtYXR0ZXIgd2hpY2ggKHN1YiltZW51IGluIGl0IGlzIGN1cnJlbnRseSB2aXNpYmxlLlxcbiAgICAgKiBDb21wYXJlZCB0byBfc2hvdygpIHRoaXMgbGV0cyB5b3UganVtcCBpbnRvIGFueSBzdWJtZW51IHdpdGhvdXQgY2xpY2tpbmcgdGhyb3VnaCBldmVyeSBzdWJtZW51IG9uIHRoZSB3YXkgdG8gaXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI29wZW5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIHRhcmdldCAoc3ViKW1lbnUgKGB1bGAgdGFnKVxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9Gb2N1cyAtIGlmIHRydWUgdGhlIGZpcnN0IGxpbmsgaW4gdGhlIHRhcmdldCAoc3ViKW1lbnUgZ2V0cyBhdXRvIGZvY3VzZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zaG93TWVudVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd01lbnUoJGVsZW0sIGF1dG9Gb2N1cykge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIFJlc2V0IGRyaWxsZG93blxcblxcblxcbiAgICAgIHZhciAkZXhwYW5kZWRTdWJtZW51cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGlbYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCJdID4gdWxbZGF0YS1zdWJtZW51XScpO1xcbiAgICAgICRleHBhbmRlZFN1Ym1lbnVzLmVhY2goZnVuY3Rpb24gKGluZGV4KSB7XFxuICAgICAgICBfdGhpcy5fc2V0SGlkZVN1Yk1lbnVDbGFzc2VzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSk7XFxuICAgICAgfSk7IC8vIFNhdmUgdGhlIG1lbnUgYXMgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgb25lLlxcblxcbiAgICAgIHRoaXMuJGN1cnJlbnRNZW51ID0gJGVsZW07IC8vIElmIHRhcmdldCBtZW51IGlzIHJvb3QsIGZvY3VzIGZpcnN0IGxpbmsgJiBleGl0XFxuXFxuICAgICAgaWYgKCRlbGVtLmlzKCdbZGF0YS1kcmlsbGRvd25dJykpIHtcXG4gICAgICAgIGlmIChhdXRvRm9jdXMgPT09IHRydWUpICRlbGVtLmZpbmQoJ2xpW3JvbGU9XFxcInRyZWVpdGVtXFxcIl0gPiBhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcygnaGVpZ2h0JywgJGVsZW0uZGF0YSgnY2FsY0hlaWdodCcpKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIEZpbmQgYWxsIHN1Ym1lbnVzIG9uIHdheSB0byByb290IGluY2wuIHRoZSBlbGVtZW50IGl0c2VsZlxcblxcblxcbiAgICAgIHZhciAkc3VibWVudXMgPSAkZWxlbS5jaGlsZHJlbigpLmZpcnN0KCkucGFyZW50c1VudGlsKCdbZGF0YS1kcmlsbGRvd25dJywgJ1tkYXRhLXN1Ym1lbnVdJyk7IC8vIE9wZW4gdGFyZ2V0IG1lbnUgYW5kIGFsbCBzdWJtZW51cyBvbiBpdHMgd2F5IHRvIHJvb3RcXG5cXG4gICAgICAkc3VibWVudXMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcXG4gICAgICAgIC8vIFVwZGF0ZSBoZWlnaHQgb2YgZmlyc3QgY2hpbGQgKHRhcmdldCBtZW51KSBpZiBhdXRvSGVpZ2h0IG9wdGlvbiB0cnVlXFxuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgX3RoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XFxuICAgICAgICAgIF90aGlzLiR3cmFwcGVyLmNzcygnaGVpZ2h0JywganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ2NhbGNIZWlnaHQnKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgaXNMYXN0Q2hpbGQgPSBpbmRleCA9PSAkc3VibWVudXMubGVuZ3RoIC0gMTsgLy8gQWRkIHRyYW5zaXRpb25zZW5kIGxpc3RlbmVyIHRvIGxhc3QgY2hpbGQgKHJvb3QgZHVlIHRvIHJldmVyc2Ugb3JkZXIpIHRvIG9wZW4gdGFyZ2V0IG1lbnUncyBmaXJzdCBsaW5rXFxuICAgICAgICAvLyBMYXN0IGNoaWxkIG1ha2VzIHN1cmUgdGhlIGV2ZW50IGdldHMgYWx3YXlzIHRyaWdnZXJlZCBldmVuIGlmIGdvaW5nIHRocm91Z2ggc2V2ZXJhbCBtZW51c1xcblxcbiAgICAgICAgaWYgKGlzTGFzdENoaWxkID09PSB0cnVlKSB7XFxuICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgJGVsZW0uZmluZCgnbGlbcm9sZT1cXFwidHJlZWl0ZW1cXFwiXSA+IGEnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLl9zZXRTaG93U3ViTWVudUNsYXNzZXMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLCBpc0xhc3RDaGlsZCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIGEgc3VibWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBlbGVtZW50IHdpdGggYSBzdWJtZW51IHRvIG9wZW4sIGkuZS4gdGhlIGBsaWAgdGFnLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3Nob3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coJGVsZW0pIHtcXG4gICAgICB2YXIgJHN1Ym1lbnUgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcXG4gICAgICAkZWxlbS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XFxuICAgICAgdGhpcy4kY3VycmVudE1lbnUgPSAkc3VibWVudTtcXG4gICAgICAkc3VibWVudS5hZGRDbGFzcygnaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xcbiAgICAgICAgdGhpcy4kd3JhcHBlci5jc3Moe1xcbiAgICAgICAgICBoZWlnaHQ6ICRzdWJtZW51LmRhdGEoJ2NhbGNIZWlnaHQnKVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaGFzIG9wZW5lZC5cXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI29wZW5cXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEhpZGVzIGEgc3VibWVudVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyaWxsZG93biNoaWRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGhpZGUsIGkuZS4gdGhlIGB1bGAgdGFnLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hpZGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoJGVsZW0pIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHRoaXMuJHdyYXBwZXIuY3NzKHtcXG4gICAgICAgIGhlaWdodDogJGVsZW0ucGFyZW50KCkuY2xvc2VzdCgndWwnKS5kYXRhKCdjYWxjSGVpZ2h0JylcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICRlbGVtLnBhcmVudCgnbGknKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xcbiAgICAgICRlbGVtLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKS5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSgkZWxlbSksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xcbiAgICAgICAgJGVsZW0uYmx1cigpLmFkZENsYXNzKCdpbnZpc2libGUnKTtcXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzdWJtZW51IGhhcyBjbG9zZWQuXFxuICAgICAgICogQGV2ZW50IERyaWxsZG93biNoaWRlXFxuICAgICAgICovXFxuXFxuICAgICAgJGVsZW0udHJpZ2dlcignaGlkZS56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbmVzdGVkIG1lbnVzIHRvIGNhbGN1bGF0ZSB0aGUgbWluLWhlaWdodCwgYW5kIG1heC13aWR0aCBmb3IgdGhlIG1lbnUuXFxuICAgICAqIFByZXZlbnRzIGNvbnRlbnQganVtcGluZy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0TWF4RGltc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWF4RGltcygpIHtcXG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gMCxcXG4gICAgICAgICAgcmVzdWx0ID0ge30sXFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gUmVjYWxjdWxhdGUgbWVudSBoZWlnaHRzIGFuZCB0b3RhbCBtYXggaGVpZ2h0XFxuXFxuXFxuICAgICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIG51bU9mRWxlbXMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuY2hpbGRyZW4oJ2xpJykubGVuZ3RoO1xcbiAgICAgICAgdmFyIGhlaWdodCA9IF9mb3VuZGF0aW9uX3V0aWxfYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIkJveFxcXCJdLkdldERpbWVuc2lvbnModGhpcykuaGVpZ2h0O1xcbiAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0ID4gbWF4SGVpZ2h0ID8gaGVpZ2h0IDogbWF4SGVpZ2h0O1xcblxcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnY2FsY0hlaWdodCcsIGhlaWdodCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSByZXN1bHRbJ2hlaWdodCddID0gdGhpcy4kY3VycmVudE1lbnUuZGF0YSgnY2FsY0hlaWdodCcpO2Vsc2UgcmVzdWx0WydtaW4taGVpZ2h0J10gPSBcXFwiXFxcIi5jb25jYXQobWF4SGVpZ2h0LCBcXFwicHhcXFwiKTtcXG4gICAgICByZXN1bHRbJ21heC13aWR0aCddID0gXFxcIlxcXCIuY29uY2F0KHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsIFxcXCJweFxcXCIpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG9wKSB0aGlzLiRlbGVtZW50Lm9mZignLnpmLmRyaWxsZG93bicsIHRoaXMuX2JpbmRIYW5kbGVyKTtcXG5cXG4gICAgICB0aGlzLl9oaWRlQWxsKCk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX25lc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiTmVzdFxcXCJdLkJ1cm4odGhpcy4kZWxlbWVudCwgJ2RyaWxsZG93bicpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCkuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbScpLnJlbW92ZSgpLmVuZCgpLmZpbmQoJy5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnUnKS5lbmQoKS5maW5kKCdbZGF0YS1zdWJtZW51XScpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIHRhYmluZGV4IHJvbGUnKTtcXG4gICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWlzLXBhcmVudC1saW5rXScpLmRldGFjaCgpO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLnJlbW92ZUNsYXNzKCdkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91cyBpbnZpc2libGUnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkbGluayA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKTtcXG4gICAgICAgICRsaW5rLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XFxuXFxuICAgICAgICBpZiAoJGxpbmsuZGF0YSgnc2F2ZWRIcmVmJykpIHtcXG4gICAgICAgICAgJGxpbmsuYXR0cignaHJlZicsICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicpKS5yZW1vdmVEYXRhKCdzYXZlZEhyZWYnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIERyaWxsZG93bjtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5EcmlsbGRvd24uZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIERyaWxsZG93bnMgZGVwZW5kIG9uIHN0eWxlcyBpbiBvcmRlciB0byBmdW5jdGlvbiBwcm9wZXJseTsgaW4gdGhlIGRlZmF1bHQgYnVpbGQgb2YgRm91bmRhdGlvbiB0aGVzZSBhcmVcXG4gICAqIG9uIHRoZSBgZHJpbGxkb3duYCBjbGFzcy4gVGhpcyBvcHRpb24gYXV0by1hcHBsaWVzIHRoaXMgY2xhc3MgdG8gdGhlIGRyaWxsZG93biB1cG9uIGluaXRpYWxpemF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGF1dG9BcHBseUNsYXNzOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBNYXJrdXAgdXNlZCBmb3IgSlMgZ2VuZXJhdGVkIGJhY2sgYnV0dG9uLiBQcmVwZW5kZWQgIG9yIGFwcGVuZGVkIChzZWUgYmFja0J1dHRvblBvc2l0aW9uKSB0byBzdWJtZW51IGxpc3RzIGFuZCBkZWxldGVkIG9uIGBkZXN0cm95YCBtZXRob2QsICdqcy1kcmlsbGRvd24tYmFjaycgY2xhc3MgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJzxsaSBjbGFzcz1cXFwianMtZHJpbGxkb3duLWJhY2tcXFwiPjxhIHRhYmluZGV4PVxcXCIwXFxcIj5CYWNrPC9hPjwvbGk+J1xcbiAgICovXFxuICBiYWNrQnV0dG9uOiAnPGxpIGNsYXNzPVxcXCJqcy1kcmlsbGRvd24tYmFja1xcXCI+PGEgdGFiaW5kZXg9XFxcIjBcXFwiPkJhY2s8L2E+PC9saT4nLFxcblxcbiAgLyoqXFxuICAgKiBQb3NpdGlvbiB0aGUgYmFjayBidXR0b24gZWl0aGVyIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIGRyaWxsZG93biBzdWJtZW51cy4gQ2FuIGJlIGAnbGVmdCdgIG9yIGAnYm90dG9tJ2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgdG9wXFxuICAgKi9cXG4gIGJhY2tCdXR0b25Qb3NpdGlvbjogJ3RvcCcsXFxuXFxuICAvKipcXG4gICAqIE1hcmt1cCB1c2VkIHRvIHdyYXAgZHJpbGxkb3duIG1lbnUuIFVzZSBhIGNsYXNzIG5hbWUgZm9yIGluZGVwZW5kZW50IHN0eWxpbmc7IHRoZSBKUyBhcHBsaWVkIGNsYXNzOiBgaXMtZHJpbGxkb3duYCBpcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnPGRpdj48L2Rpdj4nXFxuICAgKi9cXG4gIHdyYXBwZXI6ICc8ZGl2PjwvZGl2PicsXFxuXFxuICAvKipcXG4gICAqIEFkZHMgdGhlIHBhcmVudCBsaW5rIHRvIHRoZSBzdWJtZW51LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBwYXJlbnRMaW5rOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gcmV0dXJuIHRvIHJvb3QgbGlzdCBvbiBib2R5IGNsaWNrLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgbWVudSB0byBhdXRvIGFkanVzdCBoZWlnaHQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGF1dG9IZWlnaHQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbmltYXRlIHRoZSBhdXRvIGFkanVzdCBoZWlnaHQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFuaW1hdGVIZWlnaHQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgbWVudSBhZnRlciBvcGVuaW5nIGEgc3VibWVudSBvciBuYXZpZ2F0aW5nIGJhY2sgdXNpbmcgdGhlIG1lbnUgYmFjayBidXR0b25cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgc2Nyb2xsVG9wOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogU3RyaW5nIGpxdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgJ2JvZHknKSBvZiBlbGVtZW50IHRvIHRha2Ugb2Zmc2V0KCkudG9wIGZyb20sIGlmIGVtcHR5IHN0cmluZyB0aGUgZHJpbGxkb3duIG1lbnUgb2Zmc2V0KCkudG9wIGlzIHRha2VuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgc2Nyb2xsVG9wRWxlbWVudDogJycsXFxuXFxuICAvKipcXG4gICAqIFNjcm9sbFRvcCBvZmZzZXRcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIHNjcm9sbFRvcE9mZnNldDogMCxcXG5cXG4gIC8qKlxcbiAgICogU2Nyb2xsIGFuaW1hdGlvbiBkdXJhdGlvblxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDUwMFxcbiAgICovXFxuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxcblxcbiAgLyoqXFxuICAgKiBTY3JvbGwgYW5pbWF0aW9uIGVhc2luZy4gQ2FuIGJlIGAnc3dpbmcnYCBvciBgJ2xpbmVhcidgLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYW5pbWF0ZXxKUXVlcnkgYW5pbWF0ZX1cXG4gICAqIEBkZWZhdWx0ICdzd2luZydcXG4gICAqL1xcbiAgYW5pbWF0aW9uRWFzaW5nOiAnc3dpbmcnIC8vIGhvbGRPcGVuOiBmYWxzZVxcblxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5kcmlsbGRvd24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uZHJvcGRvd24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5kcm9wZG93bi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRHJvcGRvd24gKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkRyb3Bkb3duXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEcm9wZG93bjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnBvc2l0aW9uYWJsZSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnBvc2l0aW9uYWJsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudG91Y2ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XFxuXFxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBEcm9wZG93biBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKi9cXG5cXG52YXIgRHJvcGRvd24gPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1Bvc2l0aW9uYWJsZSkge1xcbiAgX2luaGVyaXRzKERyb3Bkb3duLCBfUG9zaXRpb25hYmxlKTtcXG5cXG4gIGZ1bmN0aW9uIERyb3Bkb3duKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERyb3Bkb3duKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIERyb3Bkb3duXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93bi5cXG4gICAgICogICAgICAgIE9iamVjdCBzaG91bGQgYmUgb2YgdGhlIGRyb3Bkb3duIHBhbmVsLCByYXRoZXIgdGhhbiBpdHMgYW5jaG9yLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBEcm9wZG93bi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0Ryb3Bkb3duJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuICAgICAgLy8gVG91Y2ggYW5kIFRyaWdnZXJzIGluaXQgYXJlIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgdGhleSBhcmUgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRvdWNoXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignRHJvcGRvd24nLCB7XFxuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcXG4gICAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBzZXR0aW5nL2NoZWNraW5nIG9wdGlvbnMgYW5kIGF0dHJpYnV0ZXMsIGFkZGluZyBoZWxwZXIgdmFyaWFibGVzLCBhbmQgc2F2aW5nIHRoZSBhbmNob3IuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyICRpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcXG4gICAgICB0aGlzLiRhbmNob3JzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS10b2dnbGU9XFxcXFxcXCJcXFwiLmNvbmNhdCgkaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSkubGVuZ3RoID8ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS10b2dnbGU9XFxcXFxcXCJcXFwiLmNvbmNhdCgkaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSkgOiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIltkYXRhLW9wZW49XFxcXFxcXCJcXFwiLmNvbmNhdCgkaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgICAgdGhpcy4kYW5jaG9ycy5hdHRyKHtcXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogJGlkLFxcbiAgICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX3NldEN1cnJlbnRBbmNob3IodGhpcy4kYW5jaG9ycy5maXJzdCgpKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudENsYXNzKSB7XFxuICAgICAgICB0aGlzLiRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudHMoJy4nICsgdGhpcy5vcHRpb25zLnBhcmVudENsYXNzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gbnVsbDtcXG4gICAgICB9IC8vIFNldCBbYXJpYS1sYWJlbGxlZGJ5XSBvbiB0aGUgRHJvcGRvd24gaWYgaXQgaXMgbm90IHNldFxcblxcblxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vIEdldCB0aGUgYW5jaG9yIElEIG9yIGNyZWF0ZSBvbmVcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdpZCcpID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICB0aGlzLiRjdXJyZW50QW5jaG9yLmF0dHIoJ2lkJywgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ2RkLWFuY2hvcicpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdpZCcpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogJGlkXFxuICAgICAgfSk7XFxuXFxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgXFxcIl9pbml0XFxcIiwgdGhpcykuY2FsbCh0aGlzKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0RGVmYXVsdFBvc2l0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZhdWx0UG9zaXRpb24oKSB7XFxuICAgICAgLy8gaGFuZGxlIGxlZ2FjeSBjbGFzc25hbWVzXFxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyh0b3B8bGVmdHxyaWdodHxib3R0b20pL2cpO1xcblxcbiAgICAgIGlmIChwb3NpdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uWzBdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXREZWZhdWx0QWxpZ25tZW50XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZhdWx0QWxpZ25tZW50KCkge1xcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgZmxvYXQgYXBwcm9hY2hcXG4gICAgICB2YXIgaG9yaXpvbnRhbFBvc2l0aW9uID0gL2Zsb2F0LShcXFxcUyspLy5leGVjKHRoaXMuJGN1cnJlbnRBbmNob3IuYXR0cignY2xhc3MnKSk7XFxuXFxuICAgICAgaWYgKGhvcml6b250YWxQb3NpdGlvbikge1xcbiAgICAgICAgcmV0dXJuIGhvcml6b250YWxQb3NpdGlvblsxXTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKERyb3Bkb3duLnByb3RvdHlwZSksIFxcXCJfZ2V0RGVmYXVsdEFsaWdubWVudFxcXCIsIHRoaXMpLmNhbGwodGhpcyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZHJvcGRvd24gcGFuZSwgY2hlY2tzIGZvciBjb2xsaXNpb25zIGlmIGFsbG93LW92ZXJsYXAgaXMgbm90IHRydWUuXFxuICAgICAqIFJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiBpZiBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCwgd2l0aCBhIG5ldyBwb3NpdGlvbiBjbGFzcy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0UG9zaXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uKCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImhhcy1wb3NpdGlvbi1cXFwiLmNvbmNhdCh0aGlzLnBvc2l0aW9uLCBcXFwiIGhhcy1hbGlnbm1lbnQtXFxcIikuY29uY2F0KHRoaXMuYWxpZ25tZW50KSk7XFxuXFxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgXFxcIl9zZXRQb3NpdGlvblxcXCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcy4kY3VycmVudEFuY2hvciwgdGhpcy4kZWxlbWVudCwgdGhpcy4kcGFyZW50KTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJoYXMtcG9zaXRpb24tXFxcIi5jb25jYXQodGhpcy5wb3NpdGlvbiwgXFxcIiBoYXMtYWxpZ25tZW50LVxcXCIpLmNvbmNhdCh0aGlzLmFsaWdubWVudCkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBNYWtlIGl0IGEgY3VycmVudCBhbmNob3IuXFxuICAgICAqIEN1cnJlbnQgYW5jaG9yIGFzIHRoZSByZWZlcmVuY2UgZm9yIHRoZSBwb3NpdGlvbiBvZiBEcm9wZG93biBwYW5lcy5cXG4gICAgICogQHBhcmFtIHtIVE1MfSBlbCAtIERPTSBlbGVtZW50IG9mIHRoZSBhbmNob3IuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldEN1cnJlbnRBbmNob3JcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEN1cnJlbnRBbmNob3IoZWwpIHtcXG4gICAgICB0aGlzLiRjdXJyZW50QW5jaG9yID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGVsZW1lbnQgdXRpbGl6aW5nIHRoZSB0cmlnZ2VycyB1dGlsaXR5IGxpYnJhcnkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIGhhc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogdGhpcy5fc2V0UG9zaXRpb24uYmluZCh0aGlzKVxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJGFuY2hvcnMub2ZmKCdjbGljay56Zi50cmlnZ2VyJykub24oJ2NsaWNrLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgX3RoaXMuX3NldEN1cnJlbnRBbmNob3IodGhpcyk7XFxuXFxuICAgICAgICBpZiAoIC8vIGlmIGZvcmNlRm9sbG93IGZhbHNlLCBhbHdheXMgcHJldmVudCBkZWZhdWx0IGFjdGlvblxcbiAgICAgICAgX3RoaXMub3B0aW9ucy5mb3JjZUZvbGxvdyA9PT0gZmFsc2UgfHwgLy8gaWYgZm9yY2VGb2xsb3cgdHJ1ZSBhbmQgaG92ZXIgb3B0aW9uIHRydWUsIG9ubHkgcHJldmVudCBkZWZhdWx0IGFjdGlvbiBvbiAxc3QgY2xpY2tcXG4gICAgICAgIC8vIG9uIDJuZCBjbGljayAoZHJvcG93biBvcGVuZWQpIHRoZSBkZWZhdWx0IGFjdGlvbiAoZS5nLiBmb2xsb3cgYSBocmVmKSBnZXRzIGV4ZWN1dGVkXFxuICAgICAgICBoYXNUb3VjaCAmJiBfdGhpcy5vcHRpb25zLmhvdmVyICYmIF90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgPT09IGZhbHNlKSB7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyKSB7XFxuICAgICAgICB0aGlzLiRhbmNob3JzLm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJykub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLl9zZXRDdXJyZW50QW5jaG9yKHRoaXMpO1xcblxcbiAgICAgICAgICB2YXIgYm9keURhdGEgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2JvZHknKS5kYXRhKCk7XFxuXFxuICAgICAgICAgIGlmICh0eXBlb2YgYm9keURhdGEud2hhdGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCBib2R5RGF0YS53aGF0aW5wdXQgPT09ICdtb3VzZScpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMub3BlbigpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvcnMuZGF0YSgnaG92ZXInLCB0cnVlKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsIE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImlnbm9yZU1vdXNlZGlzYXBwZWFyXFxcIl0pKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5kYXRhKCdob3ZlcicsIGZhbHNlKTtcXG4gICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcXG4gICAgICAgIH0pKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJQYW5lKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKS5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaWdub3JlTW91c2VkaXNhcHBlYXJcXFwiXSkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcXG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvcnMuZGF0YSgnaG92ZXInLCBmYWxzZSk7XFxuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcXG4gICAgICAgICAgfSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRhbmNob3JzLmFkZCh0aGlzLiRlbGVtZW50KS5vbigna2V5ZG93bi56Zi5kcm9wZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB2YXIgJHRhcmdldCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMgPSBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0uZmluZEZvY3VzYWJsZShfdGhpcy4kZWxlbWVudCk7XFxuICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0uaGFuZGxlS2V5KGUsICdEcm9wZG93bicsIHtcXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAgICAgICBpZiAoJHRhcmdldC5pcyhfdGhpcy4kYW5jaG9ycykgJiYgISR0YXJnZXQuaXMoJ2lucHV0LCB0ZXh0YXJlYScpKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5vcGVuKCk7XFxuXFxuICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuJGFuY2hvcnMuZm9jdXMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEJvZHlIYW5kbGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb2R5SGFuZGxlcigpIHtcXG4gICAgICB2YXIgJGJvZHkgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93biB0YXAuemYuZHJvcGRvd24nKS5vbignY2xpY2suemYuZHJvcGRvd24gdGFwLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChfdGhpcy4kYW5jaG9ycy5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGFuY2hvcnMuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLmNsb3NlKCk7XFxuXFxuICAgICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duIHRhcC56Zi5kcm9wZG93bicpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgZHJvcGRvd24gcGFuZSwgYW5kIGZpcmVzIGEgYnViYmxpbmcgZXZlbnQgdG8gY2xvc2Ugb3RoZXIgZHJvcGRvd25zLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyb3Bkb3duI2Nsb3NlbWVcXG4gICAgICogQGZpcmVzIERyb3Bkb3duI3Nob3dcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIm9wZW5cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAvLyB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHRvIGNsb3NlIG90aGVyIG9wZW4gZHJvcGRvd25zLCB0eXBpY2FsbHkgd2hlbiBkcm9wZG93biBpcyBvcGVuaW5nXFxuICAgICAgICogQGV2ZW50IERyb3Bkb3duI2Nsb3NlbWVcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYuZHJvcGRvd24nLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xcbiAgICAgIHRoaXMuJGFuY2hvcnMuYWRkQ2xhc3MoJ2hvdmVyJykuYXR0cih7XFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWVcXG4gICAgICB9KTsgLy8gdGhpcy4kZWxlbWVudC8qLnNob3coKSovO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW5pbmcnKTtcXG5cXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW5pbmcnKS5hZGRDbGFzcygnaXMtb3BlbicpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xcbiAgICAgICAgdmFyICRmb2N1c2FibGUgPSBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0uZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICAgIGlmICgkZm9jdXNhYmxlLmxlbmd0aCkge1xcbiAgICAgICAgICAkZm9jdXNhYmxlLmVxKDApLmZvY3VzKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYXBGb2N1cykge1xcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJLZXlib2FyZFxcXCJdLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgb25jZSB0aGUgZHJvcGRvd24gaXMgdmlzaWJsZS5cXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd24jc2hvd1xcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bicsIFt0aGlzLiRlbGVtZW50XSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgb3BlbiBkcm9wZG93biBwYW5lLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyb3Bkb3duI2hpZGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNsb3NlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6IHRydWVcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLiRhbmNob3JzLnJlbW92ZUNsYXNzKCdob3ZlcicpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgb25jZSB0aGUgZHJvcGRvd24gaXMgbm8gbG9uZ2VyIHZpc2libGUuXFxuICAgICAgICogQGV2ZW50IERyb3Bkb3duI2hpZGVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7XFxuICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0ucmVsZWFzZUZvY3VzKHRoaXMuJGVsZW1lbnQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgZHJvcGRvd24gcGFuZSdzIHZpc2liaWxpdHkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9nZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XFxuICAgICAgICBpZiAodGhpcy4kYW5jaG9ycy5kYXRhKCdob3ZlcicpKSByZXR1cm47XFxuICAgICAgICB0aGlzLmNsb3NlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMub3BlbigpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIGRyb3Bkb3duLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlcicpLmhpZGUoKTtcXG4gICAgICB0aGlzLiRhbmNob3JzLm9mZignLnpmLmRyb3Bkb3duJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50LmJvZHkpLm9mZignY2xpY2suemYuZHJvcGRvd24gdGFwLnpmLmRyb3Bkb3duJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBEcm9wZG93bjtcXG59KF9mb3VuZGF0aW9uX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJQb3NpdGlvbmFibGVcXFwiXSk7XFxuXFxuRHJvcGRvd24uZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIENsYXNzIHRoYXQgZGVzaWduYXRlcyBib3VuZGluZyBjb250YWluZXIgb2YgRHJvcGRvd24gKGRlZmF1bHQ6IHdpbmRvdylcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBwYXJlbnRDbGFzczogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgb3BlbmluZyBhIHN1Ym1lbnUgb24gaG92ZXIgZXZlbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMjUwXFxuICAgKi9cXG4gIGhvdmVyRGVsYXk6IDI1MCxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgc3VibWVudXMgdG8gb3BlbiBvbiBob3ZlciBldmVudHNcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgaG92ZXI6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBEb24ndCBjbG9zZSBkcm9wZG93biB3aGVuIGhvdmVyaW5nIG92ZXIgZHJvcGRvd24gcGFuZVxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBob3ZlclBhbmU6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIHZPZmZzZXQ6IDAsXFxuXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgaE9mZnNldDogMCxcXG5cXG4gIC8qKlxcbiAgICogUG9zaXRpb24gb2YgZHJvcGRvd24uIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG9yIGF1dG8uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2F1dG8nXFxuICAgKi9cXG4gIHBvc2l0aW9uOiAnYXV0bycsXFxuXFxuICAvKipcXG4gICAqIEFsaWdubWVudCBvZiBkcm9wZG93biByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIGNlbnRlciwgb3IgYXV0by5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgYWxpZ25tZW50OiAnYXV0bycsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIGRyb3Bkb3duIHdpbGwgZmlyc3QgdHJ5IHRvIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dCByZXBvc2l0aW9uIGlmIGl0IHdvdWxkIGNhdXNlIGFuIG92ZXJmbG93LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBhbGxvd092ZXJsYXA6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBvdmVybGFwIG9mIG9ubHkgdGhlIGJvdHRvbSBvZiB0aGUgY29udGFpbmVyLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vblxcbiAgICogYmVoYXZpb3IgZm9yIGRyb3Bkb3ducywgYWxsb3dpbmcgdGhlIGRyb3Bkb3duIHRvIGV4dGVuZCB0aGUgYm90dG9tIG9mIHRoZVxcbiAgICogc2NyZWVuIGJ1dCBub3Qgb3RoZXJ3aXNlIGluZmx1ZW5jZSBvciBicmVhayBvdXQgb2YgdGhlIGNvbnRhaW5lci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBhbGxvd0JvdHRvbU92ZXJsYXA6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBwbHVnaW4gdG8gdHJhcCBmb2N1cyB0byB0aGUgZHJvcGRvd24gcGFuZSBpZiBvcGVuZWQgd2l0aCBrZXlib2FyZCBjb21tYW5kcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdHJhcEZvY3VzOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIHBsdWdpbiB0byBzZXQgZm9jdXMgdG8gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgcGFuZSwgcmVnYXJkbGVzcyBvZiBtZXRob2Qgb2Ygb3BlbmluZy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYXV0b0ZvY3VzOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIGEgY2xpY2sgb24gdGhlIGJvZHkgdG8gY2xvc2UgdGhlIGRyb3Bkb3duLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiB0cnVlIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgdG9nZ2xlIChlLmcuIGZvbGxvdyBhIGxpbmsgd2l0aCBocmVmKSBnZXRzIGV4ZWN1dGVkIG9uIGNsaWNrLiBJZiBob3ZlciBvcHRpb24gaXMgYWxzbyB0cnVlIHRoZSBkZWZhdWx0IGFjdGlvbiBnZXRzIHByZXZlbnRlZCBvbiBmaXJzdCBjbGljayBmb3IgbW9iaWxlIC8gdG91Y2ggZGV2aWNlcyBhbmQgZXhlY3V0ZWQgb24gc2Vjb25kIGNsaWNrLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGZvcmNlRm9sbG93OiB0cnVlXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLmRyb3Bkb3duTWVudS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5kcm9wZG93bk1lbnUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBEcm9wZG93bk1lbnUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkRyb3Bkb3duTWVudVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRHJvcGRvd25NZW51OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbmVzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubmVzdCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubmVzdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuYm94ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5ib3guanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudG91Y2ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRHJvcGRvd25NZW51IG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd25NZW51XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxcbiAqL1xcblxcbnZhciBEcm9wZG93bk1lbnUgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKERyb3Bkb3duTWVudSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBEcm9wZG93bk1lbnUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bk1lbnUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERyb3Bkb3duTWVudSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoRHJvcGRvd25NZW51LCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBEcm9wZG93bk1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBEcm9wZG93bk1lbnVcXG4gICAgICogQGZpcmVzIERyb3Bkb3duTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBEcm9wZG93bk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdEcm9wZG93bk1lbnUnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcIlRvdWNoXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyAvLyBUb3VjaCBpbml0IGlzIGlkZW1wb3RlbnQsIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBpbml0aWFsaWVkLlxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0ucmVnaXN0ZXIoJ0Ryb3Bkb3duTWVudScsIHtcXG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcXG4gICAgICAgICdBUlJPV19VUCc6ICd1cCcsXFxuICAgICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4sIGFuZCBjYWxscyBfcHJlcGFyZU1lbnVcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX25lc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiTmVzdFxcXCJdLkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2Ryb3Bkb3duJyk7XFxuICAgICAgdmFyIHN1YnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykuYWRkQ2xhc3MoJ2ZpcnN0LXN1YicpO1xcbiAgICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGlbcm9sZT1cXFwibm9uZVxcXCJdJyk7XFxuICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ2xpW3JvbGU9XFxcIm5vbmVcXFwiXScpO1xcbiAgICAgIHRoaXMuJHRhYnMuZmluZCgndWwuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2F1dG8nKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcykgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwicnRsXFxcIl0pKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcudG9wLWJhci1yaWdodCcpLmlzKCcqJykpIHtcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9ICdyaWdodCc7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPSAnbGVmdCc7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pc1ZlcnRpY2FsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZlcnRpY2FsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLiR0YWJzLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snIHx8IHRoaXMuJGVsZW1lbnQuY3NzKCdmbGV4LWRpcmVjdGlvbicpID09PSAnY29sdW1uJztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaXNSdGxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzUnRsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhbGlnbi1yaWdodCcpIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInJ0bFxcXCJdKSgpICYmICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhbGlnbi1sZWZ0Jyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBoYXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCAhPT0gJ3VuZGVmaW5lZCcsXFxuICAgICAgICAgIHBhckNsYXNzID0gJ2lzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JzsgLy8gdXNlZCBmb3Igb25DbGljayBhbmQgaW4gdGhlIGtleWJvYXJkIGhhbmRsZXJzXFxuXFxuXFxuICAgICAgdmFyIGhhbmRsZUNsaWNrRm4gPSBmdW5jdGlvbiBoYW5kbGVDbGlja0ZuKGUpIHtcXG4gICAgICAgIHZhciAkZWxlbSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsIFxcXCIuXFxcIi5jb25jYXQocGFyQ2xhc3MpKSxcXG4gICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyksXFxuICAgICAgICAgICAgaGFzQ2xpY2tlZCA9ICRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnLFxcbiAgICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtcXG5cXG4gICAgICAgIGlmIChoYXNTdWIpIHtcXG4gICAgICAgICAgaWYgKGhhc0NsaWNrZWQpIHtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8ICFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbiAmJiAhaGFzVG91Y2ggfHwgX3RoaXMub3B0aW9ucy5mb3JjZUZvbGxvdyAmJiBoYXNUb3VjaCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuX3Nob3coJHN1Yik7XFxuXFxuICAgICAgICAgICAgJGVsZW0uYWRkKCRlbGVtLnBhcmVudHNVbnRpbChfdGhpcy4kZWxlbWVudCwgXFxcIi5cXFwiLmNvbmNhdChwYXJDbGFzcykpKS5hdHRyKCdkYXRhLWlzLWNsaWNrJywgdHJ1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuIHx8IGhhc1RvdWNoKSB7XFxuICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2NsaWNrLnpmLmRyb3Bkb3duTWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3duTWVudScsIGhhbmRsZUNsaWNrRm4pO1xcbiAgICAgIH0gLy8gSGFuZGxlIExlYWYgZWxlbWVudCBDbGlja3NcXG5cXG5cXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2tJbnNpZGUpIHtcXG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignY2xpY2suemYuZHJvcGRvd25NZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgdmFyICRlbGVtID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xcblxcbiAgICAgICAgICBpZiAoIWhhc1N1Yikge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcXG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bk1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgJGVsZW0gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XFxuXFxuICAgICAgICAgIGlmIChoYXNTdWIpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJGVsZW0uZGF0YSgnX2RlbGF5JykpO1xcbiAgICAgICAgICAgICRlbGVtLmRhdGEoJ19kZWxheScsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykpO1xcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bk1lbnUnLCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJpZ25vcmVNb3VzZWRpc2FwcGVhclxcXCJdKShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgJGVsZW0gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XFxuXFxuICAgICAgICAgIGlmIChoYXNTdWIgJiYgX3RoaXMub3B0aW9ucy5hdXRvY2xvc2UpIHtcXG4gICAgICAgICAgICBpZiAoJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScgJiYgX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCRlbGVtLmRhdGEoJ19kZWxheScpKTtcXG4gICAgICAgICAgICAkZWxlbS5kYXRhKCdfZGVsYXknLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmNsb3NpbmdUaW1lKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdrZXlkb3duLnpmLmRyb3Bkb3duTWVudScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB2YXIgJGVsZW1lbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnW3JvbGU9XFxcIm5vbmVcXFwiXScpLFxcbiAgICAgICAgICAgIGlzVGFiID0gX3RoaXMuJHRhYnMuaW5kZXgoJGVsZW1lbnQpID4gLTEsXFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gaXNUYWIgPyBfdGhpcy4kdGFicyA6ICRlbGVtZW50LnNpYmxpbmdzKCdsaScpLmFkZCgkZWxlbWVudCksXFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudDtcXG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuaXMoJGVsZW1lbnQpKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkgLSAxKTtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoaSArIDEpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBmdW5jdGlvbiBuZXh0U2libGluZygpIHtcXG4gICAgICAgICAgJG5leHRFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBwcmV2U2libGluZyA9IGZ1bmN0aW9uIHByZXZTaWJsaW5nKCkge1xcbiAgICAgICAgICAkcHJldkVsZW1lbnQuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIG9wZW5TdWIgPSBmdW5jdGlvbiBvcGVuU3ViKCkge1xcbiAgICAgICAgICB2YXIgJHN1YiA9ICRlbGVtZW50LmNoaWxkcmVuKCd1bC5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XFxuXFxuICAgICAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xcbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRzdWIpO1xcblxcbiAgICAgICAgICAgICRlbGVtZW50LmZpbmQoJ2xpID4gYTpmaXJzdCcpLmZvY3VzKCk7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBjbG9zZVN1YiA9IGZ1bmN0aW9uIGNsb3NlU3ViKCkge1xcbiAgICAgICAgICAvL2lmICgkZWxlbWVudC5pcygnOmZpcnN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgdmFyIGNsb3NlID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKTtcXG4gICAgICAgICAgY2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xcblxcbiAgICAgICAgICBfdGhpcy5faGlkZShjbG9zZSk7XFxuXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy99XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IHtcXG4gICAgICAgICAgb3Blbjogb3BlblN1YixcXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKF90aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kbWVudUl0ZW1zLmVxKDApLmNoaWxkcmVuKCdhJykuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxcblxcblxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmIChpc1RhYikge1xcbiAgICAgICAgICBpZiAoX3RoaXMuX2lzVmVydGljYWwoKSkge1xcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsIG1lbnVcXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzUnRsKCkpIHtcXG4gICAgICAgICAgICAgIC8vIHJpZ2h0IGFsaWduZWRcXG4gICAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YlxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIGxlZnQgYWxpZ25lZFxcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBtZW51XFxuICAgICAgICAgICAgaWYgKF90aGlzLl9pc1J0bCgpKSB7XFxuICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKGZ1bmN0aW9ucywge1xcbiAgICAgICAgICAgICAgICBuZXh0OiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICBkb3duOiBvcGVuU3ViLFxcbiAgICAgICAgICAgICAgICB1cDogY2xvc2VTdWJcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcXG4gICAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogcHJldlNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIGRvd246IG9wZW5TdWIsXFxuICAgICAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBub3QgdGFicyAtPiBvbmUgc3ViXFxuICAgICAgICAgIGlmIChfdGhpcy5faXNSdGwoKSkge1xcbiAgICAgICAgICAgIC8vIHJpZ2h0IGFsaWduZWRcXG4gICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKGZ1bmN0aW9ucywge1xcbiAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXFxuICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YixcXG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXFxuICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXFxuICAgICAgICAgICAgICBwcmV2aW91czogY2xvc2VTdWIsXFxuICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcXG4gICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0uaGFuZGxlS2V5KGUsICdEcm9wZG93bk1lbnUnLCBmdW5jdGlvbnMpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGJvZHkgdG8gY2xvc2UgYW55IGRyb3Bkb3ducyBvbiBhIGNsaWNrLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQm9keUhhbmRsZXIoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdmFyICRib2R5ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50LmJvZHkpO1xcblxcbiAgICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKCk7XFxuXFxuICAgICAgJGJvZHkub24oJ2NsaWNrLnpmLmRyb3Bkb3duTWVudSB0YXAuemYuZHJvcGRvd25NZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciBpc0l0c2VsZiA9ICEhanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUudGFyZ2V0KS5jbG9zZXN0KF90aGlzMi4kZWxlbWVudCkubGVuZ3RoO1xcbiAgICAgICAgaWYgKGlzSXRzZWxmKSByZXR1cm47XFxuXFxuICAgICAgICBfdGhpczIuX2hpZGUoKTtcXG5cXG4gICAgICAgIF90aGlzMi5fcmVtb3ZlQm9keUhhbmRsZXIoKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIHRoZSBib2R5IGV2ZW50IGhhbmRsZXIuIFNlZSBgX2FkZEJvZHlIYW5kbGVyYC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVtb3ZlQm9keUhhbmRsZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUJvZHlIYW5kbGVyKCkge1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudC5ib2R5KS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duTWVudSB0YXAuemYuZHJvcGRvd25NZW51Jyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIGEgZHJvcGRvd24gcGFuZSwgYW5kIGNoZWNrcyBmb3IgY29sbGlzaW9ucyBmaXJzdC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRzdWIgLSB1bCBlbGVtZW50IHRoYXQgaXMgYSBzdWJtZW51IHRvIHNob3dcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjc2hvd1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3Nob3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coJHN1Yikge1xcbiAgICAgIHZhciBpZHggPSB0aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCkuZmluZCgkc3ViKS5sZW5ndGggPiAwO1xcbiAgICAgIH0pKTtcXG4gICAgICB2YXIgJHNpYnMgPSAkc3ViLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5zaWJsaW5ncygnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcXG5cXG4gICAgICB0aGlzLl9oaWRlKCRzaWJzLCBpZHgpO1xcblxcbiAgICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLmFkZENsYXNzKCdqcy1kcm9wZG93bi1hY3RpdmUnKS5wYXJlbnQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgICAgIHZhciBjbGVhciA9IF9mb3VuZGF0aW9uX3V0aWxfYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIkJveFxcXCJdLkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFjbGVhcikge1xcbiAgICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJy1yaWdodCcgOiAnLWxlZnQnLFxcbiAgICAgICAgICAgICRwYXJlbnRMaSA9ICRzdWIucGFyZW50KCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcXG4gICAgICAgICRwYXJlbnRMaS5yZW1vdmVDbGFzcyhcXFwib3BlbnNcXFwiLmNvbmNhdChvbGRDbGFzcykpLmFkZENsYXNzKFxcXCJvcGVucy1cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYWxpZ25tZW50KSk7XFxuICAgICAgICBjbGVhciA9IF9mb3VuZGF0aW9uX3V0aWxfYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIkJveFxcXCJdLkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XFxuXFxuICAgICAgICBpZiAoIWNsZWFyKSB7XFxuICAgICAgICAgICRwYXJlbnRMaS5yZW1vdmVDbGFzcyhcXFwib3BlbnMtXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmFsaWdubWVudCkpLmFkZENsYXNzKCdvcGVucy1pbm5lcicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG5ldyBkcm9wZG93biBwYW5lIGlzIHZpc2libGUuXFxuICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNzaG93XFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3duTWVudScsIFskc3ViXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEhpZGVzIGEgc2luZ2xlLCBjdXJyZW50bHkgb3BlbiBkcm9wZG93biBwYW5lLCBpZiBwYXNzZWQgYSBwYXJhbWV0ZXIsIG90aGVyd2lzZSwgaGlkZXMgZXZlcnl0aGluZy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gaGlkZVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlICR0YWJzIGNvbGxlY3Rpb24gdG8gaGlkZVxcbiAgICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I2hpZGVcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9oaWRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCRlbGVtLCBpZHgpIHtcXG4gICAgICB2YXIgJHRvQ2xvc2U7XFxuXFxuICAgICAgaWYgKCRlbGVtICYmICRlbGVtLmxlbmd0aCkge1xcbiAgICAgICAgJHRvQ2xvc2UgPSAkZWxlbTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZHggIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAkdG9DbG9zZSA9IHRoaXMuJHRhYnMubm90KGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgICByZXR1cm4gaSA9PT0gaWR4O1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICR0b0Nsb3NlID0gdGhpcy4kZWxlbWVudDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNvbWV0aGluZ1RvQ2xvc2UgPSAkdG9DbG9zZS5oYXNDbGFzcygnaXMtYWN0aXZlJykgfHwgJHRvQ2xvc2UuZmluZCgnLmlzLWFjdGl2ZScpLmxlbmd0aCA+IDA7XFxuXFxuICAgICAgaWYgKHNvbWV0aGluZ1RvQ2xvc2UpIHtcXG4gICAgICAgIHZhciAkYWN0aXZlSXRlbSA9ICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWFjdGl2ZScpO1xcbiAgICAgICAgJGFjdGl2ZUl0ZW0uYWRkKCR0b0Nsb3NlKS5hdHRyKHtcXG4gICAgICAgICAgJ2RhdGEtaXMtY2xpY2snOiBmYWxzZVxcbiAgICAgICAgfSkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgICAgICAgJHRvQ2xvc2UuZmluZCgndWwuanMtZHJvcGRvd24tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlZCB8fCAkdG9DbG9zZS5maW5kKCdvcGVucy1pbm5lcicpLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xcbiAgICAgICAgICAkdG9DbG9zZS5maW5kKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmFkZCgkdG9DbG9zZSkucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLWlubmVyIG9wZW5zLVxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpKS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIi5jb25jYXQob2xkQ2xhc3MpKTtcXG4gICAgICAgICAgdGhpcy5jaGFuZ2VkID0gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjbGVhclRpbWVvdXQoJGFjdGl2ZUl0ZW0uZGF0YSgnX2RlbGF5JykpO1xcblxcbiAgICAgICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIoKTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb3BlbiBtZW51cyBhcmUgY2xvc2VkLlxcbiAgICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNoaWRlXFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bk1lbnUnLCBbJHRvQ2xvc2VdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm9mZignLnpmLmRyb3Bkb3duTWVudScpLnJlbW92ZUF0dHIoJ2RhdGEtaXMtY2xpY2snKS5yZW1vdmVDbGFzcygnaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXInKTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSkub2ZmKCcuemYuZHJvcGRvd25NZW51Jyk7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIk5lc3RcXFwiXS5CdXJuKHRoaXMuJGVsZW1lbnQsICdkcm9wZG93bicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gRHJvcGRvd25NZW51O1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUGx1Z2luXFxcIl0pO1xcbi8qKlxcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxcbiAqL1xcblxcblxcbkRyb3Bkb3duTWVudS5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogRGlzYWxsb3dzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgc3VibWVudXNcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGlzYWJsZUhvdmVyOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgYSBzdWJtZW51IHRvIGF1dG9tYXRpY2FsbHkgY2xvc2Ugb24gYSBtb3VzZWxlYXZlIGV2ZW50LCBpZiBub3QgY2xpY2tlZCBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGF1dG9jbG9zZTogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgb3BlbmluZyBhIHN1Ym1lbnUgb24gaG92ZXIgZXZlbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTBcXG4gICAqL1xcbiAgaG92ZXJEZWxheTogNTAsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IGEgc3VibWVudSB0byBvcGVuL3JlbWFpbiBvcGVuIG9uIHBhcmVudCBjbGljayBldmVudC4gQWxsb3dzIGN1cnNvciB0byBtb3ZlIGF3YXkgZnJvbSBtZW51LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBjbGlja09wZW46IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBjbG9zaW5nIGEgc3VibWVudSBvbiBhIG1vdXNlbGVhdmUgZXZlbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTAwXFxuICAgKi9cXG4gIGNsb3NpbmdUaW1lOiA1MDAsXFxuXFxuICAvKipcXG4gICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHdoYXQgZGlyZWN0aW9uIHRoZSBzdWJtZW51cyBzaG91bGQgb3Blbi4gSGFuZGxlZCBieSBKUy4gQ2FuIGJlIGAnYXV0bydgLCBgJ2xlZnQnYCBvciBgJ3JpZ2h0J2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2F1dG8nXFxuICAgKi9cXG4gIGFsaWdubWVudDogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBjbGlja3Mgb24gdGhlIGJvZHkgdG8gY2xvc2UgYW55IG9wZW4gc3VibWVudXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBjbGlja3Mgb24gbGVhZiBhbmNob3IgbGlua3MgdG8gY2xvc2UgYW55IG9wZW4gc3VibWVudXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgY2xvc2VPbkNsaWNrSW5zaWRlOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHZlcnRpY2FsIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYHZlcnRpY2FsYC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xcbiAgICovXFxuICB2ZXJ0aWNhbENsYXNzOiAndmVydGljYWwnLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHJpZ2h0LXNpZGUgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgYWxpZ24tcmlnaHRgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYWxpZ24tcmlnaHQnXFxuICAgKi9cXG4gIHJpZ2h0Q2xhc3M6ICdhbGlnbi1yaWdodCcsXFxuXFxuICAvKipcXG4gICAqIEJvb2xlYW4gdG8gZm9yY2Ugb3ZlcmlkZSB0aGUgY2xpY2tpbmcgb2YgbGlua3MgdG8gcGVyZm9ybSBkZWZhdWx0IGFjdGlvbiwgb24gc2Vjb25kIHRvdWNoIGV2ZW50IGZvciBtb2JpbGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgZm9yY2VGb2xsb3c6IHRydWVcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLmVxdWFsaXplci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5lcXVhbGl6ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBFcXVhbGl6ZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkVxdWFsaXplclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRXF1YWxpemVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlciAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIEVxdWFsaXplciBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmVxdWFsaXplclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIgaWYgZXF1YWxpemVyIGNvbnRhaW5zIGltYWdlc1xcbiAqL1xcblxcbnZhciBFcXVhbGl6ZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEVxdWFsaXplciwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBFcXVhbGl6ZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcXVhbGl6ZXIpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEVxdWFsaXplcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoRXF1YWxpemVyLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBFcXVhbGl6ZXJcXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIEVxdWFsaXplci5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0VxdWFsaXplcic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEVxdWFsaXplciBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgZXFJZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1lcXVhbGl6ZXInKSB8fCAnJztcXG4gICAgICB2YXIgJHdhdGNoZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWVxdWFsaXplci13YXRjaD1cXFxcXFxcIlxcXCIuY29uY2F0KGVxSWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuJHdhdGNoZWQgPSAkd2F0Y2hlZC5sZW5ndGggPyAkd2F0Y2hlZCA6IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoXScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1yZXNpemUnLCBlcUlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdlcScpKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJywgZXFJZCB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnZXEnKSk7XFxuICAgICAgdGhpcy5oYXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xcbiAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnBhcmVudHNVbnRpbChkb2N1bWVudC5ib2R5LCAnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XFxuICAgICAgdGhpcy5pc09uID0gZmFsc2U7XFxuICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB7XFxuICAgICAgICBvblJlc2l6ZU1lQm91bmQ6IHRoaXMuX29uUmVzaXplTWUuYmluZCh0aGlzKSxcXG4gICAgICAgIG9uUG9zdEVxdWFsaXplZEJvdW5kOiB0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKVxcbiAgICAgIH07XFxuICAgICAgdmFyIGltZ3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpO1xcbiAgICAgIHZhciB0b29TbWFsbDtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVxdWFsaXplT24pIHtcXG4gICAgICAgIHRvb1NtYWxsID0gdGhpcy5fY2hlY2tNUSgpO1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIHRvb1NtYWxsICE9PSAndW5kZWZpbmVkJyAmJiB0b29TbWFsbCA9PT0gZmFsc2UgfHwgdHlwZW9mIHRvb1NtYWxsID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgaWYgKGltZ3MubGVuZ3RoKSB7XFxuICAgICAgICAgIE9iamVjdChfZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIm9uSW1hZ2VzTG9hZGVkXFxcIl0pKGltZ3MsIHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX3JlZmxvdygpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgaWYgdGhlIGJyZWFrcG9pbnQgaXMgdG9vIHNtYWxsLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3BhdXNlRXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZUV2ZW50cygpIHtcXG4gICAgICB0aGlzLmlzT24gPSBmYWxzZTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZih7XFxuICAgICAgICAnLnpmLmVxdWFsaXplcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQsXFxuICAgICAgICAnbXV0YXRlbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHJlc2l6ZW1lLnpmLnRyaWdnZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfb25SZXNpemVNZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemVNZShlKSB7XFxuICAgICAgdGhpcy5fcmVmbG93KCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIGZ1bmN0aW9uIHRvIGhhbmRsZSAkZWxlbWVudHMgcG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9vblBvc3RFcXVhbGl6ZWRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUG9zdEVxdWFsaXplZChlKSB7XFxuICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLiRlbGVtZW50WzBdKSB7XFxuICAgICAgICB0aGlzLl9yZWZsb3coKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgRXF1YWxpemVyLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcXG5cXG4gICAgICBpZiAodGhpcy5oYXNOZXN0ZWQpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJywgdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmlzT24gPSB0cnVlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCB0byB0aGUgbWluaW11bSByZXF1aXJlZCBzaXplLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2NoZWNrTVFcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTVEoKSB7XFxuICAgICAgdmFyIHRvb1NtYWxsID0gIV9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uaXModGhpcy5vcHRpb25zLmVxdWFsaXplT24pO1xcblxcbiAgICAgIGlmICh0b29TbWFsbCkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNPbikge1xcbiAgICAgICAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xcblxcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKCF0aGlzLmlzT24pIHtcXG4gICAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0b29TbWFsbDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQSBub29wIHZlcnNpb24gZm9yIHRoZSBwbHVnaW5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9raWxsc3dpdGNoXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9raWxsc3dpdGNoKCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgRXF1YWxpemVyIHVwb24gRE9NIGNoYW5nZVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlZmxvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmbG93KCkge1xcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjaykge1xcbiAgICAgICAgaWYgKHRoaXMuX2lzU3RhY2tlZCgpKSB7XFxuICAgICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXF1YWxpemVCeVJvdykge1xcbiAgICAgICAgdGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE1hbnVhbGx5IGRldGVybWluZXMgaWYgdGhlIGZpcnN0IDIgZWxlbWVudHMgYXJlICpOT1QqIHN0YWNrZWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaXNTdGFja2VkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1N0YWNrZWQoKSB7XFxuICAgICAgaWYgKCF0aGlzLiR3YXRjaGVkWzBdIHx8ICF0aGlzLiR3YXRjaGVkWzFdKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuJHdhdGNoZWRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICE9PSB0aGlzLiR3YXRjaGVkWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEhlaWdodHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0cyhjYikge1xcbiAgICAgIHZhciBoZWlnaHRzID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIHRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xcbiAgICAgICAgaGVpZ2h0cy5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTtcXG4gICAgICB9XFxuXFxuICAgICAgY2IoaGVpZ2h0cyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQSBub24tb3B0aW9uYWwgY2FsbGJhY2sgdG8gcmV0dXJuIHRoZSBoZWlnaHRzIGFycmF5IHRvLlxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGdyb3VwcyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXIgZ3JvdXBlZCBieSByb3cgd2l0aCBlbGVtZW50LGhlaWdodCBhbmQgbWF4IGFzIGxhc3QgY2hpbGRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEhlaWdodHNCeVJvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHRzQnlSb3coY2IpIHtcXG4gICAgICB2YXIgbGFzdEVsVG9wT2Zmc2V0ID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGggPyB0aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wIDogMCxcXG4gICAgICAgICAgZ3JvdXBzID0gW10sXFxuICAgICAgICAgIGdyb3VwID0gMDsgLy9ncm91cCBieSBSb3dcXG5cXG4gICAgICBncm91cHNbZ3JvdXBdID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIHRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nOyAvL21heWJlIGNvdWxkIHVzZSB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldFRvcFxcblxcbiAgICAgICAgdmFyIGVsT2Zmc2V0VG9wID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMuJHdhdGNoZWRbaV0pLm9mZnNldCgpLnRvcDtcXG5cXG4gICAgICAgIGlmIChlbE9mZnNldFRvcCAhPSBsYXN0RWxUb3BPZmZzZXQpIHtcXG4gICAgICAgICAgZ3JvdXArKztcXG4gICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xcbiAgICAgICAgICBsYXN0RWxUb3BPZmZzZXQgPSBlbE9mZnNldFRvcDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChbdGhpcy4kd2F0Y2hlZFtpXSwgdGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHRdKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxuID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGxuOyBqKyspIHtcXG4gICAgICAgIHZhciBoZWlnaHRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGdyb3Vwc1tqXSkubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXNbMV07XFxuICAgICAgICB9KS5nZXQoKTtcXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcXG4gICAgICAgIGdyb3Vwc1tqXS5wdXNoKG1heCk7XFxuICAgICAgfVxcblxcbiAgICAgIGNiKGdyb3Vwcyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0XFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhlaWdodHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYXBwbHlIZWlnaHRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHQoaGVpZ2h0cykge1xcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcXG4gICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xcbiAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCBtYXgpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgaGF2ZSBiZWVuIGFwcGxpZWRcXG4gICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0IGJ5IHJvd1xcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkcm93XFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZHJvd1xcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFwcGx5SGVpZ2h0QnlSb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHRCeVJvdyhncm91cHMpIHtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3ByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICB2YXIgZ3JvdXBzSUxlbmd0aCA9IGdyb3Vwc1tpXS5sZW5ndGgsXFxuICAgICAgICAgICAgbWF4ID0gZ3JvdXBzW2ldW2dyb3Vwc0lMZW5ndGggLSAxXTtcXG5cXG4gICAgICAgIGlmIChncm91cHNJTGVuZ3RoIDw9IDIpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGdyb3Vwc1tpXVswXVswXSkuY3NzKHtcXG4gICAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXFxuICAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRyb3dcXG4gICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkogPSBncm91cHNJTGVuZ3RoIC0gMTsgaiA8IGxlbko7IGorKykge1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZ3JvdXBzW2ldW2pdWzBdKS5jc3Moe1xcbiAgICAgICAgICAgICdoZWlnaHQnOiBtYXhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIHBlciByb3cgaGF2ZSBiZWVuIGFwcGxpZWRcXG4gICAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRyb3dcXG4gICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXInKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgRXF1YWxpemVyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XFxuXFxuICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBFcXVhbGl6ZXI7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuRXF1YWxpemVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiB3aGVuIHN0YWNrZWQgb24gc21hbGxlciBzY3JlZW5zLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBlcXVhbGl6ZU9uU3RhY2s6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiByb3cgYnkgcm93LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBlcXVhbGl6ZUJ5Um93OiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBicmVha3BvaW50IHNpemUgdGhlIHBsdWdpbiBzaG91bGQgZXF1YWxpemUgaGVpZ2h0cyBvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBlcXVhbGl6ZU9uOiAnJ1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5lcXVhbGl6ZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uaW50ZXJjaGFuZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5pbnRlcmNoYW5nZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogSW50ZXJjaGFuZ2UgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkludGVyY2hhbmdlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBJbnRlcmNoYW5nZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBJbnRlcmNoYW5nZSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmludGVyY2hhbmdlXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICovXFxuXFxudmFyIEludGVyY2hhbmdlID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhJbnRlcmNoYW5nZSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBJbnRlcmNoYW5nZSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyY2hhbmdlKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihJbnRlcmNoYW5nZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoSW50ZXJjaGFuZ2UsIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEludGVyY2hhbmdlLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgSW50ZXJjaGFuZ2VcXG4gICAgICogQGZpcmVzIEludGVyY2hhbmdlI2luaXRcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgSW50ZXJjaGFuZ2UuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLnJ1bGVzID0gW107XFxuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9ICcnO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0ludGVyY2hhbmdlJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuICAgICAgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJUcmlnZ2Vyc1xcXCJdLmluaXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBJbnRlcmNoYW5nZSBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgaW50ZXJjaGFuZ2UgZnVuY3Rpb25pbmcgb24gbG9hZC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLl9pbml0KCk7XFxuXFxuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnaW50ZXJjaGFuZ2UnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXFxuICAgICAgICAnaWQnOiBpZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX3BhcnNlT3B0aW9ucygpO1xcblxcbiAgICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzKCk7XFxuXFxuICAgICAgdGhpcy5fZ2VuZXJhdGVSdWxlcygpO1xcblxcbiAgICAgIHRoaXMuX3JlZmxvdygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEludGVyY2hhbmdlLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJykub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMuX3JlZmxvdygpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBJbnRlcmNoYW5nZSB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVmbG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgdmFyIG1hdGNoOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlLCBidXQgb25seSBzYXZlIHRoZSBsYXN0IG1hdGNoXFxuXFxuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJ1bGVzKSB7XFxuICAgICAgICBpZiAodGhpcy5ydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XFxuXFxuICAgICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShydWxlLnF1ZXJ5KS5tYXRjaGVzKSB7XFxuICAgICAgICAgICAgbWF0Y2ggPSBydWxlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChtYXRjaCkge1xcbiAgICAgICAgdGhpcy5yZXBsYWNlKG1hdGNoLnBhdGgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgb3B0aW9ucyB2YWxpZml0eSBhbmQgc2V0IGRlZmF1bHRzIGZvcjpcXG4gICAgICogLSBgZGF0YS1pbnRlcmNoYW5nZS10eXBlYDogaWYgc2V0LCBlbmZvcmNlIHRoZSB0eXBlIG9mIHJlcGxhY2VtZW50IChhdXRvLCBzcmMsIGJhY2tncm91bmQgb3IgaHRtbClcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcGFyc2VPcHRpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZU9wdGlvbnMoKSB7XFxuICAgICAgdmFyIHR5cGVzID0gWydhdXRvJywgJ3NyYycsICdiYWNrZ3JvdW5kJywgJ2h0bWwnXTtcXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50eXBlID09PSAndW5kZWZpbmVkJykgdGhpcy5vcHRpb25zLnR5cGUgPSAnYXV0byc7ZWxzZSBpZiAodHlwZXMuaW5kZXhPZih0aGlzLm9wdGlvbnMudHlwZSkgPT09IC0xKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiV2FybmluZzogaW52YWxpZCB2YWx1ZSBcXFxcXFxcIlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy50eXBlLCBcXFwiXFxcXFxcXCIgZm9yIEludGVyY2hhbmdlIG9wdGlvbiBcXFxcXFxcInR5cGVcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgIHRoaXMub3B0aW9ucy50eXBlID0gJ2F1dG8nO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hZGRCcmVha3BvaW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQnJlYWtwb2ludHMoKSB7XFxuICAgICAgZm9yICh2YXIgaSBpbiBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLnF1ZXJpZXMpIHtcXG4gICAgICAgIGlmIChfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5xdWVyaWVzW2ldO1xcbiAgICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgSW50ZXJjaGFuZ2UgZWxlbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1lZGlhIHF1ZXJ5ICsgY29udGVudCBwYWlyaW5nc1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRoYXQgaXMgYW4gSW50ZXJjaGFuZ2UgaW5zdGFuY2VcXG4gICAgICogQHJldHVybnMge0FycmF5fSBzY2VuYXJpb3MgLSBBcnJheSBvZiBvYmplY3RzIHRoYXQgaGF2ZSAnbXEnIGFuZCAncGF0aCcga2V5cyB3aXRoIGNvcnJlc3BvbmRpbmcga2V5c1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dlbmVyYXRlUnVsZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlUnVsZXMoZWxlbWVudCkge1xcbiAgICAgIHZhciBydWxlc0xpc3QgPSBbXTtcXG4gICAgICB2YXIgcnVsZXM7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydWxlcykge1xcbiAgICAgICAgcnVsZXMgPSB0aGlzLm9wdGlvbnMucnVsZXM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdpbnRlcmNoYW5nZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBydWxlcyA9IHR5cGVvZiBydWxlcyA9PT0gJ3N0cmluZycgPyBydWxlcy5tYXRjaCgvXFxcXFsuKj8sIC4qP1xcXFxdL2cpIDogcnVsZXM7XFxuXFxuICAgICAgZm9yICh2YXIgaSBpbiBydWxlcykge1xcbiAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc2xpY2UoMSwgLTEpLnNwbGl0KCcsICcpO1xcbiAgICAgICAgICB2YXIgcGF0aCA9IHJ1bGUuc2xpY2UoMCwgLTEpLmpvaW4oJycpO1xcbiAgICAgICAgICB2YXIgcXVlcnkgPSBydWxlW3J1bGUubGVuZ3RoIC0gMV07XFxuXFxuICAgICAgICAgIGlmIChJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldKSB7XFxuICAgICAgICAgICAgcXVlcnkgPSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJ1bGVzTGlzdC5wdXNoKHtcXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzTGlzdDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFBhdGggdG8gdGhlIGltYWdlIG9yIEhUTUwgcGFydGlhbC5cXG4gICAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZXBsYWNlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoID09PSBwYXRoKSByZXR1cm47XFxuICAgICAgdmFyIHRyaWdnZXIgPSAncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnO1xcbiAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLnR5cGU7XFxuXFxuICAgICAgaWYgKHR5cGUgPT09ICdhdXRvJykge1xcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0ubm9kZU5hbWUgPT09ICdJTUcnKSB0eXBlID0gJ3NyYyc7ZWxzZSBpZiAocGF0aC5tYXRjaCgvXFxcXC4oZ2lmfGpwZT9nfHBuZ3xzdmd8dGlmZikoWz8jXS4qKT8vaSkpIHR5cGUgPSAnYmFja2dyb3VuZCc7ZWxzZSB0eXBlID0gJ2h0bWwnO1xcbiAgICAgIH0gLy8gUmVwbGFjaW5nIGltYWdlc1xcblxcblxcbiAgICAgIGlmICh0eXBlID09PSAnc3JjJykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdzcmMnLCBwYXRoKS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMyLmN1cnJlbnRQYXRoID0gcGF0aDtcXG4gICAgICAgIH0pLnRyaWdnZXIodHJpZ2dlcik7XFxuICAgICAgfSAvLyBSZXBsYWNpbmcgYmFja2dyb3VuZCBpbWFnZXNcXG4gICAgICBlbHNlIGlmICh0eXBlID09PSAnYmFja2dyb3VuZCcpIHtcXG4gICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXCgvZywgJyUyOCcpLnJlcGxhY2UoL1xcXFwpL2csICclMjknKTtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgcGF0aCArICcpJ1xcbiAgICAgICAgICB9KS50cmlnZ2VyKHRyaWdnZXIpO1xcbiAgICAgICAgfSAvLyBSZXBsYWNpbmcgSFRNTFxcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2h0bWwnKSB7XFxuICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmdldChwYXRoLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgICAgICAgICAgIF90aGlzMi4kZWxlbWVudC5odG1sKHJlc3BvbnNlKS50cmlnZ2VyKHRyaWdnZXIpO1xcblxcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHJlc3BvbnNlKS5mb3VuZGF0aW9uKCk7XFxuICAgICAgICAgICAgICBfdGhpczIuY3VycmVudFBhdGggPSBwYXRoO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiBjb250ZW50IGluIGFuIEludGVyY2hhbmdlIGVsZW1lbnQgaXMgZG9uZSBiZWluZyBsb2FkZWQuXFxuICAgICAgICogQGV2ZW50IEludGVyY2hhbmdlI3JlcGxhY2VkXFxuICAgICAgICovXFxuICAgICAgLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZScpO1xcblxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBpbnRlcmNoYW5nZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gSW50ZXJjaGFuZ2U7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuSW50ZXJjaGFuZ2UuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7P2FycmF5fVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBydWxlczogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogVHlwZSBvZiB0aGUgcmVzcG9uc2l2ZSByZXNzb3VyY2UgdG8gcmVwbGFjZS4gSXQgY2FuIHRha2UgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxcbiAgICogLSBgYXV0b2AgKGRlZmF1bHQpOiBjaG9vc2UgdGhlIHR5cGUgYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50IHRhZyBvciB0aGUgcmVzc291cmNlIGV4dGVuc2lvbixcXG4gICAqIC0gYHNyY2A6IHJlcGxhY2UgdGhlIGBbc3JjXWAgYXR0cmlidXRlLCByZWNvbW1lbmRlZCBmb3IgaW1hZ2VzIGA8aW1nPmAuXFxuICAgKiAtIGBiYWNrZ3JvdW5kYDogcmVwbGFjZSB0aGUgYGJhY2tncm91bmQtaW1hZ2VgIENTUyBwcm9wZXJ0eS5cXG4gICAqIC0gYGh0bWxgOiByZXBsYWNlIHRoZSBlbGVtZW50IGNvbnRlbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2F1dG8nXFxuICAgKi9cXG4gIHR5cGU6ICdhdXRvJ1xcbn07XFxuSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTID0ge1xcbiAgJ2xhbmRzY2FwZSc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXFxuICAncG9ydHJhaXQnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXFxuICAncmV0aW5hJzogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24uaW50ZXJjaGFuZ2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24ubWFnZWxsYW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5tYWdlbGxhbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogTWFnZWxsYW4gKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk1hZ2VsbGFuXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNYWdlbGxhbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3Ntb290aFNjcm9sbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnNtb290aFNjcm9sbCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnNtb290aFNjcm9sbC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBNYWdlbGxhbiBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1hZ2VsbGFuXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24uc21vb3RoU2Nyb2xsXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBNYWdlbGxhbiA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoTWFnZWxsYW4sIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gTWFnZWxsYW4oKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYWdlbGxhbik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFnZWxsYW4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE1hZ2VsbGFuLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNYWdlbGxhbi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIE1hZ2VsbGFuXFxuICAgICAqIEBmaXJlcyBNYWdlbGxhbiNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIE1hZ2VsbGFuLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnTWFnZWxsYW4nOyAvLyBpZTkgYmFjayBjb21wYXRcXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLmNhbGNQb2ludHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1hZ2VsbGFuIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBlcXVhbGl6ZXIgZnVuY3Rpb25pbmcgb24gbG9hZC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ21hZ2VsbGFuJyk7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiR0YXJnZXRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS1tYWdlbGxhbi10YXJnZXRdJyk7XFxuICAgICAgdGhpcy4kbGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXFxuICAgICAgICAnZGF0YS1zY3JvbGwnOiBpZCxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kYWN0aXZlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCk7XFxuICAgICAgdGhpcy5zY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsY3VsYXRlcyBhbiBhcnJheSBvZiBwaXhlbCB2YWx1ZXMgdGhhdCBhcmUgdGhlIGRlbWFyY2F0aW9uIGxpbmVzIGJldHdlZW4gbG9jYXRpb25zIG9uIHRoZSBwYWdlLlxcbiAgICAgKiBDYW4gYmUgaW52b2tlZCBpZiBuZXcgZWxlbWVudHMgYXJlIGFkZGVkIG9yIHRoZSBzaXplIG9mIGEgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjYWxjUG9pbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNQb2ludHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgYm9keSA9IGRvY3VtZW50LmJvZHksXFxuICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuICAgICAgdGhpcy5wb2ludHMgPSBbXTtcXG4gICAgICB0aGlzLndpbkhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCkpO1xcbiAgICAgIHRoaXMuZG9jSGVpZ2h0ID0gTWF0aC5yb3VuZChNYXRoLm1heChib2R5LnNjcm9sbEhlaWdodCwgYm9keS5vZmZzZXRIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5vZmZzZXRIZWlnaHQpKTtcXG4gICAgICB0aGlzLiR0YXJnZXRzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICR0YXIgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgcHQgPSBNYXRoLnJvdW5kKCR0YXIub2Zmc2V0KCkudG9wIC0gX3RoaXMub3B0aW9ucy50aHJlc2hvbGQpO1xcbiAgICAgICAgJHRhci50YXJnZXRQb2ludCA9IHB0O1xcblxcbiAgICAgICAgX3RoaXMucG9pbnRzLnB1c2gocHQpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIE1hZ2VsbGFuLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub25lKCdsb2FkJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcXG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgX3RoaXMuY2FsY1BvaW50cygpO1xcblxcbiAgICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xcbiAgICAgIH0pO1xcbiAgICAgIF90aGlzLm9uTG9hZExpc3RlbmVyID0gT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwib25Mb2FkXFxcIl0pKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy4kZWxlbWVudC5vbih7XFxuICAgICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogX3RoaXMucmVmbG93LmJpbmQoX3RoaXMpLFxcbiAgICAgICAgICAnc2Nyb2xsbWUuemYudHJpZ2dlcic6IF90aGlzLl91cGRhdGVBY3RpdmUuYmluZChfdGhpcylcXG4gICAgICAgIH0pLm9uKCdjbGljay56Zi5tYWdlbGxhbicsICdhW2hyZWZePVxcXCIjXFxcIl0nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHZhciBhcnJpdmFsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcXG5cXG4gICAgICAgICAgX3RoaXMuc2Nyb2xsVG9Mb2MoYXJyaXZhbCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLl9kZWVwTGlua1Njcm9sbCA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kZWVwTGlua2luZykge1xcbiAgICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyh3aW5kb3cubG9jYXRpb24uaGFzaCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbignaGFzaGNoYW5nZScsIHRoaXMuX2RlZXBMaW5rU2Nyb2xsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRnVuY3Rpb24gdG8gc2Nyb2xsIHRvIGEgZ2l2ZW4gbG9jYXRpb24gb24gdGhlIHBhZ2UuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2MgLSBhIHByb3Blcmx5IGZvcm1hdHRlZCBqUXVlcnkgaWQgc2VsZWN0b3IuIEV4YW1wbGU6ICcjZm9vJ1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNjcm9sbFRvTG9jXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFRvTG9jKGxvYykge1xcbiAgICAgIHRoaXMuX2luVHJhbnNpdGlvbiA9IHRydWU7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZyxcXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXFxuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMub3B0aW9ucy50aHJlc2hvbGQsXFxuICAgICAgICBvZmZzZXQ6IHRoaXMub3B0aW9ucy5vZmZzZXRcXG4gICAgICB9O1xcbiAgICAgIF9mb3VuZGF0aW9uX3Ntb290aFNjcm9sbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJTbW9vdGhTY3JvbGxcXFwiXS5zY3JvbGxUb0xvYyhsb2MsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLl9pblRyYW5zaXRpb24gPSBmYWxzZTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgTWFnZWxsYW4gdXBvbiBET00gY2hhbmdlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVmbG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZmxvdygpIHtcXG4gICAgICB0aGlzLmNhbGNQb2ludHMoKTtcXG5cXG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmUoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RpdmUgbG9jYXRpb24gbGluaywgYW5kIHVwZGF0ZXMgdGhlIHVybCBoYXNoIGZvciB0aGUgcGFnZSwgaWYgZGVlcExpbmtpbmcgZW5hYmxlZC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBNYWdlbGxhbiN1cGRhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl91cGRhdGVBY3RpdmVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFjdGl2ZSgpXFxuICAgIC8qZXZ0LCBlbGVtLCBzY3JvbGxQb3MqL1xcbiAgICB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuX2luVHJhbnNpdGlvbikgcmV0dXJuO1xcbiAgICAgIHZhciBuZXdTY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKTtcXG4gICAgICB2YXIgaXNTY3JvbGxpbmdVcCA9IHRoaXMuc2Nyb2xsUG9zID4gbmV3U2Nyb2xsUG9zO1xcbiAgICAgIHRoaXMuc2Nyb2xsUG9zID0gbmV3U2Nyb2xsUG9zO1xcbiAgICAgIHZhciBhY3RpdmVJZHg7IC8vIEJlZm9yZSB0aGUgZmlyc3QgcG9pbnQ6IG5vIGxpbmtcXG5cXG4gICAgICBpZiAobmV3U2Nyb2xsUG9zIDwgdGhpcy5wb2ludHNbMF0pIHt9XFxuICAgICAgLyogZG8gbm90aGluZyAqL1xcbiAgICAgIC8vIEF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2U6IGxhc3QgbGlua1xcbiAgICAgIGVsc2UgaWYgKG5ld1Njcm9sbFBvcyArIHRoaXMud2luSGVpZ2h0ID09PSB0aGlzLmRvY0hlaWdodCkge1xcbiAgICAgICAgICBhY3RpdmVJZHggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxO1xcbiAgICAgICAgfSAvLyBPdGhlcndoaXNlLCB1c2UgdGhlIGxhc3QgdmlzaWJsZSBsaW5rXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgdmlzaWJsZUxpbmtzID0gdGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwLCBpKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gcCAtIF90aGlzMi5vcHRpb25zLm9mZnNldCAtIChpc1Njcm9sbGluZ1VwID8gX3RoaXMyLm9wdGlvbnMudGhyZXNob2xkIDogMCkgPD0gbmV3U2Nyb2xsUG9zO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGFjdGl2ZUlkeCA9IHZpc2libGVMaW5rcy5sZW5ndGggPyB2aXNpYmxlTGlua3MubGVuZ3RoIC0gMSA6IDA7XFxuICAgICAgICAgIH0gLy8gR2V0IHRoZSBuZXcgYWN0aXZlIGxpbmtcXG5cXG5cXG4gICAgICB2YXIgJG9sZEFjdGl2ZSA9IHRoaXMuJGFjdGl2ZTtcXG4gICAgICB2YXIgYWN0aXZlSGFzaCA9ICcnO1xcblxcbiAgICAgIGlmICh0eXBlb2YgYWN0aXZlSWR4ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kbGlua3MuZmlsdGVyKCdbaHJlZj1cXFwiIycgKyB0aGlzLiR0YXJnZXRzLmVxKGFjdGl2ZUlkeCkuZGF0YSgnbWFnZWxsYW4tdGFyZ2V0JykgKyAnXFxcIl0nKTtcXG4gICAgICAgIGlmICh0aGlzLiRhY3RpdmUubGVuZ3RoKSBhY3RpdmVIYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRhY3RpdmUgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGlzTmV3QWN0aXZlID0gISghdGhpcy4kYWN0aXZlLmxlbmd0aCAmJiAhJG9sZEFjdGl2ZS5sZW5ndGgpICYmICF0aGlzLiRhY3RpdmUuaXMoJG9sZEFjdGl2ZSk7XFxuICAgICAgdmFyIGlzTmV3SGFzaCA9IGFjdGl2ZUhhc2ggIT09IHdpbmRvdy5sb2NhdGlvbi5oYXNoOyAvLyBVcGRhdGUgdGhlIGFjdGl2ZSBsaW5rIGVsZW1lbnRcXG5cXG4gICAgICBpZiAoaXNOZXdBY3RpdmUpIHtcXG4gICAgICAgICRvbGRBY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcXG4gICAgICAgIHRoaXMuJGFjdGl2ZS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xcbiAgICAgIH0gLy8gVXBkYXRlIHRoZSBoYXNoIChpdCBtYXkgaGF2ZSBjaGFuZ2VkIHdpdGggdGhlIHNhbWUgYWN0aXZlIGxpbmspXFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyAmJiBpc05ld0hhc2gpIHtcXG4gICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcXG4gICAgICAgICAgLy8gU2V0IG9yIHJlbW92ZSB0aGUgaGFzaCAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTI5ODY4NC80MzE3Mzg0XFxuICAgICAgICAgIHZhciB1cmwgPSBhY3RpdmVIYXNoID8gYWN0aXZlSGFzaCA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIHVybCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgdXJsKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBhY3RpdmVIYXNoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNOZXdBY3RpdmUpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiBtYWdlbGxhbiBpcyBmaW5pc2hlZCB1cGRhdGluZyB0byB0aGUgbmV3IGFjdGl2ZSBlbGVtZW50LlxcbiAgICAgICAgICogQGV2ZW50IE1hZ2VsbGFuI3VwZGF0ZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwZGF0ZS56Zi5tYWdlbGxhbicsIFt0aGlzLiRhY3RpdmVdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIE1hZ2VsbGFuIGFuZCByZXNldHMgdGhlIHVybCBvZiB0aGUgd2luZG93LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYubWFnZWxsYW4nKS5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XFxuICAgICAgICB2YXIgaGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoaGFzaCwgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9kZWVwTGlua1Njcm9sbCk7XFxuICAgICAgaWYgKHRoaXMub25Mb2FkTGlzdGVuZXIpIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIE1hZ2VsbGFuO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUGx1Z2luXFxcIl0pO1xcbi8qKlxcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxcbiAqL1xcblxcblxcbk1hZ2VsbGFuLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTAwXFxuICAgKi9cXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXFxuXFxuICAvKipcXG4gICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuIENhbiBiZSBgJ3N3aW5nJ2Agb3IgYCdsaW5lYXInYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnbGluZWFyJ1xcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpxdWVyeSBhbmltYXRlfVxcbiAgICovXFxuICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MFxcbiAgICovXFxuICB0aHJlc2hvbGQ6IDUwLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBhY3RpdmUgbG9jYXRpb25zIGxpbmsgb24gdGhlIG1hZ2VsbGFuIGNvbnRhaW5lci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnaXMtYWN0aXZlJ1xcbiAgICovXFxuICBhY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgc2NyaXB0IHRvIG1hbmlwdWxhdGUgdGhlIHVybCBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgaWYgc3VwcG9ydGVkLCBhbHRlciB0aGUgaGlzdG9yeS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGVlcExpbmtpbmc6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBVcGRhdGUgdGhlIGJyb3dzZXIgaGlzdG9yeSB3aXRoIHRoZSBhY3RpdmUgbGluaywgaWYgZGVlcCBsaW5raW5nIGlzIGVuYWJsZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHVwZGF0ZUhpc3Rvcnk6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIG9mZnNldCB0aGUgc2Nyb2xsIG9mIHRoZSBwYWdlIG9uIGl0ZW0gY2xpY2sgaWYgdXNpbmcgYSBzdGlja3kgbmF2IGJhci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIG9mZnNldDogMFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5tYWdlbGxhbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi5vZmZjYW52YXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24ub2ZmY2FudmFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogT2ZmQ2FudmFzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJPZmZDYW52YXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE9mZkNhbnZhczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLmtleWJvYXJkICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogT2ZmQ2FudmFzIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ub2ZmQ2FudmFzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKi9cXG5cXG52YXIgT2ZmQ2FudmFzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhPZmZDYW52YXMsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gT2ZmQ2FudmFzKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmQ2FudmFzKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihPZmZDYW52YXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE9mZkNhbnZhcywgW3tcXG4gICAga2V5OiBcXFwiX3NldHVwXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb2ZmLWNhbnZhcyB3cmFwcGVyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgT2ZmQ2FudmFzXFxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gaW5pdGlhbGl6ZS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnT2ZmQ2FudmFzJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgT2ZmQ2FudmFzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jb250ZW50Q2xhc3NlcyA9IHtcXG4gICAgICAgIGJhc2U6IFtdLFxcbiAgICAgICAgcmV2ZWFsOiBbXVxcbiAgICAgIH07XFxuICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoKTtcXG4gICAgICB0aGlzLiR0cmlnZ2VycyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMucG9zaXRpb24gPSAnbGVmdCc7XFxuICAgICAgdGhpcy4kY29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMubmVzdGVkID0gISF0aGlzLm9wdGlvbnMubmVzdGVkO1xcbiAgICAgIHRoaXMuJHN0aWNreSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMuaXNJbkNhbnZhcyA9IGZhbHNlOyAvLyBEZWZpbmVzIHRoZSBDU1MgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzc2VzIG9mIHRoZSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLlxcblxcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShbJ3B1c2gnLCAnb3ZlcmxhcCddKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XFxuICAgICAgICBfdGhpczIuY29udGVudENsYXNzZXMuYmFzZS5wdXNoKCdoYXMtdHJhbnNpdGlvbi0nICsgdmFsKTtcXG4gICAgICB9KTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSkuZWFjaChmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xcbiAgICAgICAgX3RoaXMyLmNvbnRlbnRDbGFzc2VzLmJhc2UucHVzaCgnaGFzLXBvc2l0aW9uLScgKyB2YWwpO1xcblxcbiAgICAgICAgX3RoaXMyLmNvbnRlbnRDbGFzc2VzLnJldmVhbC5wdXNoKCdoYXMtcmV2ZWFsLScgKyB2YWwpO1xcbiAgICAgIH0pOyAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJLZXlib2FyZFxcXCJdLnJlZ2lzdGVyKCdPZmZDYW52YXMnLCB7XFxuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGJ5IGFkZGluZyB0aGUgZXhpdCBvdmVybGF5IChpZiBuZWVkZWQpLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTsgLy8gRmluZCBvZmYtY2FudmFzIGNvbnRlbnQsIGVpdGhlciBieSBJRCAoaWYgc3BlY2lmaWVkKSwgYnkgc2libGluZ3Mgb3IgYnkgY2xvc2VzdCBzZWxlY3RvciAoZmFsbGJhY2spXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50SWQpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJyMnICsgdGhpcy5vcHRpb25zLmNvbnRlbnRJZCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmZpcnN0KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSB0aGlzLiRlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5maXJzdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb250ZW50SWQpIHtcXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBvZmYtY2FudmFzIGVsZW1lbnQgaXMgbmVzdGVkIGlmIGl0IGlzbid0IGEgc2libGluZyBvZiB0aGUgY29udGVudFxcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykubGVuZ3RoID09PSAwO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRJZCAmJiB0aGlzLm9wdGlvbnMubmVzdGVkID09PSBudWxsKSB7XFxuICAgICAgICAvLyBXYXJuaW5nIGlmIHVzaW5nIGNvbnRlbnQgSUQgd2l0aG91dCBzZXR0aW5nIHRoZSBuZXN0ZWQgb3B0aW9uXFxuICAgICAgICAvLyBPbmNlIHRoZSBlbGVtZW50IGlzIG5lc3RlZCBpdCBpcyByZXF1aXJlZCB0byB3b3JrIHByb3Blcmx5IGluIHRoaXMgY2FzZVxcbiAgICAgICAgY29uc29sZS53YXJuKCdSZW1lbWJlciB0byB1c2UgdGhlIG5lc3RlZCBvcHRpb24gaWYgdXNpbmcgdGhlIGNvbnRlbnQgSUQgb3B0aW9uIScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5uZXN0ZWQgPT09IHRydWUpIHtcXG4gICAgICAgIC8vIEZvcmNlIHRyYW5zaXRpb24gb3ZlcmxhcCBpZiBuZXN0ZWRcXG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uID0gJ292ZXJsYXAnOyAvLyBSZW1vdmUgYXBwcm9wcmlhdGUgY2xhc3NlcyBpZiBhbHJlYWR5IGFzc2lnbmVkIGluIG1hcmt1cFxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtdHJhbnNpdGlvbi1wdXNoJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLXRyYW5zaXRpb24tXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnRyYW5zaXRpb24sIFxcXCIgaXMtY2xvc2VkXFxcIikpOyAvLyBGaW5kIHRyaWdnZXJzIHRoYXQgYWZmZWN0IHRoaXMgZWxlbWVudCBhbmQgYWRkIGFyaWEtZXhwYW5kZWQgdG8gdGhlbVxcblxcbiAgICAgIHRoaXMuJHRyaWdnZXJzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJyArIGlkICsgJ1xcXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7IC8vIEdldCBwb3NpdGlvbiBieSBjaGVja2luZyBmb3IgcmVsYXRlZCBDU1MgY2xhc3NcXG5cXG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy4kZWxlbWVudC5pcygnLnBvc2l0aW9uLWxlZnQsIC5wb3NpdGlvbi10b3AsIC5wb3NpdGlvbi1yaWdodCwgLnBvc2l0aW9uLWJvdHRvbScpID8gdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLm1hdGNoKC9wb3NpdGlvblxcXFwtKGxlZnR8dG9wfHJpZ2h0fGJvdHRvbSkvKVsxXSA6IHRoaXMucG9zaXRpb247IC8vIEFkZCBhbiBvdmVybGF5IG92ZXIgdGhlIGNvbnRlbnQgaWYgbmVjZXNzYXJ5XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHZhciBvdmVybGF5UG9zaXRpb24gPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcy4kZWxlbWVudCkuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09PSAnZml4ZWQnID8gJ2lzLW92ZXJsYXktZml4ZWQnIDogJ2lzLW92ZXJsYXktYWJzb2x1dGUnO1xcbiAgICAgICAgb3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2pzLW9mZi1jYW52YXMtb3ZlcmxheSAnICsgb3ZlcmxheVBvc2l0aW9uKTtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkob3ZlcmxheSk7XFxuXFxuICAgICAgICBpZiAob3ZlcmxheVBvc2l0aW9uID09PSAnaXMtb3ZlcmxheS1maXhlZCcpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMuJG92ZXJsYXkpLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kY29udGVudC5hcHBlbmQodGhpcy4kb3ZlcmxheSk7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBHZXQgdGhlIHJldmVhbE9uIG9wdGlvbiBmcm9tIHRoZSBjbGFzcy5cXG5cXG5cXG4gICAgICB2YXIgcmV2ZWFsT25SZWdFeHAgPSBuZXcgUmVnRXhwKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlJlZ0V4cEVzY2FwZVxcXCJdKSh0aGlzLm9wdGlvbnMucmV2ZWFsQ2xhc3MpICsgJyhbXlxcXFxcXFxcc10rKScsICdnJyk7XFxuICAgICAgdmFyIHJldmVhbE9uQ2xhc3MgPSByZXZlYWxPblJlZ0V4cC5leGVjKHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lKTtcXG5cXG4gICAgICBpZiAocmV2ZWFsT25DbGFzcykge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5vcHRpb25zLnJldmVhbE9uID0gdGhpcy5vcHRpb25zLnJldmVhbE9uIHx8IHJldmVhbE9uQ2xhc3NbMV07XFxuICAgICAgfSAvLyBFbnN1cmUgdGhlIGByZXZlYWwtb24tKmAgY2xhc3MgaXMgc2V0LlxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMucmV2ZWFsT24pIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmlyc3QoKS5hZGRDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnJldmVhbENsYXNzKS5jb25jYXQodGhpcy5vcHRpb25zLnJldmVhbE9uKSk7XFxuXFxuICAgICAgICB0aGlzLl9zZXRNUUNoZWNrZXIoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpO1xcbiAgICAgIH0gLy8gRmluZCBmaXhlZCBlbGVtZW50cyB0aGF0IHNob3VsZCBzdGF5IGZpeGVkIHdoaWxlIG9mZi1jYW52YXMgaXMgb3BlbmVkXFxuXFxuXFxuICAgICAgdGhpcy4kc3RpY2t5ID0gdGhpcy4kY29udGVudC5maW5kKCdbZGF0YS1vZmYtY2FudmFzLXN0aWNreV0nKTtcXG5cXG4gICAgICBpZiAodGhpcy4kc3RpY2t5Lmxlbmd0aCA+IDAgJiYgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gPT09ICdwdXNoJykge1xcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgbWF0Y2ggZm9yY2UgY29udGVudFNjcm9sbDpmYWxzZSBiZWNhdXNlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgZG9lc24ndCBnZXQgcmVjYWxjdWxhdGVkIG9uIHNjcm9sbFxcbiAgICAgICAgLy8gTGltaXQgdG8gcHVzaCB0cmFuc2l0aW9uIHNpbmNlIHRoZXJlJ3Mgbm8gdHJhbnNmb3JtIHNjb3BlIGZvciBvdmVybGFwXFxuICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudFNjcm9sbCA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaW5DYW52YXNGb3IgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL1xcXFxiaW4tY2FudmFzLWZvci0oXFxcXHcrKS8pO1xcblxcbiAgICAgIGlmIChpbkNhbnZhc0ZvciAmJiBpbkNhbnZhc0Zvci5sZW5ndGggPT09IDIpIHtcXG4gICAgICAgIC8vIFNldCBgaW5DYW52YXNPbmAgb3B0aW9uIGlmIGZvdW5kIGluLWNhbnZhcy1mb3ItW0JSRUFLUE9OVF0gQ1NTIGNsYXNzXFxuICAgICAgICB0aGlzLm9wdGlvbnMuaW5DYW52YXNPbiA9IGluQ2FudmFzRm9yWzFdO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmluQ2FudmFzT24pIHtcXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgQ1NTIGNsYXNzIGlzIHNldFxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaW4tY2FudmFzLWZvci1cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuaW5DYW52YXNPbikpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmluQ2FudmFzT24pIHtcXG4gICAgICAgIHRoaXMuX2NoZWNrSW5DYW52YXMoKTtcXG4gICAgICB9IC8vIEluaXRhbGx5IHJlbW92ZSBhbGwgdHJhbnNpdGlvbi9wb3NpdGlvbiBDU1MgY2xhc3NlcyBmcm9tIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIuXFxuXFxuXFxuICAgICAgdGhpcy5fcmVtb3ZlQ29udGVudENsYXNzZXMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGFuZCB0aGUgZXhpdCBvdmVybGF5LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZkNhbnZhcycpLm9uKHtcXG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICdrZXlkb3duLnpmLm9mZkNhbnZhcyc6IHRoaXMuX2hhbmRsZUtleWJvYXJkLmJpbmQodGhpcylcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyICR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPyB0aGlzLiRvdmVybGF5IDogdGhpcy4kY29udGVudDtcXG4gICAgICAgICR0YXJnZXQub24oe1xcbiAgICAgICAgICAnY2xpY2suemYub2ZmQ2FudmFzJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbkNhbnZhc09uKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpczMuX2NoZWNrSW5DYW52YXMoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQXBwbGllcyBldmVudCBsaXN0ZW5lciBmb3IgZWxlbWVudHMgdGhhdCB3aWxsIHJldmVhbCBhdCBjZXJ0YWluIGJyZWFrcG9pbnRzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldE1RQ2hlY2tlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TVFDaGVja2VyKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5vbkxvYWRMaXN0ZW5lciA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIm9uTG9hZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xcbiAgICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcXG4gICAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX3RoaXMucmV2ZWFsKGZhbHNlKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGlmIEluQ2FudmFzIG9uIGN1cnJlbnQgYnJlYWtwb2ludCBhbmQgYWRqdXN0IG9mZi1jYW52YXMgYWNjb3JkaW5nbHlcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9jaGVja0luQ2FudmFzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0luQ2FudmFzKCkge1xcbiAgICAgIHRoaXMuaXNJbkNhbnZhcyA9IF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uYXRMZWFzdCh0aGlzLm9wdGlvbnMuaW5DYW52YXNPbik7XFxuXFxuICAgICAgaWYgKHRoaXMuaXNJbkNhbnZhcyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyB0aGUgQ1NTIHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3NlcyBvZiB0aGUgb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lci5cXG4gICAgICogUmVtb3ZpbmcgdGhlIGNsYXNzZXMgaXMgaW1wb3J0YW50IHdoZW4gYW5vdGhlciBvZmYtY2FudmFzIGdldHMgb3BlbmVkIHRoYXQgdXNlcyB0aGUgc2FtZSBjb250ZW50IGNvbnRhaW5lci5cXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNSZXZlYWwgLSB0cnVlIGlmIHJlbGF0ZWQgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIHJldmVhbGVkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlbW92ZUNvbnRlbnRDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVDb250ZW50Q2xhc3NlcyhoYXNSZXZlYWwpIHtcXG4gICAgICBpZiAodHlwZW9mIGhhc1JldmVhbCAhPT0gJ2Jvb2xlYW4nKSB7XFxuICAgICAgICB0aGlzLiRjb250ZW50LnJlbW92ZUNsYXNzKHRoaXMuY29udGVudENsYXNzZXMuYmFzZS5qb2luKCcgJykpO1xcbiAgICAgIH0gZWxzZSBpZiAoaGFzUmV2ZWFsID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcyhcXFwiaGFzLXJldmVhbC1cXFwiLmNvbmNhdCh0aGlzLnBvc2l0aW9uKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIHRoZSBDU1MgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzc2VzIG9mIHRoZSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLCBiYXNlZCBvbiB0aGUgb3BlbmluZyBvZmYtY2FudmFzIGVsZW1lbnQuXFxuICAgICAqIEJlZm9yZWhhbmQgYW55IHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3MgZ2V0cyByZW1vdmVkLlxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc1JldmVhbCAtIHRydWUgaWYgcmVsYXRlZCBvZmYtY2FudmFzIGVsZW1lbnQgaXMgcmV2ZWFsZWQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRkQ29udGVudENsYXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENvbnRlbnRDbGFzc2VzKGhhc1JldmVhbCkge1xcbiAgICAgIHRoaXMuX3JlbW92ZUNvbnRlbnRDbGFzc2VzKGhhc1JldmVhbCk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBoYXNSZXZlYWwgIT09ICdib29sZWFuJykge1xcbiAgICAgICAgdGhpcy4kY29udGVudC5hZGRDbGFzcyhcXFwiaGFzLXRyYW5zaXRpb24tXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnRyYW5zaXRpb24sIFxcXCIgaGFzLXBvc2l0aW9uLVxcXCIpLmNvbmNhdCh0aGlzLnBvc2l0aW9uKSk7XFxuICAgICAgfSBlbHNlIGlmIChoYXNSZXZlYWwgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoXFxcImhhcy1yZXZlYWwtXFxcIi5jb25jYXQodGhpcy5wb3NpdGlvbikpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUHJlc2VydmVzIHRoZSBmaXhlZCBiZWhhdmlvciBvZiBzdGlja3kgZWxlbWVudHMgb24gb3BlbmluZyBhbiBvZmYtY2FudmFzIHdpdGggcHVzaCB0cmFuc2l0aW9uLlxcbiAgICAgKiBTaW5jZSB0aGUgb2ZmLWNhbnZhcyBjb250YWluZXIgaGFzIGdvdCBhIHRyYW5zZm9ybSBzY29wZSBpbiBzdWNoIGEgY2FzZSwgaXQgaXMgZG9uZSBieSBjYWxjdWxhdGluZyBwb3NpdGlvbiBhYnNvbHV0ZSB2YWx1ZXMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZml4U3RpY2t5RWxlbWVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeFN0aWNreUVsZW1lbnRzKCkge1xcbiAgICAgIHRoaXMuJHN0aWNreS5lYWNoKGZ1bmN0aW9uIChfLCBlbCkge1xcbiAgICAgICAgdmFyICRlbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbCk7IC8vIElmIHN0aWNreSBlbGVtZW50IGlzIGN1cnJlbnRseSBmaXhlZCwgYWRqdXN0IGl0cyB0b3AgdmFsdWUgdG8gbWF0Y2ggYWJzb2x1dGUgcG9zaXRpb24gZHVlIHRvIHRyYW5zZm9ybSBzY29wZVxcbiAgICAgICAgLy8gTGltaXQgdG8gcHVzaCB0cmFuc2l0aW9uIGJlY2F1c2UgcG9zdGlvbjpmaXhlZCB3b3JrcyB3aXRob3V0IHByb2JsZW1zIGZvciBvdmVybGFwIChubyB0cmFuc2Zvcm0gc2NvcGUpXFxuXFxuICAgICAgICBpZiAoJGVsLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xcbiAgICAgICAgICAvLyBTYXZlIGN1cnJlbnQgaW5saW5lIHN0eWxpbmcgdG8gcmVzdG9yZSBpdCBpZiB1bmRvaW5nIHRoZSBhYnNvbHV0ZSBmaXhpbmdcXG4gICAgICAgICAgdmFyIHRvcFZhbCA9IHBhcnNlSW50KCRlbC5jc3MoJ3RvcCcpLCAxMCk7XFxuICAgICAgICAgICRlbC5kYXRhKCdvZmZDYW52YXNTdGlja3knLCB7XFxuICAgICAgICAgICAgdG9wOiB0b3BWYWxcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHZhciBhYnNvbHV0ZVRvcFZhbCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyB0b3BWYWw7XFxuICAgICAgICAgICRlbC5jc3Moe1xcbiAgICAgICAgICAgIHRvcDogXFxcIlxcXCIuY29uY2F0KGFic29sdXRlVG9wVmFsLCBcXFwicHhcXFwiKSxcXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGZpeGVkIHN0eWxpbmcgb2Ygc3RpY2t5IGVsZW1lbnRzIGFmdGVyIGhhdmluZyBjbG9zZWQgYW4gb2ZmLWNhbnZhcyB0aGF0IGdvdCBwc2V1ZG8gZml4ZWQgYmVmb3JlaGFuZC5cXG4gICAgICogVGhpcyByZXZlcnRzIHRoZSBjaGFuZ2VzIG9mIF9maXhTdGlja3lFbGVtZW50cygpXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfdW5maXhTdGlja3lFbGVtZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5maXhTdGlja3lFbGVtZW50cygpIHtcXG4gICAgICB0aGlzLiRzdGlja3kuZWFjaChmdW5jdGlvbiAoXywgZWwpIHtcXG4gICAgICAgIHZhciAkZWwgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZWwpO1xcbiAgICAgICAgdmFyIHN0aWNreURhdGEgPSAkZWwuZGF0YSgnb2ZmQ2FudmFzU3RpY2t5Jyk7IC8vIElmIHN0aWNreSBlbGVtZW50IGhhcyBnb3QgZGF0YSBvYmplY3Qgd2l0aCBwcmlvciB2YWx1ZXMgKG1lYW5pbmcgaXQgd2FzIG9yaWdpbmFsbHkgZml4ZWQpIHJlc3RvcmUgdGhlc2UgdmFsdWVzIG9uY2Ugb2ZmLWNhbnZhcyBpcyBjbG9zZWRcXG5cXG4gICAgICAgIGlmIChfdHlwZW9mKHN0aWNreURhdGEpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAkZWwuY3NzKHtcXG4gICAgICAgICAgICB0b3A6IFxcXCJcXFwiLmNvbmNhdChzdGlja3lEYXRhLnRvcCwgXFxcInB4XFxcIiksXFxuICAgICAgICAgICAgd2lkdGg6ICcnLFxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICcnXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAkZWwuZGF0YSgnb2ZmQ2FudmFzU3RpY2t5JywgJycpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGVzIHRoZSByZXZlYWxpbmcvaGlkaW5nIHRoZSBvZmYtY2FudmFzIGF0IGJyZWFrcG9pbnRzLCBub3QgdGhlIHNhbWUgYXMgb3Blbi5cXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1JldmVhbGVkIC0gdHJ1ZSBpZiBlbGVtZW50IHNob3VsZCBiZSByZXZlYWxlZC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZXZlYWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZWFsKGlzUmV2ZWFsZWQpIHtcXG4gICAgICBpZiAoaXNSZXZlYWxlZCkge1xcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXInKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLWNsb3NlZCcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmlzUmV2ZWFsZWQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ29wZW4uemYudHJpZ2dlciB0b2dnbGUuemYudHJpZ2dlcicpLm9uKHtcXG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWNsb3NlZCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9hZGRDb250ZW50Q2xhc3Nlcyhpc1JldmVhbGVkKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU3RvcHMgc2Nyb2xsaW5nIG9mIHRoZSBib2R5IHdoZW4gT2ZmQ2FudmFzIGlzIG9wZW4gb24gbW9iaWxlIFNhZmFyaSBhbmQgb3RoZXIgdHJvdWJsZXNvbWUgYnJvd3NlcnMuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3N0b3BTY3JvbGxpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BTY3JvbGxpbmcoZXZlbnQpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRhZyB0aGUgZWxlbWVudCBnaXZlbiBhcyBjb250ZXh0IHdoZXRoZXIgaXQgY2FuIGJlIHNjcm9sbGVkIHVwIGFuZCBkb3duLlxcbiAgICAgKiBVc2VkIHRvIGFsbG93IG9yIHByZXZlbnQgaXQgdG8gc2Nyb2xsLiBTZWUgYF9zdG9wU2Nyb2xsUHJvcGFnYXRpb25gLlxcbiAgICAgKlxcbiAgICAgKiBUYWtlbiBhbmQgYWRhcHRlZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY4ODk0NDcvcHJldmVudC1mdWxsLXBhZ2Utc2Nyb2xsaW5nLWlvc1xcbiAgICAgKiBPbmx5IHJlYWxseSB3b3JrcyBmb3IgeSwgbm90IHN1cmUgaG93IHRvIGV4dGVuZCB0byB4IG9yIGlmIHdlIG5lZWQgdG8uXFxuICAgICAqXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlY29yZFNjcm9sbGFibGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlY29yZFNjcm9sbGFibGUoZXZlbnQpIHtcXG4gICAgICB2YXIgZWxlbSA9IHRoaXM7IC8vIGNhbGxlZCBmcm9tIGV2ZW50IGhhbmRsZXIgY29udGV4dCB3aXRoIHRoaXMgYXMgZWxlbVxcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIHNjcm9sbGFibGUgKGNvbnRlbnQgb3ZlcmZsb3dzKSwgdGhlbi4uLlxcblxcbiAgICAgIGlmIChlbGVtLnNjcm9sbEhlaWdodCAhPT0gZWxlbS5jbGllbnRIZWlnaHQpIHtcXG4gICAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSB0b3AsIHNjcm9sbCBkb3duIG9uZSBwaXhlbCB0byBhbGxvdyBzY3JvbGxpbmcgdXBcXG4gICAgICAgIGlmIChlbGVtLnNjcm9sbFRvcCA9PT0gMCkge1xcbiAgICAgICAgICBlbGVtLnNjcm9sbFRvcCA9IDE7XFxuICAgICAgICB9IC8vIElmIHdlJ3JlIGF0IHRoZSBib3R0b20sIHNjcm9sbCB1cCBvbmUgcGl4ZWwgdG8gYWxsb3cgc2Nyb2xsaW5nIGRvd25cXG5cXG5cXG4gICAgICAgIGlmIChlbGVtLnNjcm9sbFRvcCA9PT0gZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodCkge1xcbiAgICAgICAgICBlbGVtLnNjcm9sbFRvcCA9IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5jbGllbnRIZWlnaHQgLSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBlbGVtLmFsbG93VXAgPSBlbGVtLnNjcm9sbFRvcCA+IDA7XFxuICAgICAgZWxlbS5hbGxvd0Rvd24gPSBlbGVtLnNjcm9sbFRvcCA8IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5jbGllbnRIZWlnaHQ7XFxuICAgICAgZWxlbS5sYXN0WSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQucGFnZVk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFByZXZlbnQgdGhlIGdpdmVuIGV2ZW50IHByb3BhZ2F0aW9uIGlmIHRoZSBlbGVtZW50IGdpdmVuIGFzIGNvbnRleHQgY2FuIHNjcm9sbC5cXG4gICAgICogVXNlZCB0byBwcmVzZXJ2ZSB0aGUgZWxlbWVudCBzY3JvbGxpbmcgb24gbW9iaWxlIChgdG91Y2htb3ZlYCkgd2hlbiB0aGUgZG9jdW1lbnRcXG4gICAgICogc2Nyb2xsaW5nIGlzIHByZXZlbnRlZC4gU2VlIGh0dHBzOi8vZ2l0LmlvL3pmLTk3MDcuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3N0b3BTY3JvbGxQcm9wYWdhdGlvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcFNjcm9sbFByb3BhZ2F0aW9uKGV2ZW50KSB7XFxuICAgICAgdmFyIGVsZW0gPSB0aGlzOyAvLyBjYWxsZWQgZnJvbSBldmVudCBoYW5kbGVyIGNvbnRleHQgd2l0aCB0aGlzIGFzIGVsZW1cXG5cXG4gICAgICB2YXIgcGFyZW50OyAvLyBvZmYtY2FudmFzIGVsZW0gaWYgY2FsbGVkIGZyb20gaW5uZXIgc2Nyb2xsYm94XFxuXFxuICAgICAgdmFyIHVwID0gZXZlbnQucGFnZVkgPCBlbGVtLmxhc3RZO1xcbiAgICAgIHZhciBkb3duID0gIXVwO1xcbiAgICAgIGVsZW0ubGFzdFkgPSBldmVudC5wYWdlWTtcXG5cXG4gICAgICBpZiAodXAgJiYgZWxlbS5hbGxvd1VwIHx8IGRvd24gJiYgZWxlbS5hbGxvd0Rvd24pIHtcXG4gICAgICAgIC8vIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uICh0aGUgdXNlciBjYW5ub3Qgd2F0Y2ggaXQpLFxcbiAgICAgICAgLy8gYnV0IGluIHRoaXMgY2FzZSB0aGlzIGlzIHRoZSBvbmx5IHNvbHV0aW9uIHdlIGhhdmUuXFxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gSWYgZWxlbSBpcyBpbm5lciBzY3JvbGxib3ggd2UgYXJlIHNjcm9sbGluZyB0aGUgb3V0ZXIgb2ZmLWNhbnZhcyBkb3duL3VwIG9uY2UgdGhlIGJveCBlbmQgaGFzIGJlZW4gcmVhY2hlZFxcbiAgICAgICAgLy8gVGhpcyBsZXRzIHRoZSB1c2VyIGNvbnRpbnVlIHRvIHRvdWNoIG1vdmUgdGhlIG9mZi1jYW52YXMgd2l0aG91dCB0aGUgbmVlZCB0byBwbGFjZSB0aGUgZmluZ2VyIG91dHNpZGUgdGhlIHNjcm9sbGJveFxcblxcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKCdkYXRhLW9mZi1jYW52YXMtc2Nyb2xsYm94JykpIHtcXG4gICAgICAgICAgcGFyZW50ID0gZWxlbS5jbG9zZXN0KCdbZGF0YS1vZmYtY2FudmFzXSwgW2RhdGEtb2ZmLWNhbnZhcy1zY3JvbGxib3gtb3V0ZXJdJyk7XFxuXFxuICAgICAgICAgIGlmIChlbGVtLnNjcm9sbFRvcCA8PSAxICYmIHBhcmVudC5zY3JvbGxUb3AgPiAwKSB7XFxuICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcC0tO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uc2Nyb2xsVG9wID49IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5jbGllbnRIZWlnaHQgLSAxICYmIHBhcmVudC5zY3JvbGxUb3AgPCBwYXJlbnQuc2Nyb2xsSGVpZ2h0IC0gcGFyZW50LmNsaWVudEhlaWdodCkge1xcbiAgICAgICAgICAgIHBhcmVudC5zY3JvbGxUb3ArKztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgdGhlIG9mZi1jYW52YXMgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHRyaWdnZXIgLSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBvZmYtY2FudmFzIHRvIG9wZW4uXFxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjb3BlbmVkXFxuICAgICAqIEB0b2RvIGFsc28gdHJpZ2dlciAnb3BlbicgZXZlbnQ/XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJvcGVuXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oZXZlbnQsIHRyaWdnZXIpIHtcXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCB8fCB0aGlzLmlzSW5DYW52YXMpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBpZiAodHJpZ2dlcikge1xcbiAgICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICd0b3AnKSB7XFxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VUbyA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUgJiYgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gIT09ICdvdmVybGFwJykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmNzcygndHJhbnNpdGlvbi1kdXJhdGlvbicsIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCAnJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5yZW1vdmVDbGFzcygnaXMtY2xvc2VkJyk7XFxuICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xcbiAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoJ2lzLW9wZW4tJyArIHRoaXMucG9zaXRpb24pOyAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCBhZGQgY2xhc3MgYW5kIGRpc2FibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50U2Nyb2xsID09PSBmYWxzZSkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdib2R5JykuYWRkQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbicpLm9uKCd0b3VjaG1vdmUnLCB0aGlzLl9zdG9wU2Nyb2xsaW5nKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNoc3RhcnQnLCB0aGlzLl9yZWNvcmRTY3JvbGxhYmxlKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNobW92ZScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCd0b3VjaHN0YXJ0JywgJ1tkYXRhLW9mZi1jYW52YXMtc2Nyb2xsYm94XScsIHRoaXMuX3JlY29yZFNjcm9sbGFibGUpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndG91Y2htb3ZlJywgJ1tkYXRhLW9mZi1jYW52YXMtc2Nyb2xsYm94XScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpcy1jbG9zYWJsZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbmUoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwidHJhbnNpdGlvbmVuZFxcXCJdKSh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcXG4gICAgICAgICAgICByZXR1cm47IC8vIGV4aXQgaWYgcHJlbWF0dXJlbHkgY2xvc2VkXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIGNhbnZhc0ZvY3VzID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYXV0b2ZvY3VzXScpO1xcblxcbiAgICAgICAgICBpZiAoY2FudmFzRm9jdXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgY2FudmFzRm9jdXMuZXEoMCkuZm9jdXMoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5maW5kKCdhLCBidXR0b24nKS5lcSgwKS5mb2N1cygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiA9PT0gJ3B1c2gnKSB7XFxuICAgICAgICB0aGlzLl9maXhTdGlja3lFbGVtZW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9hZGRDb250ZW50Q2xhc3NlcygpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cXG4gICAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI29wZW5lZFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3BlbmVkLnpmLm9mZkNhbnZhcycpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVuIHRyYW5zaXRpb24gaXMgZG9uZS5cXG4gICAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI29wZW5lZEVuZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub25lKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInRyYW5zaXRpb25lbmRcXFwiXSkodGhpcy4kZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzNC4kZWxlbWVudC50cmlnZ2VyKCdvcGVuZWRFbmQuemYub2ZmQ2FudmFzJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYiB0byBmaXJlIGFmdGVyIGNsb3N1cmUuXFxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VcXG4gICAgICogQGZpcmVzIE9mZkNhbnZhcyNjbG9zZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNsb3NlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKGNiKSB7XFxuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgfHwgdGhpcy5pc1JldmVhbGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBjbG9zZXMuXFxuICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNjbG9zZVxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2UuemYub2ZmQ2FudmFzJyk7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XFxuICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcygnaXMtb3Blbi1sZWZ0IGlzLW9wZW4tdG9wIGlzLW9wZW4tcmlnaHQgaXMtb3Blbi1ib3R0b20nKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcygnaXMtY2xvc2FibGUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpOyAvLyBMaXN0ZW4gdG8gdHJhbnNpdGlvbkVuZDogYWRkIGNsYXNzLCByZS1lbmFibGUgc2Nyb2xsaW5nIGFuZCByZWxlYXNlIGZvY3VzIHdoZW4gZG9uZS5cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZShPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJ0cmFuc2l0aW9uZW5kXFxcIl0pKHRoaXMuJGVsZW1lbnQpLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgX3RoaXM1LiRlbGVtZW50LmFkZENsYXNzKCdpcy1jbG9zZWQnKTtcXG5cXG4gICAgICAgIF90aGlzNS5fcmVtb3ZlQ29udGVudENsYXNzZXMoKTtcXG5cXG4gICAgICAgIGlmIChfdGhpczUub3B0aW9ucy50cmFuc2l0aW9uID09PSAncHVzaCcpIHtcXG4gICAgICAgICAgX3RoaXM1Ll91bmZpeFN0aWNreUVsZW1lbnRzKCk7XFxuICAgICAgICB9IC8vIElmIGBjb250ZW50U2Nyb2xsYCBpcyBzZXQgdG8gZmFsc2UsIHJlbW92ZSBjbGFzcyBhbmQgcmUtZW5hYmxlIHNjcm9sbGluZyBvbiB0b3VjaCBkZXZpY2VzLlxcblxcblxcbiAgICAgICAgaWYgKF90aGlzNS5vcHRpb25zLmNvbnRlbnRTY3JvbGwgPT09IGZhbHNlKSB7XFxuICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnYm9keScpLnJlbW92ZUNsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4nKS5vZmYoJ3RvdWNobW92ZScsIF90aGlzNS5fc3RvcFNjcm9sbGluZyk7XFxuXFxuICAgICAgICAgIF90aGlzNS4kZWxlbWVudC5vZmYoJ3RvdWNoc3RhcnQnLCBfdGhpczUuX3JlY29yZFNjcm9sbGFibGUpO1xcblxcbiAgICAgICAgICBfdGhpczUuJGVsZW1lbnQub2ZmKCd0b3VjaG1vdmUnLCBfdGhpczUuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XFxuXFxuICAgICAgICAgIF90aGlzNS4kZWxlbWVudC5vZmYoJ3RvdWNoc3RhcnQnLCAnW2RhdGEtb2ZmLWNhbnZhcy1zY3JvbGxib3hdJywgX3RoaXM1Ll9yZWNvcmRTY3JvbGxhYmxlKTtcXG5cXG4gICAgICAgICAgX3RoaXM1LiRlbGVtZW50Lm9mZigndG91Y2htb3ZlJywgJ1tkYXRhLW9mZi1jYW52YXMtc2Nyb2xsYm94XScsIF90aGlzNS5fc3RvcFNjcm9sbFByb3BhZ2F0aW9uKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChfdGhpczUub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgICAgX3RoaXM1LiRjb250ZW50LnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XFxuXFxuICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWxlYXNlRm9jdXMoX3RoaXM1LiRlbGVtZW50KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlIHRyYW5zaXRpb24gaXMgZG9uZS5cXG4gICAgICAgICAqIEBldmVudCBPZmZDYW52YXMjY2xvc2VkXFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIF90aGlzNS4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYub2ZmQ2FudmFzJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIG9mZi1jYW52YXMgbWVudSBvcGVuIG9yIGNsb3NlZC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHRyaWdnZXIgLSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBvZmYtY2FudmFzIHRvIG9wZW4uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKGV2ZW50LCB0cmlnZ2VyKSB7XFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xcbiAgICAgICAgdGhpcy5jbG9zZShldmVudCwgdHJpZ2dlcik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMub3BlbihldmVudCwgdHJpZ2dlcik7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGVzIGtleWJvYXJkIGlucHV0IHdoZW4gZGV0ZWN0ZWQuIFdoZW4gdGhlIGVzY2FwZSBrZXkgaXMgcHJlc3NlZCwgdGhlIG9mZi1jYW52YXMgbWVudSBjbG9zZXMsIGFuZCBmb2N1cyBpcyByZXN0b3JlZCB0byB0aGUgZWxlbWVudCB0aGF0IG9wZW5lZCB0aGUgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaGFuZGxlS2V5Ym9hcmRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtleWJvYXJkKGUpIHtcXG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0uaGFuZGxlS2V5KGUsICdPZmZDYW52YXMnLCB7XFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgIF90aGlzNi5jbG9zZSgpO1xcblxcbiAgICAgICAgICBfdGhpczYuJGxhc3RUcmlnZ2VyLmZvY3VzKCk7XFxuXFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIE9mZkNhbnZhcyBwbHVnaW4uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYub2ZmQ2FudmFzJyk7XFxuICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5vZmZDYW52YXMnKTtcXG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gT2ZmQ2FudmFzO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcbk9mZkNhbnZhcy5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudSB0byBjbG9zZSBpdC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFkZHMgYW4gb3ZlcmxheSBvbiB0b3Agb2YgYFtkYXRhLW9mZi1jYW52YXMtY29udGVudF1gLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNvbnRlbnRPdmVybGF5OiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBUYXJnZXQgYW4gb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lciBieSBJRCB0aGF0IG1heSBiZSBwbGFjZWQgYW55d2hlcmUuIElmIG51bGwgdGhlIGNsb3Nlc3QgY29udGVudCBjb250YWluZXIgd2lsbCBiZSB0YWtlbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBjb250ZW50SWQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIERlZmluZSB0aGUgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIG5lc3RlZCBpbiBhbiBvZmYtY2FudmFzIGNvbnRlbnQuIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyB0aGUgY29udGVudElkIG9wdGlvbiBmb3IgYSBuZXN0ZWQgZWxlbWVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBuZXN0ZWQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEVuYWJsZS9kaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgbWFpbiBjb250ZW50IHdoZW4gYW4gb2ZmIGNhbnZhcyBwYW5lbCBpcyBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNvbnRlbnRTY3JvbGw6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRoZSBvcGVuIGFuZCBjbG9zZSB0cmFuc2l0aW9uIHJlcXVpcmVzLCBpbmNsdWRpbmcgdGhlIGFwcHJvcHJpYXRlIG1pbGxpc2Vjb25kcyAoYG1zYCkgb3Igc2Vjb25kcyAoYHNgKSB1bml0IChlLmcuIGA1MDBtc2AsIGAuNzVzYCkgSWYgbm9uZSBzZWxlY3RlZCwgcHVsbHMgZnJvbSBib2R5IHN0eWxlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IG51bGxcXG4gICAqL1xcbiAgdHJhbnNpdGlvblRpbWU6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIFR5cGUgb2YgdHJhbnNpdGlvbiBmb3IgdGhlIE9mZkNhbnZhcyBtZW51LiBPcHRpb25zIGFyZSAncHVzaCcsICdkZXRhY2hlZCcgb3IgJ3NsaWRlJy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCBwdXNoXFxuICAgKi9cXG4gIHRyYW5zaXRpb246ICdwdXNoJyxcXG5cXG4gIC8qKlxcbiAgICogRm9yY2UgdGhlIHBhZ2UgdG8gc2Nyb2xsIHRvIHRvcCBvciBib3R0b20gb24gb3Blbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBmb3JjZVRvOiBudWxsLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgT2ZmQ2FudmFzIHRvIHJlbWFpbiBvcGVuIGZvciBjZXJ0YWluIGJyZWFrcG9pbnRzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBpc1JldmVhbGVkOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQnJlYWtwb2ludCBhdCB3aGljaCB0byByZXZlYWwuIEpTIHdpbGwgdXNlIGEgUmVnRXhwIHRvIHRhcmdldCBzdGFuZGFyZCBjbGFzc2VzLCBpZiBjaGFuZ2luZyBjbGFzc25hbWVzLCBwYXNzIHlvdXIgY2xhc3Mgd2l0aCB0aGUgYHJldmVhbENsYXNzYCBvcHRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7P3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IG51bGxcXG4gICAqL1xcbiAgcmV2ZWFsT246IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEJyZWFrcG9pbnQgYXQgd2hpY2ggdGhlIG9mZi1jYW52YXMgZ2V0cyBtb3ZlZCBpbnRvIGNhbnZhcyBjb250ZW50IGFuZCBhY3RzIGFzIHJlZ3VsYXIgcGFnZSBlbGVtZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUgez9zdHJpbmd9XFxuICAgKiBAZGVmYXVsdCBudWxsXFxuICAgKi9cXG4gIGluQ2FudmFzT246IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEZvcmNlIGZvY3VzIHRvIHRoZSBvZmZjYW52YXMgb24gb3Blbi4gSWYgdHJ1ZSwgd2lsbCBmb2N1cyB0aGUgb3BlbmluZyB0cmlnZ2VyIG9uIGNsb3NlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGF1dG9Gb2N1czogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgdXNlZCB0byBmb3JjZSBhbiBPZmZDYW52YXMgdG8gcmVtYWluIG9wZW4uIEZvdW5kYXRpb24gZGVmYXVsdHMgZm9yIHRoaXMgYXJlIGByZXZlYWwtZm9yLWxhcmdlYCAmIGByZXZlYWwtZm9yLW1lZGl1bWAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgcmV2ZWFsLWZvci1cXG4gICAqIEB0b2RvIGltcHJvdmUgdGhlIHJlZ2V4IHRlc3RpbmcgZm9yIHRoaXMuXFxuICAgKi9cXG4gIHJldmVhbENsYXNzOiAncmV2ZWFsLWZvci0nLFxcblxcbiAgLyoqXFxuICAgKiBUcmlnZ2VycyBvcHRpb25hbCBmb2N1cyB0cmFwcGluZyB3aGVuIG9wZW5pbmcgYW4gT2ZmQ2FudmFzLiBTZXRzIHRhYmluZGV4IG9mIFtkYXRhLW9mZi1jYW52YXMtY29udGVudF0gdG8gLTEgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHRyYXBGb2N1czogZmFsc2VcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24ub2ZmY2FudmFzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLm9yYml0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24ub3JiaXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IE9yYml0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJPcmJpdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT3JiaXQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24gKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RpbWVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50aW1lciAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudGltZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudG91Y2ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogT3JiaXQgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5vcmJpdFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxcbiAqL1xcblxcbnZhciBPcmJpdCA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoT3JiaXQsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gT3JiaXQoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcmJpdCk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoT3JiaXQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE9yYml0LCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9yYml0IGNhcm91c2VsLlxcbiAgICAqIEBjbGFzc1xcbiAgICAqIEBuYW1lIE9yYml0XFxuICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBPcmJpdCBDYXJvdXNlbC5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIE9yYml0LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnT3JiaXQnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcIlRvdWNoXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyAvLyBUb3VjaCBpbml0IGlzIGlkZW1wb3RlbnQsIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBpbml0aWFsaWVkLlxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0ucmVnaXN0ZXIoJ09yYml0Jywge1xcbiAgICAgICAgJ2x0cic6IHtcXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cydcXG4gICAgICAgIH0sXFxuICAgICAgICAncnRsJzoge1xcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICduZXh0JyxcXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ3ByZXZpb3VzJ1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zLCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGFuZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIC8vIEBUT0RPOiBjb25zaWRlciBkaXNjdXNzaW9uIG9uIFBSICM5Mjc4IGFib3V0IERPTSBwb2xsdXRpb24gYnkgY2hhbmdlU2xpZGVcXG4gICAgICB0aGlzLl9yZXNldCgpO1xcblxcbiAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpKTtcXG4gICAgICB0aGlzLiRzbGlkZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpO1xcbiAgICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKSxcXG4gICAgICAgICAgaW5pdEFjdGl2ZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKSxcXG4gICAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIkdldFlvRGlnaXRzXFxcIl0pKDYsICdvcmJpdCcpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKCFpbml0QWN0aXZlLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlTVVJKSB7XFxuICAgICAgICB0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoJ25vLW1vdGlvbnVpJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCkge1xcbiAgICAgICAgT2JqZWN0KF9mb3VuZGF0aW9uX3V0aWxfaW1hZ2VMb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwib25JbWFnZXNMb2FkZWRcXFwiXSkoJGltYWdlcywgdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKTsgLy9oZWhlXFxuXFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xcbiAgICAgICAgdGhpcy5fbG9hZEJ1bGxldHMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiB0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgdGhpcy5nZW9TeW5jKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXNzaWJsZSkge1xcbiAgICAgICAgLy8gYWxsb3cgd3JhcHBlciB0byBiZSBmb2N1c2FibGUgdG8gZW5hYmxlIGFycm93IG5hdmlnYXRpb25cXG4gICAgICAgIHRoaXMuJHdyYXBwZXIuYXR0cigndGFiaW5kZXgnLCAwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogQ3JlYXRlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGJ1bGxldHMsIGlmIHRoZXkgYXJlIGJlaW5nIHVzZWQuXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2xvYWRCdWxsZXRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkQnVsbGV0cygpIHtcXG4gICAgICB0aGlzLiRidWxsZXRzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykpLmZpbmQoJ2J1dHRvbicpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIFNldHMgYSBgdGltZXJgIG9iamVjdCBvbiB0aGUgb3JiaXQsIGFuZCBzdGFydHMgdGhlIGNvdW50ZXIgZm9yIHRoZSBuZXh0IHNsaWRlLlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZW9TeW5jXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlb1N5bmMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLnRpbWVyID0gbmV3IF9mb3VuZGF0aW9uX3V0aWxfdGltZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiVGltZXJcXFwiXSh0aGlzLiRlbGVtZW50LCB7XFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLnRpbWVyRGVsYXksXFxuICAgICAgICBpbmZpbml0ZTogZmFsc2VcXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogU2V0cyB3cmFwcGVyIGFuZCBzbGlkZSBoZWlnaHRzIGZvciB0aGUgb3JiaXQuXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3ByZXBhcmVGb3JPcmJpdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUZvck9yYml0KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fc2V0V3JhcHBlckhlaWdodCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIENhbHVsYXRlcyB0aGUgaGVpZ2h0IG9mIGVhY2ggc2xpZGUgaW4gdGhlIGNvbGxlY3Rpb24sIGFuZCB1c2VzIHRoZSB0YWxsZXN0IG9uZSBmb3IgdGhlIHdyYXBwZXIgaGVpZ2h0LlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgd2hlbiBjb21wbGV0ZS5cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFdyYXBwZXJIZWlnaHRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFdyYXBwZXJIZWlnaHQoY2IpIHtcXG4gICAgICAvL3Jld3JpdGUgdGhpcyB0byBgZm9yYCBsb29wXFxuICAgICAgdmFyIG1heCA9IDAsXFxuICAgICAgICAgIHRlbXAsXFxuICAgICAgICAgIGNvdW50ZXIgPSAwLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmF0dHIoJ2RhdGEtc2xpZGUnLCBjb3VudGVyKTsgLy8gaGlkZSBhbGwgc2xpZGVzIGJ1dCB0aGUgYWN0aXZlIG9uZVxcblxcbiAgICAgICAgaWYgKCEvbXVpL2cudGVzdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcylbMF0uY2xhc3NOYW1lKSAmJiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpWzBdICE9PSBfdGhpcy4kc2xpZGVzLmVxKGNvdW50ZXIpWzBdKSB7XFxuICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5jc3Moe1xcbiAgICAgICAgICAgICdkaXNwbGF5JzogJ25vbmUnXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XFxuICAgICAgICBjb3VudGVyKys7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGNvdW50ZXIgPT09IHRoaXMuJHNsaWRlcy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHtcXG4gICAgICAgICAgJ2hlaWdodCc6IG1heFxcbiAgICAgICAgfSk7IC8vb25seSBjaGFuZ2UgdGhlIHdyYXBwZXIgaGVpZ2h0IHByb3BlcnR5IG9uY2UuXFxuXFxuICAgICAgICBpZiAoY2IpIHtcXG4gICAgICAgICAgY2IobWF4KTtcXG4gICAgICAgIH0gLy9maXJlIGNhbGxiYWNrIHdpdGggbWF4IGhlaWdodCBkaW1lbnNpb24uXFxuXFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIFNldHMgdGhlIG1heC1oZWlnaHQgb2YgZWFjaCBzbGlkZS5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0U2xpZGVIZWlnaHRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNsaWRlSGVpZ2h0KGhlaWdodCkge1xcbiAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5jc3MoJ21heC1oZWlnaHQnLCBoZWlnaHQpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGJhc2ljYWxseSBldmVyeXRoaW5nIHdpdGhpbiB0aGUgZWxlbWVudC5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4gICAgICAvLyoqTm93IHVzaW5nIGN1c3RvbSBldmVudCAtIHRoYW5rcyB0bzoqKlxcbiAgICAgIC8vKiogICAgICBZb2hhaSBBcmFyYXQgb2YgVG9yb250byAgICAgICoqXFxuICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4gICAgICAvL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcucmVzaXplbWUuemYudHJpZ2dlcicpLm9uKHtcXG4gICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcylcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy4kc2xpZGVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3dpcGUpIHtcXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLm9mZignc3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXQnKS5vbignc3dpcGVsZWZ0LnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XFxuICAgICAgICAgIH0pLm9uKCdzd2lwZXJpZ2h0LnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLm9uKCdjbGljay56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nLCBfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSA/IGZhbHNlIDogdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgX3RoaXMudGltZXJbX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyAncGF1c2UnIDogJ3N0YXJ0J10oKTtcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnRpbWVyLnBhdXNlKCk7XFxuICAgICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLnN0YXJ0KCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2QnV0dG9ucykge1xcbiAgICAgICAgICB2YXIgJGNvbnRyb2xzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLm5leHRDbGFzcywgXFxcIiwgLlxcXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMucHJldkNsYXNzKSk7XFxuICAgICAgICAgICRjb250cm9scy5hdHRyKCd0YWJpbmRleCcsIDApIC8vYWxzbyBuZWVkIHRvIGhhbmRsZSBlbnRlci9yZXR1cm4gYW5kIHNwYWNlYmFyIGtleSBwcmVzc2VzXFxuICAgICAgICAgIC5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuaGFzQ2xhc3MoX3RoaXMub3B0aW9ucy5uZXh0Q2xhc3MpKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgICAgdGhpcy4kYnVsbGV0cy5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKC9pcy1hY3RpdmUvZy50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH0gLy9pZiB0aGlzIGlzIGFjdGl2ZSwga2ljayBvdXQgb2YgZnVuY3Rpb24uXFxuXFxuXFxuICAgICAgICAgICAgdmFyIGlkeCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCdzbGlkZScpLFxcbiAgICAgICAgICAgICAgICBsdHIgPSBpZHggPiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmRhdGEoJ3NsaWRlJyksXFxuICAgICAgICAgICAgICAgICRzbGlkZSA9IF90aGlzLiRzbGlkZXMuZXEoaWR4KTtcXG5cXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShsdHIsICRzbGlkZSwgaWR4KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcXG4gICAgICAgICAgdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oJ2tleWRvd24uemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG4gICAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIktleWJvYXJkXFxcIl0uaGFuZGxlS2V5KGUsICdPcmJpdCcsIHtcXG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XFxuICAgICAgICAgICAgICAgIC8vIGlmIGJ1bGxldCBpcyBmb2N1c2VkLCBtYWtlIHN1cmUgZm9jdXMgbW92ZXNcXG4gICAgICAgICAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlLnRhcmdldCkuaXMoX3RoaXMuJGJ1bGxldHMpKSB7XFxuICAgICAgICAgICAgICAgICAgX3RoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlc2V0cyBPcmJpdCBzbyBpdCBjYW4gYmUgcmVpbml0aWFsaXplZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3Jlc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcXG4gICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGVyZSBhcmUgbm8gc2xpZGVzIChmaXJzdCBydW4pXFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLiRzbGlkZXMgPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICAvLyBSZW1vdmUgb2xkIGV2ZW50c1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5vcmJpdCcpLmZpbmQoJyonKS5vZmYoJy56Zi5vcmJpdCcpOyAvLyBSZXN0YXJ0IHRpbWVyIGlmIGF1dG9QbGF5IGlzIGVuYWJsZWRcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcXG4gICAgICAgICAgdGhpcy50aW1lci5yZXN0YXJ0KCk7XFxuICAgICAgICB9IC8vIFJlc2V0IGFsbCBzbGlkZGVzXFxuXFxuXFxuICAgICAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcXG4gICAgICAgIH0pOyAvLyBTaG93IHRoZSBmaXJzdCBzbGlkZVxcblxcbiAgICAgICAgdGhpcy4kc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnNob3coKTsgLy8gVHJpZ2dlcnMgd2hlbiB0aGUgc2xpZGUgaGFzIGZpbmlzaGVkIGFuaW1hdGluZ1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzbGlkZWNoYW5nZS56Zi5vcmJpdCcsIFt0aGlzLiRzbGlkZXMuZmlyc3QoKV0pOyAvLyBTZWxlY3QgZmlyc3QgYnVsbGV0IGlmIGJ1bGxldHMgYXJlIHByZXNlbnRcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xcbiAgICAgICAgICB0aGlzLl91cGRhdGVCdWxsZXRzKDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNsaWRlIHRvIGEgbmV3IG9uZS5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTFRSIC0gaWYgdHJ1ZSB0aGUgc2xpZGUgbW92ZXMgZnJvbSByaWdodCB0byBsZWZ0LCBpZiBmYWxzZSB0aGUgc2xpZGUgbW92ZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxcbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBjaG9zZW5TbGlkZSAtIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgc2xpZGUgdG8gc2hvdyBuZXh0LCBpZiBvbmUgaXMgc2VsZWN0ZWQuXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgbmV3IHNsaWRlIGluIGl0cyBjb2xsZWN0aW9uLCBpZiBvbmUgY2hvc2VuLlxcbiAgICAqIEBmaXJlcyBPcmJpdCNzbGlkZWNoYW5nZVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjaGFuZ2VTbGlkZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VTbGlkZShpc0xUUiwgY2hvc2VuU2xpZGUsIGlkeCkge1xcbiAgICAgIGlmICghdGhpcy4kc2xpZGVzKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBEb24ndCBmcmVhayBvdXQgaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBjbGVhbnVwXFxuXFxuXFxuICAgICAgdmFyICRjdXJTbGlkZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5lcSgwKTtcXG5cXG4gICAgICBpZiAoL211aS9nLnRlc3QoJGN1clNsaWRlWzBdLmNsYXNzTmFtZSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vaWYgdGhlIHNsaWRlIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGtpY2sgb3V0IG9mIHRoZSBmdW5jdGlvblxcblxcblxcbiAgICAgIHZhciAkZmlyc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5maXJzdCgpLFxcbiAgICAgICAgICAkbGFzdFNsaWRlID0gdGhpcy4kc2xpZGVzLmxhc3QoKSxcXG4gICAgICAgICAgZGlySW4gPSBpc0xUUiA/ICdSaWdodCcgOiAnTGVmdCcsXFxuICAgICAgICAgIGRpck91dCA9IGlzTFRSID8gJ0xlZnQnIDogJ1JpZ2h0JyxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAkbmV3U2xpZGU7XFxuXFxuICAgICAgaWYgKCFjaG9zZW5TbGlkZSkge1xcbiAgICAgICAgLy9tb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgYXV0byBwbGF5ZWQgb3IgY2xpY2tlZCBmcm9tIHRoZSBuYXZCdXR0b25zLlxcbiAgICAgICAgJG5ld1NsaWRlID0gaXNMVFIgPyAvL2lmIHdyYXBwaW5nIGVuYWJsZWQsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGBuZXh0YCBvciBgcHJldmAgc2libGluZywgaWYgbm90LCBzZWxlY3QgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUgdG8gZmlsbCBpbi4gaWYgd3JhcHBpbmcgbm90IGVuYWJsZWQsIGF0dGVtcHQgdG8gc2VsZWN0IGBuZXh0YCBvciBgcHJldmAsIGlmIHRoZXJlJ3Mgbm90aGluZyB0aGVyZSwgdGhlIGZ1bmN0aW9uIHdpbGwga2ljayBvdXQgb24gbmV4dCBzdGVwLiBDUkFaWSBORVNURUQgVEVSTkFSSUVTISEhISFcXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXAgPyAkY3VyU2xpZGUubmV4dChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSkubGVuZ3RoID8gJGN1clNsaWRlLm5leHQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpIDogJGZpcnN0U2xpZGUgOiAkY3VyU2xpZGUubmV4dChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSkgOiAvL3BpY2sgbmV4dCBzbGlkZSBpZiBtb3ZpbmcgbGVmdCB0byByaWdodFxcbiAgICAgICAgdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5wcmV2KFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKS5sZW5ndGggPyAkY3VyU2xpZGUucHJldihcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSkgOiAkbGFzdFNsaWRlIDogJGN1clNsaWRlLnByZXYoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpOyAvL3BpY2sgcHJldiBzbGlkZSBpZiBtb3ZpbmcgcmlnaHQgdG8gbGVmdFxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAkbmV3U2xpZGUgPSBjaG9zZW5TbGlkZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCRuZXdTbGlkZS5sZW5ndGgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgKiBUcmlnZ2VycyBiZWZvcmUgdGhlIG5leHQgc2xpZGUgc3RhcnRzIGFuaW1hdGluZyBpbiBhbmQgb25seSBpZiBhIG5leHQgc2xpZGUgaGFzIGJlZW4gZm91bmQuXFxuICAgICAgICAqIEBldmVudCBPcmJpdCNiZWZvcmVzbGlkZWNoYW5nZVxcbiAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignYmVmb3Jlc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJGN1clNsaWRlLCAkbmV3U2xpZGVdKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xcbiAgICAgICAgICBpZHggPSBpZHggfHwgdGhpcy4kc2xpZGVzLmluZGV4KCRuZXdTbGlkZSk7IC8vZ3JhYiBpbmRleCB0byB1cGRhdGUgYnVsbGV0c1xcblxcbiAgICAgICAgICB0aGlzLl91cGRhdGVCdWxsZXRzKGlkeCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZU1VSSAmJiAhdGhpcy4kZWxlbWVudC5pcygnOmhpZGRlbicpKSB7XFxuICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVJbigkbmV3U2xpZGUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLCB0aGlzLm9wdGlvbnNbXFxcImFuaW1JbkZyb21cXFwiLmNvbmNhdChkaXJJbildLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJG5ld1NsaWRlLmNzcyh7XFxuICAgICAgICAgICAgICAnZGlzcGxheSc6ICdibG9jaydcXG4gICAgICAgICAgICB9KS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJNb3Rpb25cXFwiXS5hbmltYXRlT3V0KCRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyksIHRoaXMub3B0aW9uc1tcXFwiYW5pbU91dFRvXFxcIi5jb25jYXQoZGlyT3V0KV0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQXR0cignYXJpYS1saXZlJyk7XFxuXFxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIV90aGlzLnRpbWVyLmlzUGF1c2VkKSB7XFxuICAgICAgICAgICAgICBfdGhpcy50aW1lci5yZXN0YXJ0KCk7XFxuICAgICAgICAgICAgfSAvL2RvIHN0dWZmP1xcblxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWluJykucmVtb3ZlQXR0cignYXJpYS1saXZlJykuaGlkZSgpO1xcbiAgICAgICAgICAkbmV3U2xpZGUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1pbicpLmF0dHIoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKS5zaG93KCk7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIXRoaXMudGltZXIuaXNQYXVzZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnRpbWVyLnJlc3RhcnQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4uXFxuICAgICAgICAqIEBldmVudCBPcmJpdCNzbGlkZWNoYW5nZVxcbiAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJG5ld1NsaWRlXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIFVwZGF0ZXMgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgYnVsbGV0cywgaWYgZGlzcGxheWVkLlxcbiAgICAqIE1vdmUgdGhlIGRlc2NyaXB0b3Igb2YgdGhlIGN1cnJlbnQgc2xpZGUgYFtkYXRhLXNsaWRlLWFjdGl2ZS1sYWJlbF1gIHRvIHRoZSBuZXdseSBhY3RpdmUgYnVsbGV0LlxcbiAgICAqIElmIG5vIGBbZGF0YS1zbGlkZS1hY3RpdmUtbGFiZWxdYCBpcyBzZXQsIHdpbGwgbW92ZSB0aGUgZXhjZWVkaW5nIGBzcGFuYCBlbGVtZW50LlxcbiAgICAqXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHNsaWRlLlxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfdXBkYXRlQnVsbGV0c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQnVsbGV0cyhpZHgpIHtcXG4gICAgICB2YXIgJG9sZEJ1bGxldCA9IHRoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJyk7XFxuICAgICAgdmFyICRvdGhlcnNCdWxsZXRzID0gdGhpcy4kYnVsbGV0cy5ub3QoJy5pcy1hY3RpdmUnKTtcXG4gICAgICB2YXIgJG5ld0J1bGxldCA9IHRoaXMuJGJ1bGxldHMuZXEoaWR4KTtcXG4gICAgICAkb2xkQnVsbGV0LnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5ibHVyKCk7XFxuICAgICAgJG5ld0J1bGxldC5hZGRDbGFzcygnaXMtYWN0aXZlJyk7IC8vIEZpbmQgdGhlIGRlc2NyaXB0b3IgZm9yIHRoZSBjdXJyZW50IHNsaWRlIHRvIG1vdmUgaXQgdG8gdGhlIG5ldyBzbGlkZSBidXR0b25cXG5cXG4gICAgICB2YXIgYWN0aXZlU3RhdGVEZXNjcmlwdG9yID0gJG9sZEJ1bGxldC5jaGlsZHJlbignW2RhdGEtc2xpZGUtYWN0aXZlLWxhYmVsXScpLmxhc3QoKTsgLy8gSWYgbm90IGV4cGxpY2l0ZWx5IGdpdmVuLCBzZWFyY2ggZm9yIHRoZSBsYXN0IFxcXCJleGNlZWRpbmdcXFwiIHNwYW4gZWxlbWVudCAoY29tcGFyZWQgdG8gb3RoZXJzIGJ1bGxldHMpLlxcblxcbiAgICAgIGlmICghYWN0aXZlU3RhdGVEZXNjcmlwdG9yLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIHNwYW5zID0gJG9sZEJ1bGxldC5jaGlsZHJlbignc3BhbicpO1xcbiAgICAgICAgdmFyIHNwYW5Db3VudEluT3RoZXJzQnVsbGV0cyA9ICRvdGhlcnNCdWxsZXRzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShiKS5jaGlsZHJlbignc3BhbicpLmxlbmd0aDtcXG4gICAgICAgIH0pOyAvLyBJZiB0aGVyZSBpcyBhbiBleGNlZWRpbmcgc3BhbiBlbGVtZW50LCB1c2UgaXQgYXMgY3VycmVudCBzbGlkZSBkZXNjcmlwdG9yXFxuXFxuICAgICAgICBpZiAoc3BhbkNvdW50SW5PdGhlcnNCdWxsZXRzLmV2ZXJ5KGZ1bmN0aW9uIChjb3VudCkge1xcbiAgICAgICAgICByZXR1cm4gY291bnQgPCBzcGFucy5sZW5ndGg7XFxuICAgICAgICB9KSkge1xcbiAgICAgICAgICBhY3RpdmVTdGF0ZURlc2NyaXB0b3IgPSBzcGFucy5sYXN0KCk7XFxuICAgICAgICAgIGFjdGl2ZVN0YXRlRGVzY3JpcHRvci5hdHRyKCdkYXRhLXNsaWRlLWFjdGl2ZS1sYWJlbCcsICcnKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIE1vdmUgdGhlIGN1cnJlbnQgc2xpZGUgZGVzY3JpcHRvciB0byB0aGUgbmV3IHNsaWRlIGJ1dHRvblxcblxcblxcbiAgICAgIGlmIChhY3RpdmVTdGF0ZURlc2NyaXB0b3IubGVuZ3RoKSB7XFxuICAgICAgICBhY3RpdmVTdGF0ZURlc2NyaXB0b3IuZGV0YWNoKCk7XFxuICAgICAgICAkbmV3QnVsbGV0LmFwcGVuZChhY3RpdmVTdGF0ZURlc2NyaXB0b3IpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBEZXN0cm95cyB0aGUgY2Fyb3VzZWwgYW5kIGhpZGVzIHRoZSBlbGVtZW50LlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLm9yYml0JykuZmluZCgnKicpLm9mZignLnpmLm9yYml0JykuZW5kKCkuaGlkZSgpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gT3JiaXQ7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuXFxuT3JiaXQuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICogVGVsbHMgdGhlIEpTIHRvIGxvb2sgZm9yIGFuZCBsb2FkQnVsbGV0cy5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAqIEBkZWZhdWx0IHRydWVcXG4gICovXFxuICBidWxsZXRzOiB0cnVlLFxcblxcbiAgLyoqXFxuICAqIFRlbGxzIHRoZSBKUyB0byBhcHBseSBldmVudCBsaXN0ZW5lcnMgdG8gbmF2IGJ1dHRvbnNcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAqIEBkZWZhdWx0IHRydWVcXG4gICovXFxuICBuYXZCdXR0b25zOiB0cnVlLFxcblxcbiAgLyoqXFxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ3NsaWRlLWluLXJpZ2h0J1xcbiAgKi9cXG4gIGFuaW1JbkZyb21SaWdodDogJ3NsaWRlLWluLXJpZ2h0JyxcXG5cXG4gIC8qKlxcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdzbGlkZS1vdXQtcmlnaHQnXFxuICAqL1xcbiAgYW5pbU91dFRvUmlnaHQ6ICdzbGlkZS1vdXQtcmlnaHQnLFxcblxcbiAgLyoqXFxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ3NsaWRlLWluLWxlZnQnXFxuICAqXFxuICAqL1xcbiAgYW5pbUluRnJvbUxlZnQ6ICdzbGlkZS1pbi1sZWZ0JyxcXG5cXG4gIC8qKlxcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdzbGlkZS1vdXQtbGVmdCdcXG4gICovXFxuICBhbmltT3V0VG9MZWZ0OiAnc2xpZGUtb3V0LWxlZnQnLFxcblxcbiAgLyoqXFxuICAqIEFsbG93cyBPcmJpdCB0byBhdXRvbWF0aWNhbGx5IGFuaW1hdGUgb24gcGFnZSBsb2FkLlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIGF1dG9QbGF5OiB0cnVlLFxcblxcbiAgLyoqXFxuICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgYmV0d2VlbiBzbGlkZSB0cmFuc2l0aW9uc1xcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgKiBAZGVmYXVsdCA1MDAwXFxuICAqL1xcbiAgdGltZXJEZWxheTogNTAwMCxcXG5cXG4gIC8qKlxcbiAgKiBBbGxvd3MgT3JiaXQgdG8gaW5maW5pdGVseSBsb29wIHRocm91Z2ggdGhlIHNsaWRlc1xcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIGluZmluaXRlV3JhcDogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgKiBBbGxvd3MgdGhlIE9yYml0IHNsaWRlcyB0byBiaW5kIHRvIHN3aXBlIGV2ZW50cyBmb3IgbW9iaWxlLCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHV0aWwgbGlicmFyeVxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIHN3aXBlOiB0cnVlLFxcblxcbiAgLyoqXFxuICAqIEFsbG93cyB0aGUgdGltaW5nIGZ1bmN0aW9uIHRvIHBhdXNlIGFuaW1hdGlvbiBvbiBob3Zlci5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAqIEBkZWZhdWx0IHRydWVcXG4gICovXFxuICBwYXVzZU9uSG92ZXI6IHRydWUsXFxuXFxuICAvKipcXG4gICogQWxsb3dzIE9yYml0IHRvIGJpbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHRoZSBzbGlkZXIsIHRvIGFuaW1hdGUgZnJhbWVzIHdpdGggYXJyb3cga2V5c1xcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIGFjY2Vzc2libGU6IHRydWUsXFxuXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG9mIE9yYml0XFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdvcmJpdC1jb250YWluZXInXFxuICAqL1xcbiAgY29udGFpbmVyQ2xhc3M6ICdvcmJpdC1jb250YWluZXInLFxcblxcbiAgLyoqXFxuICAqIENsYXNzIGFwcGxpZWQgdG8gaW5kaXZpZHVhbCBzbGlkZXMuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdvcmJpdC1zbGlkZSdcXG4gICovXFxuICBzbGlkZUNsYXNzOiAnb3JiaXQtc2xpZGUnLFxcblxcbiAgLyoqXFxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGJ1bGxldCBjb250YWluZXIuIFlvdSdyZSB3ZWxjb21lLlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgKiBAZGVmYXVsdCAnb3JiaXQtYnVsbGV0cydcXG4gICovXFxuICBib3hPZkJ1bGxldHM6ICdvcmJpdC1idWxsZXRzJyxcXG5cXG4gIC8qKlxcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgbmV4dGAgbmF2aWdhdGlvbiBidXR0b24uXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdvcmJpdC1uZXh0J1xcbiAgKi9cXG4gIG5leHRDbGFzczogJ29yYml0LW5leHQnLFxcblxcbiAgLyoqXFxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBwcmV2aW91c2AgbmF2aWdhdGlvbiBidXR0b24uXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdvcmJpdC1wcmV2aW91cydcXG4gICovXFxuICBwcmV2Q2xhc3M6ICdvcmJpdC1wcmV2aW91cycsXFxuXFxuICAvKipcXG4gICogQm9vbGVhbiB0byBmbGFnIHRoZSBqcyB0byB1c2UgbW90aW9uIHVpIGNsYXNzZXMgb3Igbm90LiBEZWZhdWx0IHRvIHRydWUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIHVzZU1VSTogdHJ1ZVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5vcmJpdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi5wb3NpdGlvbmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogUG9zaXRpb25hYmxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJQb3NpdGlvbmFibGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBvc2l0aW9uYWJsZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5ib3ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmJveC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxudmFyIFBPU0lUSU9OUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ107XFxudmFyIFZFUlRJQ0FMX0FMSUdOTUVOVFMgPSBbJ3RvcCcsICdib3R0b20nLCAnY2VudGVyJ107XFxudmFyIEhPUklaT05UQUxfQUxJR05NRU5UUyA9IFsnbGVmdCcsICdyaWdodCcsICdjZW50ZXInXTtcXG52YXIgQUxJR05NRU5UUyA9IHtcXG4gICdsZWZ0JzogVkVSVElDQUxfQUxJR05NRU5UUyxcXG4gICdyaWdodCc6IFZFUlRJQ0FMX0FMSUdOTUVOVFMsXFxuICAndG9wJzogSE9SSVpPTlRBTF9BTElHTk1FTlRTLFxcbiAgJ2JvdHRvbSc6IEhPUklaT05UQUxfQUxJR05NRU5UU1xcbn07XFxuXFxuZnVuY3Rpb24gbmV4dEl0ZW0oaXRlbSwgYXJyYXkpIHtcXG4gIHZhciBjdXJyZW50SWR4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcXG5cXG4gIGlmIChjdXJyZW50SWR4ID09PSBhcnJheS5sZW5ndGggLSAxKSB7XFxuICAgIHJldHVybiBhcnJheVswXTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBhcnJheVtjdXJyZW50SWR4ICsgMV07XFxuICB9XFxufVxcblxcbnZhciBQb3NpdGlvbmFibGUgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFBvc2l0aW9uYWJsZSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBQb3NpdGlvbmFibGUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3NpdGlvbmFibGUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFBvc2l0aW9uYWJsZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUG9zaXRpb25hYmxlLCBbe1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSB0ZXRoZXItbGlrZSBleHBsaWNpdCBwb3NpdGlvbmluZyBsb2dpY1xcbiAgICAgKiBpbmNsdWRpbmcgcmVwb3NpdGlvbmluZyBiYXNlZCBvbiBvdmVybGFwLlxcbiAgICAgKiBFeHBlY3RzIGNsYXNzZXMgdG8gZGVmaW5lIGRlZmF1bHRzIGZvciB2T2Zmc2V0LCBoT2Zmc2V0LCBwb3NpdGlvbixcXG4gICAgICogYWxpZ25tZW50LCBhbGxvd092ZXJsYXAsIGFuZCBhbGxvd0JvdHRvbU92ZXJsYXAuIFRoZXkgY2FuIGRvIHRoaXMgYnlcXG4gICAgICogZXh0ZW5kaW5nIHRoZSBkZWZhdWx0cywgb3IgKGZvciBub3cgcmVjb21tZW5kZWQgZHVlIHRvIHRoZSB3YXkgZG9jcyBhcmVcXG4gICAgICogZ2VuZXJhdGVkKSBieSBleHBsaWNpdGx5IGRlY2xhcmluZyB0aGVtLlxcbiAgICAgKlxcbiAgICAgKiovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zID0ge307XFxuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2F1dG8nID8gdGhpcy5fZ2V0RGVmYXVsdFBvc2l0aW9uKCkgOiB0aGlzLm9wdGlvbnMucG9zaXRpb247XFxuICAgICAgdGhpcy5hbGlnbm1lbnQgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnYXV0bycgPyB0aGlzLl9nZXREZWZhdWx0QWxpZ25tZW50KCkgOiB0aGlzLm9wdGlvbnMuYWxpZ25tZW50O1xcbiAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XFxuICAgICAgdGhpcy5vcmlnaW5hbEFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50O1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXREZWZhdWx0UG9zaXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcXG4gICAgICByZXR1cm4gJ2JvdHRvbSc7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dldERlZmF1bHRBbGlnbm1lbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XFxuICAgICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XFxuICAgICAgICBjYXNlICdib3R0b20nOlxcbiAgICAgICAgY2FzZSAndG9wJzpcXG4gICAgICAgICAgcmV0dXJuIE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInJ0bFxcXCJdKSgpID8gJ3JpZ2h0JyA6ICdsZWZ0JztcXG5cXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxcbiAgICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGp1c3RzIHRoZSBwb3NpdGlvbmFibGUgcG9zc2libGUgcG9zaXRpb25zIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsaWdubWVudHNcXG4gICAgICogYW5kIHBvc2l0aW9ucy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVwb3NpdGlvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVwb3NpdGlvbigpIHtcXG4gICAgICBpZiAodGhpcy5fYWxpZ25tZW50c0V4aGF1c3RlZCh0aGlzLnBvc2l0aW9uKSkge1xcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5leHRJdGVtKHRoaXMucG9zaXRpb24sIFBPU0lUSU9OUyk7XFxuICAgICAgICB0aGlzLmFsaWdubWVudCA9IEFMSUdOTUVOVFNbdGhpcy5wb3NpdGlvbl1bMF07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX3JlYWxpZ24oKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkanVzdHMgdGhlIGRyb3Bkb3duIHBhbmUgcG9zc2libGUgcG9zaXRpb25zIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsaWdubWVudHNcXG4gICAgICogb24gdGhlIGN1cnJlbnQgcG9zaXRpb24uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3JlYWxpZ25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWxpZ24oKSB7XFxuICAgICAgdGhpcy5fYWRkVHJpZWRQb3NpdGlvbih0aGlzLnBvc2l0aW9uLCB0aGlzLmFsaWdubWVudCk7XFxuXFxuICAgICAgdGhpcy5hbGlnbm1lbnQgPSBuZXh0SXRlbSh0aGlzLmFsaWdubWVudCwgQUxJR05NRU5UU1t0aGlzLnBvc2l0aW9uXSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZFRyaWVkUG9zaXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRyaWVkUG9zaXRpb24ocG9zaXRpb24sIGFsaWdubWVudCkge1xcbiAgICAgIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dID0gdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0gfHwgW107XFxuICAgICAgdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0ucHVzaChhbGlnbm1lbnQpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9wb3NpdGlvbnNFeGhhdXN0ZWRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uc0V4aGF1c3RlZCgpIHtcXG4gICAgICB2YXIgaXNFeGhhdXN0ZWQgPSB0cnVlO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUE9TSVRJT05TLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpc0V4aGF1c3RlZCA9IGlzRXhoYXVzdGVkICYmIHRoaXMuX2FsaWdubWVudHNFeGhhdXN0ZWQoUE9TSVRJT05TW2ldKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGlzRXhoYXVzdGVkO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hbGlnbm1lbnRzRXhoYXVzdGVkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hbGlnbm1lbnRzRXhoYXVzdGVkKHBvc2l0aW9uKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dICYmIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dLmxlbmd0aCA9PSBBTElHTk1FTlRTW3Bvc2l0aW9uXS5sZW5ndGg7XFxuICAgIH0gLy8gV2hlbiB3ZSdyZSB0cnlpbmcgdG8gY2VudGVyLCB3ZSBkb24ndCB3YW50IHRvIGFwcGx5IG9mZnNldCB0aGF0J3MgZ29pbmcgdG9cXG4gICAgLy8gdGFrZSB1cyBqdXN0IG9mZiBjZW50ZXIsIHNvIHdyYXAgYXJvdW5kIHRvIHJldHVybiAwIGZvciB0aGUgYXBwcm9wcmlhdGVcXG4gICAgLy8gb2Zmc2V0IGluIHRob3NlIGFsaWdubWVudHMuICBUT0RPOiBGaWd1cmUgb3V0IGlmIHdlIHdhbnQgdG8gbWFrZSB0aGlzXFxuICAgIC8vIGNvbmZpZ3VyYWJsZSBiZWhhdmlvci4uLiBpdCBmZWVscyBtb3JlIGludHVpdGl2ZSwgZXNwZWNpYWxseSBmb3IgdG9vbHRpcHMsIGJ1dFxcbiAgICAvLyBpdCdzIHBvc3NpYmxlIHNvbWVvbmUgbWlnaHQgYWN0dWFsbHkgd2FudCB0byBzdGFydCBmcm9tIGNlbnRlciBhbmQgdGhlbiBudWRnZVxcbiAgICAvLyBzbGlnaHRseSBvZmYuXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXRWT2Zmc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWT2Zmc2V0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudk9mZnNldDtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0SE9mZnNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SE9mZnNldCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhPZmZzZXQ7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFBvc2l0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigkYW5jaG9yLCAkZWxlbWVudCwgJHBhcmVudCkge1xcbiAgICAgIGlmICgkYW5jaG9yLmF0dHIoJ2FyaWEtZXhwYW5kZWQnKSA9PT0gJ2ZhbHNlJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd092ZXJsYXApIHtcXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgcG9zaXRpb24gJiBhbGlnbm1lbnQgYmVmb3JlIGNoZWNraW5nIG92ZXJsYXBcXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XFxuICAgICAgICB0aGlzLmFsaWdubWVudCA9IHRoaXMub3JpZ2luYWxBbGlnbm1lbnQ7XFxuICAgICAgfVxcblxcbiAgICAgICRlbGVtZW50Lm9mZnNldChfZm91bmRhdGlvbl91dGlsX2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJCb3hcXFwiXS5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93T3ZlcmxhcCkge1xcbiAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSAxMDAwMDAwMDA7IC8vIGRlZmF1bHQgY29vcmRpbmF0ZXMgdG8gaG93IHdlIHN0YXJ0LCBpbiBjYXNlIHdlIGNhbid0IGZpZ3VyZSBvdXQgYmV0dGVyXFxuXFxuICAgICAgICB2YXIgbWluQ29vcmRpbmF0ZXMgPSB7XFxuICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxcbiAgICAgICAgICBhbGlnbm1lbnQ6IHRoaXMuYWxpZ25tZW50XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgd2hpbGUgKCF0aGlzLl9wb3NpdGlvbnNFeGhhdXN0ZWQoKSkge1xcbiAgICAgICAgICB2YXIgb3ZlcmxhcCA9IF9mb3VuZGF0aW9uX3V0aWxfYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIkJveFxcXCJdLk92ZXJsYXBBcmVhKCRlbGVtZW50LCAkcGFyZW50LCBmYWxzZSwgZmFsc2UsIHRoaXMub3B0aW9ucy5hbGxvd0JvdHRvbU92ZXJsYXApO1xcblxcbiAgICAgICAgICBpZiAob3ZlcmxhcCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcXG4gICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcXG4gICAgICAgICAgICBtaW5Db29yZGluYXRlcyA9IHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiB0aGlzLmFsaWdubWVudFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fcmVwb3NpdGlvbigpO1xcblxcbiAgICAgICAgICAkZWxlbWVudC5vZmZzZXQoX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiQm94XFxcIl0uR2V0RXhwbGljaXRPZmZzZXRzKCRlbGVtZW50LCAkYW5jaG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFsaWdubWVudCwgdGhpcy5fZ2V0Vk9mZnNldCgpLCB0aGlzLl9nZXRIT2Zmc2V0KCkpKTtcXG4gICAgICAgIH0gLy8gSWYgd2UgZ2V0IHRocm91Z2ggdGhlIGVudGlyZSBsb29wLCB0aGVyZSB3YXMgbm8gbm9uLW92ZXJsYXBwaW5nXFxuICAgICAgICAvLyBwb3NpdGlvbiBhdmFpbGFibGUuIFBpY2sgdGhlIHZlcnNpb24gd2l0aCBsZWFzdCBvdmVybGFwLlxcblxcblxcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1pbkNvb3JkaW5hdGVzLnBvc2l0aW9uO1xcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSBtaW5Db29yZGluYXRlcy5hbGlnbm1lbnQ7XFxuICAgICAgICAkZWxlbWVudC5vZmZzZXQoX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiQm94XFxcIl0uR2V0RXhwbGljaXRPZmZzZXRzKCRlbGVtZW50LCAkYW5jaG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFsaWdubWVudCwgdGhpcy5fZ2V0Vk9mZnNldCgpLCB0aGlzLl9nZXRIT2Zmc2V0KCkpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBQb3NpdGlvbmFibGU7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuXFxuUG9zaXRpb25hYmxlLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBQb3NpdGlvbiBvZiBwb3NpdGlvbmFibGUgcmVsYXRpdmUgdG8gYW5jaG9yLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBwb3NpdGlvbjogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBBbGlnbm1lbnQgb2YgcG9zaXRpb25hYmxlIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgY2VudGVyLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBhbGlnbm1lbnQ6ICdhdXRvJyxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBjb250YWluZXIvd2luZG93LiBJZiBmYWxzZSwgZHJvcGRvd24gcG9zaXRpb25hYmxlIGZpcnN0XFxuICAgKiB0cnkgdG8gcG9zaXRpb24gYXMgZGVmaW5lZCBieSBkYXRhLXBvc2l0aW9uIGFuZCBkYXRhLWFsaWdubWVudCwgYnV0XFxuICAgKiByZXBvc2l0aW9uIGlmIGl0IHdvdWxkIGNhdXNlIGFuIG92ZXJmbG93LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBhbGxvd092ZXJsYXA6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvdyBvdmVybGFwIG9mIG9ubHkgdGhlIGJvdHRvbSBvZiB0aGUgY29udGFpbmVyLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vblxcbiAgICogYmVoYXZpb3IgZm9yIGRyb3Bkb3ducywgYWxsb3dpbmcgdGhlIGRyb3Bkb3duIHRvIGV4dGVuZCB0aGUgYm90dG9tIG9mIHRoZVxcbiAgICogc2NyZWVuIGJ1dCBub3Qgb3RoZXJ3aXNlIGluZmx1ZW5jZSBvciBicmVhayBvdXQgb2YgdGhlIGNvbnRhaW5lci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBhbGxvd0JvdHRvbU92ZXJsYXA6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdGhlIHBvc2l0aW9uYWJsZSBzaG91bGQgYmUgc2VwYXJhdGVkIHZlcnRpY2FsbHkgZnJvbSBhbmNob3JcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIHZPZmZzZXQ6IDAsXFxuXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdGhlIHBvc2l0aW9uYWJsZSBzaG91bGQgYmUgc2VwYXJhdGVkIGhvcml6b250YWxseSBmcm9tIGFuY2hvclxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgaE9mZnNldDogMFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5wb3NpdGlvbmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi5yZXNwb25zaXZlQWNjb3JkaW9uVGFicy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXNwb25zaXZlQWNjb3JkaW9uVGFiczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9hY2NvcmRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5hY2NvcmRpb24gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5hY2NvcmRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdGFic19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnRhYnMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi50YWJzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuIC8vIFRoZSBwbHVnaW4gbWF0Y2hlcyB0aGUgcGx1Z2luIGNsYXNzZXMgd2l0aCB0aGVzZSBwbHVnaW4gaW5zdGFuY2VzLlxcblxcbnZhciBNZW51UGx1Z2lucyA9IHtcXG4gIHRhYnM6IHtcXG4gICAgY3NzQ2xhc3M6ICd0YWJzJyxcXG4gICAgcGx1Z2luOiBfZm91bmRhdGlvbl90YWJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRhYnNcXFwiXSxcXG4gICAgb3BlbjogZnVuY3Rpb24gb3BlbihwbHVnaW4sIHRhcmdldCkge1xcbiAgICAgIHJldHVybiBwbHVnaW4uc2VsZWN0VGFiKHRhcmdldCk7XFxuICAgIH0sXFxuICAgIGNsb3NlOiBudWxsXFxuICAgIC8qIG5vdCBzdXBwb3J0ZWQgKi9cXG4gICAgLFxcbiAgICB0b2dnbGU6IG51bGxcXG4gICAgLyogbm90IHN1cHBvcnRlZCAqL1xcblxcbiAgfSxcXG4gIGFjY29yZGlvbjoge1xcbiAgICBjc3NDbGFzczogJ2FjY29yZGlvbicsXFxuICAgIHBsdWdpbjogX2ZvdW5kYXRpb25fYWNjb3JkaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIkFjY29yZGlvblxcXCJdLFxcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKHBsdWdpbiwgdGFyZ2V0KSB7XFxuICAgICAgcmV0dXJuIHBsdWdpbi5kb3duKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0YXJnZXQpKTtcXG4gICAgfSxcXG4gICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKHBsdWdpbiwgdGFyZ2V0KSB7XFxuICAgICAgcmV0dXJuIHBsdWdpbi51cChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGFyZ2V0KSk7XFxuICAgIH0sXFxuICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKHBsdWdpbiwgdGFyZ2V0KSB7XFxuICAgICAgcmV0dXJuIHBsdWdpbi50b2dnbGUoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRhcmdldCkpO1xcbiAgICB9XFxuICB9XFxufTtcXG4vKipcXG4gKiBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi5hY2NvcmRpb25cXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi50YWJzXFxuICovXFxuXFxudmFyIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyhlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHZhciBfdGhpczI7XFxuXFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyk7XFxuXFxuICAgIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSZXNwb25zaXZlQWNjb3JkaW9uVGFicykuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKSk7XFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpczIsIF90aGlzMi5vcHRpb25zLnJlZmxvdyAmJiBfdGhpczIuc3RvcmV6ZkRhdGEgfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpKTtcXG4gIH1cXG4gIC8qKlxcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgYWNjb3JkaW9uIHRhYnMuXFxuICAgKiBAY2xhc3NcXG4gICAqIEBuYW1lIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXFxuICAgKiBAZmlyZXMgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMjaW5pdFxcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBSZXNwb25zaXZlIEFjY29yZGlvbiBUYWJzLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMsIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZWxlbWVudCk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbkJhc2UnLCB0aGlzKTtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBSZXNwb25zaXZlQWNjb3JkaW9uVGFicy5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMucnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtYWNjb3JkaW9uLXRhYnMnKTtcXG4gICAgICB0aGlzLmN1cnJlbnRNcSA9IG51bGw7XFxuICAgICAgdGhpcy5jdXJyZW50UnVsZSA9IG51bGw7XFxuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlQWNjb3JkaW9uVGFicyc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJywgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ3Jlc3BvbnNpdmVhY2NvcmRpb250YWJzJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtcmVzcG9uc2l2ZS1hY2NvcmRpb24tdGFicycgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uX2luaXQoKTsgLy8gVGhlIGZpcnN0IHRpbWUgYW4gSW50ZXJjaGFuZ2UgcGx1Z2luIGlzIGluaXRpYWxpemVkLCB0aGlzLnJ1bGVzIGlzIGNvbnZlcnRlZCBmcm9tIGEgc3RyaW5nIG9mIFxcXCJjbGFzc2VzXFxcIiB0byBhbiBvYmplY3Qgb2YgcnVsZXNcXG5cXG5cXG4gICAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICB2YXIgcnVsZXNUcmVlID0ge307IC8vIFBhcnNlIHJ1bGVzIGZyb20gXFxcImNsYXNzZXNcXFwiIHB1bGxlZCBmcm9tIGRhdGEgYXR0cmlidXRlXFxuXFxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLnNwbGl0KCcgJyk7IC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBydWxlIGZvdW5kXFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc3BsaXQoJy0nKTtcXG4gICAgICAgICAgdmFyIHJ1bGVTaXplID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVswXSA6ICdzbWFsbCc7XFxuICAgICAgICAgIHZhciBydWxlUGx1Z2luID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVsxXSA6IHJ1bGVbMF07XFxuXFxuICAgICAgICAgIGlmIChNZW51UGx1Z2luc1tydWxlUGx1Z2luXSAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJ1bGVzVHJlZVtydWxlU2l6ZV0gPSBNZW51UGx1Z2luc1tydWxlUGx1Z2luXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzVHJlZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZ2V0QWxsT3B0aW9ucygpO1xcblxcbiAgICAgIGlmICghanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmlzRW1wdHlPYmplY3QodGhpcy5ydWxlcykpIHtcXG4gICAgICAgIHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXRBbGxPcHRpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxPcHRpb25zKCkge1xcbiAgICAgIC8vZ2V0IGFsbCBkZWZhdWx0cyBhbmQgb3B0aW9uc1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgX3RoaXMuYWxsT3B0aW9ucyA9IHt9O1xcblxcbiAgICAgIGZvciAodmFyIGtleSBpbiBNZW51UGx1Z2lucykge1xcbiAgICAgICAgaWYgKE1lbnVQbHVnaW5zLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgICAgdmFyIG9iaiA9IE1lbnVQbHVnaW5zW2tleV07XFxuXFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIGR1bW15UGx1Z2luID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCc8dWw+PC91bD4nKTtcXG4gICAgICAgICAgICB2YXIgdG1wUGx1Z2luID0gbmV3IG9iai5wbHVnaW4oZHVtbXlQbHVnaW4sIF90aGlzLm9wdGlvbnMpO1xcblxcbiAgICAgICAgICAgIGZvciAodmFyIGtleUtleSBpbiB0bXBQbHVnaW4ub3B0aW9ucykge1xcbiAgICAgICAgICAgICAgaWYgKHRtcFBsdWdpbi5vcHRpb25zLmhhc093blByb3BlcnR5KGtleUtleSkgJiYga2V5S2V5ICE9PSAnemZQbHVnaW4nKSB7XFxuICAgICAgICAgICAgICAgIHZhciBvYmpPYmogPSB0bXBQbHVnaW4ub3B0aW9uc1trZXlLZXldO1xcbiAgICAgICAgICAgICAgICBfdGhpcy5hbGxPcHRpb25zW2tleUtleV0gPSBvYmpPYmo7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRtcFBsdWdpbi5kZXN0cm95KCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBNZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB0aGlzLl9jaGFuZ2VkWmZNZWRpYVF1ZXJ5SGFuZGxlciA9IHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzLmJpbmQodGhpcyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX2NoYW5nZWRaZk1lZGlhUXVlcnlIYW5kbGVyKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfY2hlY2tNZWRpYVF1ZXJpZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTWVkaWFRdWVyaWVzKCkge1xcbiAgICAgIHZhciBtYXRjaGVkTXEsXFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXFxuXFxuXFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgaWYgKF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uYXRMZWFzdChrZXkpKSB7XFxuICAgICAgICAgIG1hdGNoZWRNcSA9IGtleTtcXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcXG5cXG4gICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuOyAvLyBQbHVnaW4gYWxyZWFkeSBpbml0aWFsaXplZD8gV2UgZ29vZFxcblxcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKSByZXR1cm47IC8vIFJlbW92ZSBleGlzdGluZyBwbHVnaW4tc3BlY2lmaWMgQ1NTIGNsYXNzZXNcXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZWFjaChNZW51UGx1Z2lucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHZhbHVlLmNzc0NsYXNzKTtcXG4gICAgICB9KTsgLy8gQWRkIHRoZSBDU1MgY2xhc3MgZm9yIHRoZSBuZXcgcGx1Z2luXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpOyAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cXG5cXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB7XFxuICAgICAgICAvL2Rvbid0IGtub3cgd2h5IGJ1dCBvbiBuZXN0ZWQgZWxlbWVudHMgZGF0YSB6ZlBsdWdpbiBnZXQncyBsb3N0XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpICYmIHRoaXMuc3RvcmV6ZkRhdGEpIHRoaXMuY3VycmVudFBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicsIHRoaXMuc3RvcmV6ZkRhdGEpO1xcbiAgICAgICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faGFuZGxlTWFya3VwKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7XFxuXFxuICAgICAgdGhpcy5jdXJyZW50UnVsZSA9IHRoaXMucnVsZXNbbWF0Y2hlZE1xXTtcXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4gPSBuZXcgdGhpcy5jdXJyZW50UnVsZS5wbHVnaW4odGhpcy4kZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcXG4gICAgICB0aGlzLnN0b3JlemZEYXRhID0gdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJyk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hhbmRsZU1hcmt1cFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTWFya3VwKHRvU2V0KSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgZnJvbVN0cmluZyA9ICdhY2NvcmRpb24nO1xcblxcbiAgICAgIHZhciAkcGFuZWxzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS10YWJzLWNvbnRlbnQ9JyArIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJyk7XFxuICAgICAgaWYgKCRwYW5lbHMubGVuZ3RoKSBmcm9tU3RyaW5nID0gJ3RhYnMnO1xcblxcbiAgICAgIGlmIChmcm9tU3RyaW5nID09PSB0b1NldCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdGFic1RpdGxlID0gX3RoaXMuYWxsT3B0aW9ucy5saW5rQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLmxpbmtDbGFzcyA6ICd0YWJzLXRpdGxlJztcXG4gICAgICB2YXIgdGFic1BhbmVsID0gX3RoaXMuYWxsT3B0aW9ucy5wYW5lbENsYXNzID8gX3RoaXMuYWxsT3B0aW9ucy5wYW5lbENsYXNzIDogJ3RhYnMtcGFuZWwnO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cigncm9sZScpO1xcbiAgICAgIHZhciAkbGlIZWFkcyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy4nICsgdGFic1RpdGxlICsgJyxbZGF0YS1hY2NvcmRpb24taXRlbV0nKS5yZW1vdmVDbGFzcyh0YWJzVGl0bGUpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24taXRlbScpLnJlbW92ZUF0dHIoJ2RhdGEtYWNjb3JkaW9uLWl0ZW0nKTtcXG4gICAgICB2YXIgJGxpSGVhZHNBID0gJGxpSGVhZHMuY2hpbGRyZW4oJ2EnKS5yZW1vdmVDbGFzcygnYWNjb3JkaW9uLXRpdGxlJyk7XFxuXFxuICAgICAgaWYgKGZyb21TdHJpbmcgPT09ICd0YWJzJykge1xcbiAgICAgICAgJHBhbmVscyA9ICRwYW5lbHMuY2hpbGRyZW4oJy4nICsgdGFic1BhbmVsKS5yZW1vdmVDbGFzcyh0YWJzUGFuZWwpLnJlbW92ZUF0dHIoJ3JvbGUnKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGFiZWxsZWRieScpO1xcbiAgICAgICAgJHBhbmVscy5jaGlsZHJlbignYScpLnJlbW92ZUF0dHIoJ3JvbGUnKS5yZW1vdmVBdHRyKCdhcmlhLWNvbnRyb2xzJykucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAkcGFuZWxzID0gJGxpSGVhZHMuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24tY29udGVudCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkcGFuZWxzLmNzcyh7XFxuICAgICAgICBkaXNwbGF5OiAnJyxcXG4gICAgICAgIHZpc2liaWxpdHk6ICcnXFxuICAgICAgfSk7XFxuICAgICAgJGxpSGVhZHMuY3NzKHtcXG4gICAgICAgIGRpc3BsYXk6ICcnLFxcbiAgICAgICAgdmlzaWJpbGl0eTogJydcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodG9TZXQgPT09ICdhY2NvcmRpb24nKSB7XFxuICAgICAgICAkcGFuZWxzLmVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHZhbHVlKS5hcHBlbmRUbygkbGlIZWFkcy5nZXQoa2V5KSkuYWRkQ2xhc3MoJ2FjY29yZGlvbi1jb250ZW50JykuYXR0cignZGF0YS10YWItY29udGVudCcsICcnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuY3NzKHtcXG4gICAgICAgICAgICBoZWlnaHQ6ICcnXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJykuYWZ0ZXIoJzxkaXYgaWQ9XFxcInRhYnMtcGxhY2Vob2xkZXItJyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXFxcIj48L2Rpdj4nKS5kZXRhY2goKTtcXG4gICAgICAgICAgJGxpSGVhZHMuYWRkQ2xhc3MoJ2FjY29yZGlvbi1pdGVtJykuYXR0cignZGF0YS1hY2NvcmRpb24taXRlbScsICcnKTtcXG4gICAgICAgICAgJGxpSGVhZHNBLmFkZENsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAodG9TZXQgPT09ICd0YWJzJykge1xcbiAgICAgICAgdmFyICR0YWJzQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEtdGFicy1jb250ZW50PScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ10nKTtcXG4gICAgICAgIHZhciAkcGxhY2Vob2xkZXIgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJyN0YWJzLXBsYWNlaG9sZGVyLScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcXG5cXG4gICAgICAgIGlmICgkcGxhY2Vob2xkZXIubGVuZ3RoKSB7XFxuICAgICAgICAgICR0YWJzQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnPGRpdiBjbGFzcz1cXFwidGFicy1jb250ZW50XFxcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcigkcGxhY2Vob2xkZXIpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XFxuICAgICAgICAgICRwbGFjZWhvbGRlci5yZW1vdmUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICR0YWJzQ29udGVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnPGRpdiBjbGFzcz1cXFwidGFicy1jb250ZW50XFxcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcihfdGhpcy4kZWxlbWVudCkuYXR0cignZGF0YS10YWJzLWNvbnRlbnQnLCBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICRwYW5lbHMuZWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgICB2YXIgdGVtcFZhbHVlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHZhbHVlKS5hcHBlbmRUbygkdGFic0NvbnRlbnQpLmFkZENsYXNzKHRhYnNQYW5lbCk7XFxuICAgICAgICAgIHZhciBoYXNoID0gJGxpSGVhZHNBLmdldChrZXkpLmhhc2guc2xpY2UoMSk7XFxuICAgICAgICAgIHZhciBpZCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh2YWx1ZSkuYXR0cignaWQnKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnYWNjb3JkaW9uJyk7XFxuXFxuICAgICAgICAgIGlmIChoYXNoICE9PSBpZCkge1xcbiAgICAgICAgICAgIGlmIChoYXNoICE9PSAnJykge1xcbiAgICAgICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHZhbHVlKS5hdHRyKCdpZCcsIGhhc2gpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBoYXNoID0gaWQ7XFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodmFsdWUpLmF0dHIoJ2lkJywgaGFzaCk7XFxuICAgICAgICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJGxpSGVhZHNBLmdldChrZXkpKS5hdHRyKCdocmVmJywganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCRsaUhlYWRzQS5nZXQoa2V5KSkuYXR0cignaHJlZicpLnJlcGxhY2UoJyMnLCAnJykgKyAnIycgKyBoYXNoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCRsaUhlYWRzLmdldChrZXkpKS5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XFxuXFxuICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xcbiAgICAgICAgICAgIHRlbXBWYWx1ZS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgJGxpSGVhZHMuYWRkQ2xhc3ModGFic1RpdGxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgcGx1Z2luIHBhbmUgZGVmaW5lZCBieSBgdGFyZ2V0YC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IHRhcmdldCAtIGpRdWVyeSBvYmplY3Qgb3Igc3RyaW5nIG9mIHRoZSBpZCBvZiB0aGUgcGFuZSB0byBvcGVuLlxcbiAgICAgKiBAc2VlIEFjY29yZGlvbi5kb3duXFxuICAgICAqIEBzZWUgVGFicy5zZWxlY3RUYWJcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJvcGVuXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oX3RhcmdldCkge1xcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSdWxlICYmIHR5cGVvZiB0aGlzLmN1cnJlbnRSdWxlLm9wZW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHZhciBfdGhpcyRjdXJyZW50UnVsZTtcXG5cXG4gICAgICAgIHJldHVybiAoX3RoaXMkY3VycmVudFJ1bGUgPSB0aGlzLmN1cnJlbnRSdWxlKS5vcGVuLmFwcGx5KF90aGlzJGN1cnJlbnRSdWxlLCBbdGhpcy5jdXJyZW50UGx1Z2luXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIHRoZSBwbHVnaW4gcGFuZSBkZWZpbmVkIGJ5IGB0YXJnZXRgLiBOb3QgYXZhaWxhaWJsZSBmb3IgVGFicy5cXG4gICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IHRhcmdldCAtIGpRdWVyeSBvYmplY3Qgb3Igc3RyaW5nIG9mIHRoZSBpZCBvZiB0aGUgcGFuZSB0byBjbG9zZS5cXG4gICAgICogQHNlZSBBY2NvcmRpb24udXBcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjbG9zZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShfdGFyZ2V0KSB7XFxuICAgICAgaWYgKHRoaXMuY3VycmVudFJ1bGUgJiYgdHlwZW9mIHRoaXMuY3VycmVudFJ1bGUuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHZhciBfdGhpcyRjdXJyZW50UnVsZTI7XFxuXFxuICAgICAgICByZXR1cm4gKF90aGlzJGN1cnJlbnRSdWxlMiA9IHRoaXMuY3VycmVudFJ1bGUpLmNsb3NlLmFwcGx5KF90aGlzJGN1cnJlbnRSdWxlMiwgW3RoaXMuY3VycmVudFBsdWdpbl0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIHBsdWdpbiBwYW5lIGRlZmluZWQgYnkgYHRhcmdldGAuIE5vdCBhdmFpbGFpYmxlIGZvciBUYWJzLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeSB8IFN0cmluZ30gdGFyZ2V0IC0galF1ZXJ5IG9iamVjdCBvciBzdHJpbmcgb2YgdGhlIGlkIG9mIHRoZSBwYW5lIHRvIHRvZ2dsZS5cXG4gICAgICogQHNlZSBBY2NvcmRpb24udG9nZ2xlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9nZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShfdGFyZ2V0KSB7XFxuICAgICAgaWYgKHRoaXMuY3VycmVudFJ1bGUgJiYgdHlwZW9mIHRoaXMuY3VycmVudFJ1bGUudG9nZ2xlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB2YXIgX3RoaXMkY3VycmVudFJ1bGUzO1xcblxcbiAgICAgICAgcmV0dXJuIChfdGhpcyRjdXJyZW50UnVsZTMgPSB0aGlzLmN1cnJlbnRSdWxlKS50b2dnbGUuYXBwbHkoX3RoaXMkY3VycmVudFJ1bGUzLCBbdGhpcy5jdXJyZW50UGx1Z2luXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fY2hhbmdlZFpmTWVkaWFRdWVyeUhhbmRsZXIpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUmVzcG9uc2l2ZUFjY29yZGlvblRhYnM7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJQbHVnaW5cXFwiXSk7XFxuXFxuUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMuZGVmYXVsdHMgPSB7fTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFJlc3BvbnNpdmVNZW51ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJSZXNwb25zaXZlTWVudVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUmVzcG9uc2l2ZU1lbnU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUucGx1Z2luICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fZHJvcGRvd25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uZHJvcGRvd25NZW51ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2RyaWxsZG93bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmRyaWxsZG93biAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmRyaWxsZG93bi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9hY2NvcmRpb25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uYWNjb3JkaW9uTWVudSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG52YXIgTWVudVBsdWdpbnMgPSB7XFxuICBkcm9wZG93bjoge1xcbiAgICBjc3NDbGFzczogJ2Ryb3Bkb3duJyxcXG4gICAgcGx1Z2luOiBfZm91bmRhdGlvbl9kcm9wZG93bk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiRHJvcGRvd25NZW51XFxcIl1cXG4gIH0sXFxuICBkcmlsbGRvd246IHtcXG4gICAgY3NzQ2xhc3M6ICdkcmlsbGRvd24nLFxcbiAgICBwbHVnaW46IF9mb3VuZGF0aW9uX2RyaWxsZG93bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJEcmlsbGRvd25cXFwiXVxcbiAgfSxcXG4gIGFjY29yZGlvbjoge1xcbiAgICBjc3NDbGFzczogJ2FjY29yZGlvbi1tZW51JyxcXG4gICAgcGx1Z2luOiBfZm91bmRhdGlvbl9hY2NvcmRpb25NZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcIkFjY29yZGlvbk1lbnVcXFwiXVxcbiAgfVxcbn07IC8vIGltcG9ydCBcXFwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXFxcIjtcXG5cXG4vKipcXG4gKiBSZXNwb25zaXZlTWVudSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqL1xcblxcbnZhciBSZXNwb25zaXZlTWVudSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoUmVzcG9uc2l2ZU1lbnUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZU1lbnUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlTWVudSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmVzcG9uc2l2ZU1lbnUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmVNZW51LCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVNZW51XFxuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMucnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtbWVudScpO1xcbiAgICAgIHRoaXMuY3VycmVudE1xID0gbnVsbDtcXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4gPSBudWxsO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Jlc3BvbnNpdmVNZW51JzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgTWVudSBieSBwYXJzaW5nIHRoZSBjbGFzc2VzIGZyb20gdGhlICdkYXRhLVJlc3BvbnNpdmVNZW51JyBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpOyAvLyBUaGUgZmlyc3QgdGltZSBhbiBJbnRlcmNoYW5nZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQsIHRoaXMucnVsZXMgaXMgY29udmVydGVkIGZyb20gYSBzdHJpbmcgb2YgXFxcImNsYXNzZXNcXFwiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xcblxcblxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ydWxlcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTsgLy8gUGFyc2UgcnVsZXMgZnJvbSBcXFwiY2xhc3Nlc1xcXCIgcHVsbGVkIGZyb20gZGF0YSBhdHRyaWJ1dGVcXG5cXG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTsgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHJ1bGUgZm91bmRcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xcbiAgICAgICAgICB2YXIgcnVsZVNpemUgPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzBdIDogJ3NtYWxsJztcXG4gICAgICAgICAgdmFyIHJ1bGVQbHVnaW4gPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzFdIDogcnVsZVswXTtcXG5cXG4gICAgICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXNUcmVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5pc0VtcHR5T2JqZWN0KHRoaXMucnVsZXMpKSB7XFxuICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xcbiAgICAgIH0gLy8gQWRkIGRhdGEtbXV0YXRlIHNpbmNlIGNoaWxkcmVuIG1heSBuZWVkIGl0LlxcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1tdXRhdGUnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJykgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ3Jlc3BvbnNpdmUtbWVudScpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgTWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XFxuICAgICAgfSk7IC8vICQod2luZG93KS5vbigncmVzaXplLnpmLlJlc3BvbnNpdmVNZW51JywgZnVuY3Rpb24oKSB7XFxuICAgICAgLy8gICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICAvLyB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfY2hlY2tNZWRpYVF1ZXJpZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTWVkaWFRdWVyaWVzKCkge1xcbiAgICAgIHZhciBtYXRjaGVkTXEsXFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXFxuXFxuXFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgaWYgKF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uYXRMZWFzdChrZXkpKSB7XFxuICAgICAgICAgIG1hdGNoZWRNcSA9IGtleTtcXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcXG5cXG4gICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuOyAvLyBQbHVnaW4gYWxyZWFkeSBpbml0aWFsaXplZD8gV2UgZ29vZFxcblxcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKSByZXR1cm47IC8vIFJlbW92ZSBleGlzdGluZyBwbHVnaW4tc3BlY2lmaWMgQ1NTIGNsYXNzZXNcXG5cXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZWFjaChNZW51UGx1Z2lucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHZhbHVlLmNzc0NsYXNzKTtcXG4gICAgICB9KTsgLy8gQWRkIHRoZSBDU1MgY2xhc3MgZm9yIHRoZSBuZXcgcGx1Z2luXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpOyAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cXG5cXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG5ldyB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQsIHt9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZignLnpmLlJlc3BvbnNpdmVNZW51Jyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBSZXNwb25zaXZlTWVudTtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5SZXNwb25zaXZlTWVudS5kZWZhdWx0cyA9IHt9O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBSZXNwb25zaXZlVG9nZ2xlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXNwb25zaXZlVG9nZ2xlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubW90aW9uICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUmVzcG9uc2l2ZVRvZ2dsZSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGVcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqL1xcblxcbnZhciBSZXNwb25zaXZlVG9nZ2xlID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhSZXNwb25zaXZlVG9nZ2xlLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVUb2dnbGUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlVG9nZ2xlKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSZXNwb25zaXZlVG9nZ2xlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlVG9nZ2xlLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZVRvZ2dsZVxcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhdHRhY2ggdGFiIGJhciBmdW5jdGlvbmFsaXR5IHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlVG9nZ2xlJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFiIGJhciBieSBmaW5kaW5nIHRoZSB0YXJnZXQgZWxlbWVudCwgdG9nZ2xpbmcgZWxlbWVudCwgYW5kIHJ1bm5pbmcgdXBkYXRlKCkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHZhciB0YXJnZXRJRCA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS10b2dnbGUnKTtcXG5cXG4gICAgICBpZiAoIXRhcmdldElEKSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKCdZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJHRhcmdldE1lbnUgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdCh0YXJnZXRJRCkpO1xcbiAgICAgIHRoaXMuJHRvZ2dsZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRvZ2dsZV0nKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHRhcmdldCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCd0b2dnbGUnKTtcXG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IHRhcmdldElEIHx8IHRhcmdldCA9PT0gXFxcIlxcXCI7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLiR0YXJnZXRNZW51LmRhdGEoKSk7IC8vIElmIHRoZXkgd2VyZSBzZXQsIHBhcnNlIHRoZSBhbmltYXRpb24gY2xhc3Nlc1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSkge1xcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5vcHRpb25zLmFuaW1hdGUuc3BsaXQoJyAnKTtcXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSW4gPSBpbnB1dFswXTtcXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uT3V0ID0gaW5wdXRbMV0gfHwgbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgdGFiIGJhciB0byB3b3JrLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuX3VwZGF0ZU1xSGFuZGxlciA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xcbiAgICAgIHRoaXMuJHRvZ2dsZXIub24oJ2NsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGUnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl91cGRhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcXG4gICAgICAvLyBNb2JpbGVcXG4gICAgICBpZiAoIV9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2hvdygpO1xcbiAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS5oaWRlKCk7XFxuICAgICAgfSAvLyBEZXNrdG9wXFxuICAgICAgZWxzZSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LnNob3coKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgZWxlbWVudCBhdHRhY2hlZCB0byB0aGUgdGFiIGJhci4gVGhlIHRvZ2dsZSBvbmx5IGhhcHBlbnMgaWYgdGhlIHNjcmVlbiBpcyBzbWFsbCBlbm91Z2ggdG8gYWxsb3cgaXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSN0b2dnbGVkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVNZW51XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCFfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIgdG9nZ2xlcy5cXG4gICAgICAgICAqIEBldmVudCBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuICAgICAgICAgIGlmICh0aGlzLiR0YXJnZXRNZW51LmlzKCc6aGlkZGVuJykpIHtcXG4gICAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJNb3Rpb25cXFwiXS5hbmltYXRlSW4odGhpcy4kdGFyZ2V0TWVudSwgdGhpcy5hbmltYXRpb25JbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMyLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMyLiR0YXJnZXRNZW51LmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVPdXQodGhpcy4kdGFyZ2V0TWVudSwgdGhpcy5hbmltYXRpb25PdXQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS50b2dnbGUoMCk7XFxuICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XFxuICAgICAgdGhpcy4kdG9nZ2xlci5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUmVzcG9uc2l2ZVRvZ2dsZTtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5SZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBUaGUgYnJlYWtwb2ludCBhZnRlciB3aGljaCB0aGUgbWVudSBpcyBhbHdheXMgc2hvd24sIGFuZCB0aGUgdGFiIGJhciBpcyBoaWRkZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcXG4gICAqL1xcbiAgaGlkZUZvcjogJ21lZGl1bScsXFxuXFxuICAvKipcXG4gICAqIFRvIGRlY2lkZSBpZiB0aGUgdG9nZ2xlIHNob3VsZCBiZSBhbmltYXRlZCBvciBub3QuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFuaW1hdGU6IGZhbHNlXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24ucmV2ZWFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnJldmVhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFJldmVhbCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUmV2ZWFsXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXZlYWw7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5ICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24gKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudG91Y2ggKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUmV2ZWFsIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmV2ZWFsXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb24gaWYgdXNpbmcgYW5pbWF0aW9uc1xcbiAqL1xcblxcbnZhciBSZXZlYWwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFJldmVhbCwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBSZXZlYWwoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXZlYWwpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJldmVhbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUmV2ZWFsLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXZlYWwuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBSZXZlYWxcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBmb3IgdGhlIG1vZGFsLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbmFsIHBhcmFtZXRlcnMuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBSZXZlYWwuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXZlYWwnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7IC8vIFRvdWNoIGFuZCBUcmlnZ2VycyBpbml0IGFyZSBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIGluaXRpYWxpemVkXFxuXFxuXFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJUb3VjaFxcXCJdLmluaXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignUmV2ZWFsJywge1xcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGFsIGJ5IGFkZGluZyB0aGUgb3ZlcmxheSBhbmQgY2xvc2UgYnV0dG9ucywgKGlmIHNlbGVjdGVkKS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLmlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLmNhY2hlZCA9IHtcXG4gICAgICAgIG1xOiBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiTWVkaWFRdWVyeVxcXCJdLmN1cnJlbnRcXG4gICAgICB9O1xcbiAgICAgIHRoaXMuJGFuY2hvciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtb3Blbj1cXFxcXFxcIlxcXCIuY29uY2F0KHRoaXMuaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSkubGVuZ3RoID8ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS1vcGVuPVxcXFxcXFwiXFxcIi5jb25jYXQodGhpcy5pZCwgXFxcIlxcXFxcXFwiXVxcXCIpKSA6IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtdG9nZ2xlPVxcXFxcXFwiXFxcIi5jb25jYXQodGhpcy5pZCwgXFxcIlxcXFxcXFwiXVxcXCIpKTtcXG4gICAgICB0aGlzLiRhbmNob3IuYXR0cih7XFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IHRoaXMuaWQsXFxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXFxuICAgICAgICAndGFiaW5kZXgnOiAwXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Z1bGwnKSkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gPSB0cnVlO1xcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJsYXkgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5ICYmICF0aGlzLiRvdmVybGF5KSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5ID0gdGhpcy5fbWFrZU92ZXJsYXkodGhpcy5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAncm9sZSc6ICdkaWFsb2cnLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogdGhpcy5pZCxcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IHRoaXMuaWRcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy4kb3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyhqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcy5vcHRpb25zLmFwcGVuZFRvKSk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCd3aXRob3V0LW92ZXJsYXknKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gXFxcIiNcXFwiLmNvbmNhdCh0aGlzLmlkKSkge1xcbiAgICAgICAgdGhpcy5vbkxvYWRMaXN0ZW5lciA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIm9uTG9hZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm9wZW4oKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBvdmVybGF5IGRpdiB0byBkaXNwbGF5IGJlaGluZCB0aGUgbW9kYWwuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfbWFrZU92ZXJsYXlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VPdmVybGF5KCkge1xcbiAgICAgIHZhciBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMgPSAnJztcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFkZGl0aW9uYWxPdmVybGF5Q2xhc3Nlcykge1xcbiAgICAgICAgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzID0gJyAnICsgdGhpcy5vcHRpb25zLmFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncmV2ZWFsLW92ZXJsYXknICsgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzKS5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuYXBwZW5kVG8pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGVzIHBvc2l0aW9uIG9mIG1vZGFsXFxuICAgICAqIFRPRE86ICBGaWd1cmUgb3V0IGlmIHdlIGFjdHVhbGx5IG5lZWQgdG8gY2FjaGUgdGhlc2UgdmFsdWVzIG9yIGlmIGl0IGRvZXNuJ3QgbWF0dGVyXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfdXBkYXRlUG9zaXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBvc2l0aW9uKCkge1xcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpO1xcbiAgICAgIHZhciBvdXRlcldpZHRoID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykud2lkdGgoKTtcXG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpO1xcbiAgICAgIHZhciBvdXRlckhlaWdodCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLmhlaWdodCgpO1xcbiAgICAgIHZhciBsZWZ0LFxcbiAgICAgICAgICB0b3AgPSBudWxsO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaE9mZnNldCA9PT0gJ2F1dG8nKSB7XFxuICAgICAgICBsZWZ0ID0gcGFyc2VJbnQoKG91dGVyV2lkdGggLSB3aWR0aCkgLyAyLCAxMCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxlZnQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuaE9mZnNldCwgMTApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZPZmZzZXQgPT09ICdhdXRvJykge1xcbiAgICAgICAgaWYgKGhlaWdodCA+IG91dGVySGVpZ2h0KSB7XFxuICAgICAgICAgIHRvcCA9IHBhcnNlSW50KE1hdGgubWluKDEwMCwgb3V0ZXJIZWlnaHQgLyAxMCksIDEwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRvcCA9IHBhcnNlSW50KChvdXRlckhlaWdodCAtIGhlaWdodCkgLyA0LCAxMCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudk9mZnNldCAhPT0gbnVsbCkge1xcbiAgICAgICAgdG9wID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnZPZmZzZXQsIDEwKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRvcCAhPT0gbnVsbCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICB0b3A6IHRvcCArICdweCdcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gLy8gb25seSB3b3JyeSBhYm91dCBsZWZ0IGlmIHdlIGRvbid0IGhhdmUgYW4gb3ZlcmxheSBvciB3ZSBoYXZlIGEgaG9yaXpvbnRhbCBvZmZzZXQsXFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlJ3JlIHBlcmZlY3RseSBpbiB0aGUgbWlkZGxlXFxuXFxuXFxuICAgICAgaWYgKCF0aGlzLiRvdmVybGF5IHx8IHRoaXMub3B0aW9ucy5oT2Zmc2V0ICE9PSAnYXV0bycpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgbGVmdDogbGVmdCArICdweCdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICBtYXJnaW46ICcwcHgnXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtb2RhbC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xcbiAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiBmdW5jdGlvbiBjbG9zZVpmVHJpZ2dlcihldmVudCwgJGVsZW1lbnQpIHtcXG4gICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGV2ZW50LnRhcmdldCkucGFyZW50cygnW2RhdGEtY2xvc2FibGVdJylbMF0gPT09ICRlbGVtZW50KSB7XFxuICAgICAgICAgICAgLy8gb25seSBjbG9zZSByZXZlYWwgd2hlbiBpdCdzIGV4cGxpY2l0bHkgY2FsbGVkXFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5jbG9zZS5hcHBseShfdGhpczMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogZnVuY3Rpb24gcmVzaXplbWVaZlRyaWdnZXIoKSB7XFxuICAgICAgICAgIF90aGlzLl91cGRhdGVQb3NpdGlvbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmIHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5Lm9mZignLnpmLnJldmVhbCcpLm9uKCdjbGljay56Zi5kcm9wZG93biB0YXAuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpIHx8ICFqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKFxcXCJoYXNoY2hhbmdlLnpmLnJldmVhbDpcXFwiLmNvbmNhdCh0aGlzLmlkKSwgdGhpcy5faGFuZGxlU3RhdGUuYmluZCh0aGlzKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGVzIG1vZGFsIG1ldGhvZHMgb24gYmFjay9mb3J3YXJkIGJ1dHRvbiBjbGlja3Mgb3IgYW55IG90aGVyIGV2ZW50IHRoYXQgdHJpZ2dlcnMgaGFzaGNoYW5nZS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9oYW5kbGVTdGF0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3RhdGUoZSkge1xcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gJyMnICsgdGhpcy5pZCAmJiAhdGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogRGlzYWJsZXMgdGhlIHNjcm9sbCB3aGVuIFJldmVhbCBpcyBzaG93biB0byBwcmV2ZW50IHRoZSBiYWNrZ3JvdW5kIGZyb20gc2hpZnRpbmdcXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsVG9wIC0gU2Nyb2xsIHRvIHZpc3VhbGx5IGFwcGx5LCB3aW5kb3cgY3VycmVudCBzY3JvbGwgYnkgZGVmYXVsdFxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGlzYWJsZVNjcm9sbFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzYWJsZVNjcm9sbChzY3JvbGxUb3ApIHtcXG4gICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgfHwganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykuc2Nyb2xsVG9wKCk7XFxuXFxuICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudCkuaGVpZ2h0KCkgPiBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5oZWlnaHQoKSkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJodG1sXFxcIikuY3NzKFxcXCJ0b3BcXFwiLCAtc2Nyb2xsVG9wKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogUmVlbmFibGVzIHRoZSBzY3JvbGwgd2hlbiBSZXZlYWwgY2xvc2VzXFxuICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFRvcCAtIFNjcm9sbCB0byByZXN0b3JlLCBodG1sIFxcXCJ0b3BcXFwiIHByb3BlcnR5IGJ5IGRlZmF1bHQgKGFzIHNldCBieSBgX2Rpc2FibGVTY3JvbGxgKVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZW5hYmxlU2Nyb2xsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbmFibGVTY3JvbGwoc2Nyb2xsVG9wKSB7XFxuICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIHx8IHBhcnNlSW50KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiaHRtbFxcXCIpLmNzcyhcXFwidG9wXFxcIikpO1xcblxcbiAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQpLmhlaWdodCgpID4ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykuaGVpZ2h0KCkpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiaHRtbFxcXCIpLmNzcyhcXFwidG9wXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykuc2Nyb2xsVG9wKC1zY3JvbGxUb3ApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogT3BlbnMgdGhlIG1vZGFsIGNvbnRyb2xsZWQgYnkgYHRoaXMuJGFuY2hvcmAsIGFuZCBjbG9zZXMgYWxsIG90aGVycyBieSBkZWZhdWx0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIFJldmVhbCNjbG9zZW1lXFxuICAgICAqIEBmaXJlcyBSZXZlYWwjb3BlblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwib3BlblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xcblxcbiAgICAgIC8vIGVpdGhlciB1cGRhdGUgb3IgcmVwbGFjZSBicm93c2VyIGhpc3RvcnlcXG4gICAgICB2YXIgaGFzaCA9IFxcXCIjXFxcIi5jb25jYXQodGhpcy5pZCk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCAhPT0gaGFzaCkge1xcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBoYXNoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBoYXNoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gUmVtZW1iZXIgYW5jaG9yIHRoYXQgb3BlbmVkIGl0IHRvIHNldCBmb2N1cyBiYWNrIGxhdGVyLCBoYXZlIGdlbmVyYWwgYW5jaG9ycyBhcyBmYWxsYmFja1xcblxcblxcbiAgICAgIHRoaXMuJGFjdGl2ZUFuY2hvciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcyh0aGlzLiRhbmNob3IpID8ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIDogdGhpcy4kYW5jaG9yO1xcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlOyAvLyBNYWtlIGVsZW1lbnRzIGludmlzaWJsZSwgYnV0IHJlbW92ZSBkaXNwbGF5OiBub25lIHNvIHdlIGNhbiBnZXQgc2l6ZSBhbmQgcG9zaXRpb25pbmdcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XFxuICAgICAgICAndmlzaWJpbGl0eSc6ICdoaWRkZW4nXFxuICAgICAgfSkuc2hvdygpLnNjcm9sbFRvcCgwKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHtcXG4gICAgICAgICAgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJ1xcbiAgICAgICAgfSkuc2hvdygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLmNzcyh7XFxuICAgICAgICAndmlzaWJpbGl0eSc6ICcnXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHtcXG4gICAgICAgICAgJ3Zpc2liaWxpdHknOiAnJ1xcbiAgICAgICAgfSkuaGlkZSgpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Zhc3QnKSkge1xcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdmYXN0Jyk7XFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3Nsb3cnKSkge1xcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdzbG93Jyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlT3BlbmVkKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgbW9kYWwgb3BlbnMuXFxuICAgICAgICAgKiBDbG9zZXMgYW55IG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgb3BlblxcbiAgICAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZW1lXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5yZXZlYWwnLCB0aGlzLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnLnJldmVhbDp2aXNpYmxlJykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgcmV2ZWFsXFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb25Jbikge1xcbiAgICAgICAgdmFyIGFmdGVyQW5pbWF0aW9uID0gZnVuY3Rpb24gYWZ0ZXJBbmltYXRpb24oKSB7XFxuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxcbiAgICAgICAgICAgICd0YWJpbmRleCc6IC0xXFxuICAgICAgICAgIH0pLmZvY3VzKCk7XFxuXFxuICAgICAgICAgIF90aGlzLl9hZGRHbG9iYWxDbGFzc2VzKCk7XFxuXFxuICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS50cmFwRm9jdXMoX3RoaXMuJGVsZW1lbnQpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgICBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJNb3Rpb25cXFwiXS5hbmltYXRlSW4odGhpcy4kb3ZlcmxheSwgJ2ZhZGUtaW4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKF90aGlzNC4kZWxlbWVudCkge1xcbiAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCBvYmplY3QgaGF2aW5nIGJlZW4gcmVtb3ZlZFxcbiAgICAgICAgICAgIF90aGlzNC5mb2N1c2FibGVFbGVtZW50cyA9IF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS5maW5kRm9jdXNhYmxlKF90aGlzNC4kZWxlbWVudCk7XFxuICAgICAgICAgICAgYWZ0ZXJBbmltYXRpb24oKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyBqUXVlcnkgbWV0aG9kIG9mIHJldmVhbFxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LnNob3coMCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5zaG93KHRoaXMub3B0aW9ucy5zaG93RGVsYXkpO1xcbiAgICAgICAgfSAvLyBoYW5kbGUgYWNjZXNzaWJpbGl0eVxcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZSxcXG4gICAgICAgICd0YWJpbmRleCc6IC0xXFxuICAgICAgfSkuZm9jdXMoKTtcXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0udHJhcEZvY3VzKHRoaXMuJGVsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2FkZEdsb2JhbENsYXNzZXMoKTtcXG5cXG4gICAgICB0aGlzLl9hZGRHbG9iYWxMaXN0ZW5lcnMoKTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBoYXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cXG4gICAgICAgKiBAZXZlbnQgUmV2ZWFsI29wZW5cXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYucmV2ZWFsJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgY2xhc3NlcyBhbmQgbGlzdGVuZXJzIG9uIGRvY3VtZW50IHJlcXVpcmVkIGJ5IG9wZW4gbW9kYWxzLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNsYXNzZXMgYXJlIGFkZGVkIGFuZCB1cGRhdGVkOlxcbiAgICAgKiAtIGAuaXMtcmV2ZWFsLW9wZW5gIC0gUHJldmVudHMgdGhlIHNjcm9sbCBvbiBkb2N1bWVudFxcbiAgICAgKiAtIGAuemYtaGFzLXNjcm9sbGAgIC0gRGlzcGxheXMgYSBkaXNhYmxlZCBzY3JvbGxiYXIgb24gZG9jdW1lbnQgaWYgcmVxdWlyZWQgbGlrZSBpZiB0aGVcXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbCB3YXMgbm90IGRpc2FibGVkLiBUaGlzIHByZXZlbnQgYSBcXFwic2hpZnRcXFwiIG9mIHRoZSBwYWdlIGNvbnRlbnQgZHVlXFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgc2Nyb2xsYmFyIGRpc2FwcGVhcmluZyB3aGVuIHRoZSBtb2RhbCBvcGVucy5cXG4gICAgICpcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hZGRHbG9iYWxDbGFzc2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRHbG9iYWxDbGFzc2VzKCkge1xcbiAgICAgIHZhciB1cGRhdGVTY3JvbGxiYXJDbGFzcyA9IGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhckNsYXNzKCkge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sJykudG9nZ2xlQ2xhc3MoJ3pmLWhhcy1zY3JvbGwnLCAhIShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZG9jdW1lbnQpLmhlaWdodCgpID4ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykuaGVpZ2h0KCkpKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXIucmV2ZWFsU2Nyb2xsYmFyTGlzdGVuZXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdXBkYXRlU2Nyb2xsYmFyQ2xhc3MoKTtcXG4gICAgICB9KTtcXG4gICAgICB1cGRhdGVTY3JvbGxiYXJDbGFzcygpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCcpLmFkZENsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGNsYXNzZXMgYW5kIGxpc3RlbmVycyBvbiBkb2N1bWVudCB0aGF0IHdlcmUgcmVxdWlyZWQgYnkgb3BlbiBtb2RhbHMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVtb3ZlR2xvYmFsQ2xhc3Nlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlR2xvYmFsQ2xhc3NlcygpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlci5yZXZlYWxTY3JvbGxiYXJMaXN0ZW5lcicpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCcpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCcpLnJlbW92ZUNsYXNzKCd6Zi1oYXMtc2Nyb2xsJyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXh0cmEgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBib2R5IGFuZCB3aW5kb3cgaWYgbmVjZXNzYXJ5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEdsb2JhbExpc3RlbmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkR2xvYmFsTGlzdGVuZXJzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGNsZWFudXAsIGRvbid0IGZyZWFrIG91dFxcblxcblxcbiAgICAgIHRoaXMuZm9jdXNhYmxlRWxlbWVudHMgPSBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0uZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgIXRoaXMub3B0aW9ucy5mdWxsU2NyZWVuKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2JvZHknKS5vbignY2xpY2suemYuZHJvcGRvd24gdGFwLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSB8fCAhanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNvbnRhaW5zKGRvY3VtZW50LCBlLnRhcmdldCkpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ1JldmVhbCcsIHtcXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIHRoZSBtb2RhbC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjbG9zZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiBoaWRpbmdcXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkge1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSwgJ2ZhZGUtb3V0Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJNb3Rpb25cXFwiXS5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQsIGZpbmlzaFVwKTtcXG4gICAgICB9IC8vIGpRdWVyeSBtZXRob2Qgb2YgaGlkaW5nXFxuICAgICAgZWxzZSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSh0aGlzLm9wdGlvbnMuaGlkZURlbGF5KTtcXG5cXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKDAsIGZpbmlzaFVwKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmaW5pc2hVcCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIENvbmRpdGlvbmFscyB0byByZW1vdmUgZXh0cmEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkIG9uIG9wZW5cXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2JvZHknKS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duIHRhcC56Zi5kcm9wZG93bicpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcXG5cXG4gICAgICBmdW5jdGlvbiBmaW5pc2hVcCgpIHtcXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0b3AgYmVmb3JlIHRoZSBtb2RhbCBpcyBjbG9zZWQgYW5kIHJlc3RvcmUgdGhlIHNjcm9sbCBhZnRlci5cXG4gICAgICAgIC8vIFRPRE86IHVzZSBjb21wb25lbnQgcHJvcGVydGllcyBpbnN0ZWFkIG9mIEhUTUwgcHJvcGVydGllc1xcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3VuZGF0aW9uL2ZvdW5kYXRpb24tc2l0ZXMvcHVsbC8xMDc4NlxcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHBhcnNlSW50KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiaHRtbFxcXCIpLmNzcyhcXFwidG9wXFxcIikpO1xcblxcbiAgICAgICAgaWYgKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnLnJldmVhbDp2aXNpYmxlJykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgIF90aGlzLl9yZW1vdmVHbG9iYWxDbGFzc2VzKCk7IC8vIGFsc28gcmVtb3ZlIC5pcy1yZXZlYWwtb3BlbiBmcm9tIHRoZSBodG1sIGVsZW1lbnQgd2hlbiB0aGVyZSBpcyBubyBvcGVuZWQgcmV2ZWFsXFxuXFxuICAgICAgICB9XFxuXFxuICAgICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0ucmVsZWFzZUZvY3VzKF90aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuXFxuICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCcucmV2ZWFsOnZpc2libGUnKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgX3RoaXMuX2VuYWJsZVNjcm9sbChzY3JvbGxUb3ApO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRvbmUgY2xvc2luZy5cXG4gICAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZWRcXG4gICAgICAgICovXFxuXFxuXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYucmV2ZWFsJyk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICogUmVzZXRzIHRoZSBtb2RhbCBjb250ZW50XFxuICAgICAgKiBUaGlzIHByZXZlbnRzIGEgcnVubmluZyB2aWRlbyB0byBrZWVwIGdvaW5nIGluIHRoZSBiYWNrZ3JvdW5kXFxuICAgICAgKi9cXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlOyAvLyBJZiBkZWVwTGluayBhbmQgd2UgZGlkIG5vdCBzd2l0Y2hlZCB0byBhbiBvdGhlciBtb2RhbC4uLlxcblxcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSBcXFwiI1xcXCIuY29uY2F0KHRoaXMuaWQpKSB7XFxuICAgICAgICAvLyBSZW1vdmUgdGhlIGhpc3RvcnkgaGFzaFxcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xcbiAgICAgICAgICB2YXIgdXJsV2l0aG91dEhhc2ggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCB1cmxXaXRob3V0SGFzaCk7IC8vIHJlbW92ZSB0aGUgaGFzaFxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSgnJywgZG9jdW1lbnQudGl0bGUsIHVybFdpdGhvdXRIYXNoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kYWN0aXZlQW5jaG9yLmZvY3VzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGEgbW9kYWwuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9nZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLm9wZW4oKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZFRvKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLm9wdGlvbnMuYXBwZW5kVG8pKTsgLy8gbW92ZSAkZWxlbWVudCBvdXRzaWRlIG9mICRvdmVybGF5IHRvIHByZXZlbnQgZXJyb3IgdW5yZWdpc3RlclBsdWdpbigpXFxuXFxuICAgICAgICB0aGlzLiRvdmVybGF5LmhpZGUoKS5vZmYoKS5yZW1vdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCkub2ZmKCk7XFxuICAgICAgdGhpcy4kYW5jaG9yLm9mZignLnpmJyk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKFxcXCIuemYucmV2ZWFsOlxcXCIuY29uY2F0KHRoaXMuaWQpKTtcXG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xcblxcbiAgICAgIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJy5yZXZlYWw6dmlzaWJsZScpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhpcy5fcmVtb3ZlR2xvYmFsQ2xhc3NlcygpOyAvLyBhbHNvIHJlbW92ZSAuaXMtcmV2ZWFsLW9wZW4gZnJvbSB0aGUgaHRtbCBlbGVtZW50IHdoZW4gdGhlcmUgaXMgbm8gb3BlbmVkIHJldmVhbFxcblxcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFJldmVhbDtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5SZXZlYWwuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIE1vdGlvbi1VSSBjbGFzcyB0byB1c2UgZm9yIGFuaW1hdGVkIGVsZW1lbnRzLiBJZiBub25lIHVzZWQsIGRlZmF1bHRzIHRvIHNpbXBsZSBzaG93L2hpZGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgYW5pbWF0aW9uSW46ICcnLFxcblxcbiAgLyoqXFxuICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGFuaW1hdGlvbk91dDogJycsXFxuXFxuICAvKipcXG4gICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgb3BlbmluZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICBzaG93RGVsYXk6IDAsXFxuXFxuICAvKipcXG4gICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgY2xvc2luZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICBoaWRlRGVsYXk6IDAsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5L292ZXJsYXkgdG8gY2xvc2UgdGhlIG1vZGFsLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNsb3NlT25DbGljazogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBjbG9zZSBpZiB0aGUgdXNlciBwcmVzc2VzIHRoZSBgRVNDQVBFYCBrZXkuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgY2xvc2VPbkVzYzogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogSWYgdHJ1ZSwgYWxsb3dzIG11bHRpcGxlIG1vZGFscyB0byBiZSBkaXNwbGF5ZWQgYXQgb25jZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgbXVsdGlwbGVPcGVuZWQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggZG93biBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgYXV0b1xcbiAgICovXFxuICB2T2Zmc2V0OiAnYXV0bycsXFxuXFxuICAvKipcXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSBtb2RhbCBzaG91bGQgcHVzaCBpbiBmcm9tIHRoZSBzaWRlIG9mIHRoZSBzY3JlZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cXG4gICAqIEBkZWZhdWx0IGF1dG9cXG4gICAqL1xcbiAgaE9mZnNldDogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGJlIGZ1bGxzY3JlZW4sIGNvbXBsZXRlbHkgYmxvY2tpbmcgb3V0IHRoZSByZXN0IG9mIHRoZSB2aWV3LiBKUyBjaGVja3MgZm9yIHRoaXMgYXMgd2VsbC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZnVsbFNjcmVlbjogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gZ2VuZXJhdGUgYW4gb3ZlcmxheSBkaXYsIHdoaWNoIHdpbGwgY292ZXIgdGhlIHZpZXcgd2hlbiBtb2RhbCBvcGVucy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBvdmVybGF5OiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIHJlbW92ZSBhbmQgcmVpbmplY3QgbWFya3VwIG9uIGNsb3NlLiBTaG91bGQgYmUgdHJ1ZSBpZiB1c2luZyB2aWRlbyBlbGVtZW50cyB3L28gdXNpbmcgcHJvdmlkZXIncyBhcGksIG90aGVyd2lzZSwgdmlkZW9zIHdpbGwgY29udGludWUgdG8gcGxheSBpbiB0aGUgYmFja2dyb3VuZC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgcmVzZXRPbkNsb3NlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogTGluayB0aGUgbG9jYXRpb24gaGFzaCB0byB0aGUgbW9kYWwuXFxuICAgKiBTZXQgdGhlIGxvY2F0aW9uIGhhc2ggd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkL2Nsb3NlZCwgYW5kIG9wZW4vY2xvc2UgdGhlIG1vZGFsIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRlZXBMaW5rOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogSWYgYGRlZXBMaW5rYCBpcyBlbmFibGVkLCB1cGRhdGUgdGhlIGJyb3dzZXIgaGlzdG9yeSB3aXRoIHRoZSBvcGVuIG1vZGFsXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICB1cGRhdGVIaXN0b3J5OiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGFwcGVuZCB0byBjdXN0b20gZGl2LlxcbiAgKiBAb3B0aW9uXFxuICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0IFxcXCJib2R5XFxcIlxcbiAgKi9cXG4gIGFwcGVuZFRvOiBcXFwiYm9keVxcXCIsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBhZGRpbmcgYWRkaXRpb25hbCBjbGFzcyBuYW1lcyB0byB0aGUgcmV2ZWFsIG92ZXJsYXkuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzOiAnJ1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5yZXZlYWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uc2xpZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnNsaWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFNsaWRlciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiU2xpZGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTbGlkZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24gKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLnRvdWNoICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBTbGlkZXIgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zbGlkZXJcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxcbiAqL1xcblxcbnZhciBTbGlkZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFNsaWRlciwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBTbGlkZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNsaWRlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHNsaWRlciBjb250cm9sLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgU2xpZGVyXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBzbGlkZXIgY29udHJvbC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgU2xpZGVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU2xpZGVyJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuICAgICAgLy8gVG91Y2ggYW5kIFRyaWdnZXJzIGluaXRzIGFyZSBpZGVtcG90ZW50LCB3ZSBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgaW5pdGlhbGllZC5cXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcIlRvdWNoXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5yZWdpc3RlcignU2xpZGVyJywge1xcbiAgICAgICAgJ2x0cic6IHtcXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX1VQJzogJ2luY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX0RPV04nOiAnZGVjcmVhc2UnLFxcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICdkZWNyZWFzZScsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdpbmNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1VQJzogJ2luY3JlYXNlX2Zhc3QnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfRE9XTic6ICdkZWNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnZGVjcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdIT01FJzogJ21pbicsXFxuICAgICAgICAgICdFTkQnOiAnbWF4J1xcbiAgICAgICAgfSxcXG4gICAgICAgICdydGwnOiB7XFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ2luY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlJyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnaW5jcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdkZWNyZWFzZV9mYXN0J1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWxpemVzIHRoZSBwbHVnaW4gYnkgcmVhZGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMsIGNyZWF0aW5nIGNvbGxlY3Rpb25zIGFuZCBzZXR0aW5nIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUocykuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XFxuICAgICAgdGhpcy5oYW5kbGVzID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItaGFuZGxlXScpO1xcbiAgICAgIHRoaXMuJGhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSgwKTtcXG4gICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuaW5wdXRzLmxlbmd0aCA/IHRoaXMuaW5wdXRzLmVxKDApIDoganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIjXFxcIi5jb25jYXQodGhpcy4kaGFuZGxlLmF0dHIoJ2FyaWEtY29udHJvbHMnKSkpO1xcbiAgICAgIHRoaXMuJGZpbGwgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXNsaWRlci1maWxsXScpLmNzcyh0aGlzLm9wdGlvbnMudmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsIDApO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuaW5wdXRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoKS5hZGQodGhpcy4kaW5wdXQpO1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmJpbmRpbmcgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zZXRJbml0QXR0cigwKTtcXG5cXG4gICAgICBpZiAodGhpcy5oYW5kbGVzWzFdKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy4kaGFuZGxlMiA9IHRoaXMuaGFuZGxlcy5lcSgxKTtcXG4gICAgICAgIHRoaXMuJGlucHV0MiA9IHRoaXMuaW5wdXRzLmxlbmd0aCA+IDEgPyB0aGlzLmlucHV0cy5lcSgxKSA6IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiI1xcXCIuY29uY2F0KHRoaXMuJGhhbmRsZTIuYXR0cignYXJpYS1jb250cm9scycpKSk7XFxuXFxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzWzFdKSB7XFxuICAgICAgICAgIHRoaXMuaW5wdXRzID0gdGhpcy5pbnB1dHMuYWRkKHRoaXMuJGlucHV0Mik7XFxuICAgICAgICB9IC8vIHRoaXMuJGhhbmRsZS50cmlnZ2VySGFuZGxlcignY2xpY2suemYuc2xpZGVyJyk7XFxuXFxuXFxuICAgICAgICB0aGlzLl9zZXRJbml0QXR0cigxKTtcXG4gICAgICB9IC8vIFNldCBoYW5kbGUgcG9zaXRpb25zXFxuXFxuXFxuICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2V0SGFuZGxlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIYW5kbGVzKCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcXG4gICAgICAgIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMuaW5wdXRzLmVxKDApLnZhbCgpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzMi5fc2V0SGFuZGxlUG9zKF90aGlzMi4kaGFuZGxlMiwgX3RoaXMyLmlucHV0cy5lcSgxKS52YWwoKSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5pbnB1dHMuZXEoMCkudmFsKCkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVmbG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBmbG9hdGluZyBwb2ludCAodGhlIHZhbHVlKSB0byBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0byBhIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHRoZSBzbGlkZXIgKHRoZSBpbnZlcnNlIG9mIF92YWx1ZSlcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3BjdE9mQmFyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wY3RPZkJhcih2YWx1ZSkge1xcbiAgICAgIHZhciBwY3RPZkJhciA9IHBlcmNlbnQodmFsdWUgLSB0aGlzLm9wdGlvbnMuc3RhcnQsIHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpO1xcblxcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xcbiAgICAgICAgY2FzZSBcXFwicG93XFxcIjpcXG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9sb2dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxvZ1xcXCI6XFxuICAgICAgICAgIHBjdE9mQmFyID0gdGhpcy5fcG93VHJhbnNmb3JtKHBjdE9mQmFyKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwY3RPZkJhci50b0ZpeGVkKDIpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHBjdE9mQmFyIC0gZmxvYXRpbmcgcG9pbnQsIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgc2xpZGVyICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHRvIGEgdmFsdWVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3ZhbHVlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWx1ZShwY3RPZkJhcikge1xcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xcbiAgICAgICAgY2FzZSBcXFwicG93XFxcIjpcXG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wb3dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxvZ1xcXCI6XFxuICAgICAgICAgIHBjdE9mQmFyID0gdGhpcy5fbG9nVHJhbnNmb3JtKHBjdE9mQmFyKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB2YWx1ZTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsKSB7XFxuICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aGljaCBpcyB3b3JraW5nIHdpdGggbmVnYXRpdmUgdmFsdWVzIGZvciBzdGFydFxcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvMTAxOTA4NFxcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy5lbmQpICsgcGN0T2ZCYXIgKiAodGhpcy5vcHRpb25zLnN0YXJ0IC0gdGhpcy5vcHRpb25zLmVuZCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhbHVlID0gKHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpICogcGN0T2ZCYXIgKyBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy5zdGFydCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBsb2cgZnVuY3Rpb25cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2xvZ1RyYW5zZm9ybVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nVHJhbnNmb3JtKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VMb2codGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UsIHZhbHVlICogKHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlIC0gMSkgKyAxKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBwb3dlciBmdW5jdGlvblxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcG93VHJhbnNmb3JtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3dUcmFuc2Zvcm0odmFsdWUpIHtcXG4gICAgICByZXR1cm4gKE1hdGgucG93KHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlLCB2YWx1ZSkgLSAxKSAvICh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSAtIDEpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgaGFuZGxlIGFuZCBmaWxsIGJhci5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaG5kbCAtIHRoZSBzZWxlY3RlZCBoYW5kbGUgdG8gbW92ZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gZmxvYXRpbmcgcG9pbnQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgb2YgdGhlIHNsaWRlciBiYXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBvbiBjb21wbGV0aW9uLlxcbiAgICAgKiBAZmlyZXMgU2xpZGVyI21vdmVkXFxuICAgICAqIEBmaXJlcyBTbGlkZXIjY2hhbmdlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldEhhbmRsZVBvc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SGFuZGxlUG9zKCRobmRsLCBsb2NhdGlvbiwgY2IpIHtcXG4gICAgICAvLyBkb24ndCBtb3ZlIGlmIHRoZSBzbGlkZXIgaGFzIGJlZW4gZGlzYWJsZWQgc2luY2UgaXRzIGluaXRpYWxpemF0aW9uXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXFxuXFxuXFxuICAgICAgbG9jYXRpb24gPSBwYXJzZUZsb2F0KGxvY2F0aW9uKTsgLy9vbiBpbnB1dCBjaGFuZ2UgZXZlbnRzLCBjb252ZXJ0IHN0cmluZyB0byBudW1iZXIuLi5ncnVtYmxlLlxcbiAgICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzLCBpZiB2YWx1ZSBleGNlZWRzIHRoZSBsaW1pdHMgc2V0IHRocm91Z2ggb3B0aW9ucywgb3ZlcnJpZGUgdGhlIHZhbHVlIHRvIG1pbi9tYXhcXG5cXG4gICAgICBpZiAobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLnN0YXJ0O1xcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gPiB0aGlzLm9wdGlvbnMuZW5kKSB7XFxuICAgICAgICBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5lbmQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBpc0RibCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZDtcXG5cXG4gICAgICBpZiAoaXNEYmwpIHtcXG4gICAgICAgIC8vdGhpcyBibG9jayBpcyB0byBwcmV2ZW50IDIgaGFuZGxlcyBmcm9tIGNyb3NzaW5nIGVhY2hvdGhlci4gQ291bGQvc2hvdWxkIGJlIGltcHJvdmVkLlxcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDApIHtcXG4gICAgICAgICAgdmFyIGgyVmFsID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XFxuICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPj0gaDJWYWwgPyBoMlZhbCAtIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgaDFWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xcbiAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICB2ZXJ0ID0gdGhpcy5vcHRpb25zLnZlcnRpY2FsLFxcbiAgICAgICAgICBoT3JXID0gdmVydCA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcXG4gICAgICAgICAgbE9yVCA9IHZlcnQgPyAndG9wJyA6ICdsZWZ0JyxcXG4gICAgICAgICAgaGFuZGxlRGltID0gJGhuZGxbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaE9yV10sXFxuICAgICAgICAgIGVsZW1EaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxcbiAgICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIG1pbi9tYXggdmFsdWUgYmFzZWQgb24gY2xpY2sgb3IgZHJhZyBwb2ludFxcbiAgICAgIHBjdE9mQmFyID0gdGhpcy5fcGN0T2ZCYXIobG9jYXRpb24pLFxcbiAgICAgICAgICAvL251bWJlciBvZiBhY3R1YWwgcGl4ZWxzIHRvIHNoaWZ0IHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9idGFpbmVkIGFib3ZlXFxuICAgICAgcHhUb01vdmUgPSAoZWxlbURpbSAtIGhhbmRsZURpbSkgKiBwY3RPZkJhcixcXG4gICAgICAgICAgLy9wZXJjZW50YWdlIG9mIGJhciB0byBzaGlmdCB0aGUgaGFuZGxlXFxuICAgICAgbW92ZW1lbnQgPSAocGVyY2VudChweFRvTW92ZSwgZWxlbURpbSkgKiAxMDApLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpOyAvL2ZpeGluZyB0aGUgZGVjaW1hbCB2YWx1ZSBmb3IgdGhlIGxvY2F0aW9uIG51bWJlciwgaXMgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMgYXMgYSBmaXhlZCBmbG9hdGluZy1wb2ludCB2YWx1ZVxcblxcblxcbiAgICAgIGxvY2F0aW9uID0gcGFyc2VGbG9hdChsb2NhdGlvbi50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7IC8vIGRlY2xhcmUgZW1wdHkgb2JqZWN0IGZvciBjc3MgYWRqdXN0bWVudHMsIG9ubHkgdXNlZCB3aXRoIDIgaGFuZGxlZC1zbGlkZXJzXFxuXFxuICAgICAgdmFyIGNzcyA9IHt9O1xcblxcbiAgICAgIHRoaXMuX3NldFZhbHVlcygkaG5kbCwgbG9jYXRpb24pOyAvLyBUT0RPIHVwZGF0ZSB0byBjYWxjdWxhdGUgYmFzZWQgb24gdmFsdWVzIHNldCB0byByZXNwZWN0aXZlIGlucHV0cz8/XFxuXFxuXFxuICAgICAgaWYgKGlzRGJsKSB7XFxuICAgICAgICB2YXIgaXNMZWZ0SG5kbCA9IHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDAsXFxuICAgICAgICAgICAgLy9lbXB0eSB2YXJpYWJsZSwgd2lsbCBiZSB1c2VkIGZvciBtaW4taGVpZ2h0L3dpZHRoIGZvciBmaWxsIGJhclxcbiAgICAgICAgZGltLFxcbiAgICAgICAgICAgIC8vcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBjb21wYXJlZCB0byB0aGUgc2xpZGVyIGJhclxcbiAgICAgICAgaGFuZGxlUGN0ID0gfn4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTsgLy9pZiBsZWZ0IGhhbmRsZSwgdGhlIG1hdGggaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gaWYgaXQncyB0aGUgcmlnaHQgaGFuZGxlLCBhbmQgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG5lZWRzIHRvIGJlIGNoYW5nZWQgZm9yIHRoZSBmaWxsIGJhclxcblxcbiAgICAgICAgaWYgKGlzTGVmdEhuZGwpIHtcXG4gICAgICAgICAgLy9sZWZ0IG9yIHRvcCBwZXJjZW50YWdlIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSBmaWxsIGJhci5cXG4gICAgICAgICAgY3NzW2xPclRdID0gXFxcIlxcXCIuY29uY2F0KG1vdmVtZW50LCBcXFwiJVxcXCIpOyAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci5cXG5cXG4gICAgICAgICAgZGltID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2xPclRdKSAtIG1vdmVtZW50ICsgaGFuZGxlUGN0OyAvL3RoaXMgY2FsbGJhY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgZXJyb3JzIGFuZCBhbGxvdyB0aGUgcHJvcGVyIHBsYWNlbWVudCBhbmQgaW5pdGlhbGl6YXRpb24gb2YgYSAyLWhhbmRsZWQgc2xpZGVyXFxuICAgICAgICAgIC8vcGx1cywgaXQgbWVhbnMgd2UgZG9uJ3QgY2FyZSBpZiAnZGltJyBpc05hTiBvbiBpbml0LCBpdCB3b24ndCBiZSBpbiB0aGUgZnV0dXJlLlxcblxcbiAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2IoKTtcXG4gICAgICAgICAgfSAvL3RoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBvZiAyIGhhbmRsZWQgc2xpZGVyc1xcblxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9qdXN0IGNhY2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0L2JvdHRvbSBoYW5kbGUncyBsZWZ0L3RvcCBwcm9wZXJ0eVxcbiAgICAgICAgICB2YXIgaGFuZGxlUG9zID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGVbMF0uc3R5bGVbbE9yVF0pOyAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci4gVXNlIGlzTmFOIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIGZvciBudW1iZXJzIDw9IDBcXG4gICAgICAgICAgLy9iYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvZiBtb3ZlbWVudCBvZiB0aGUgaGFuZGxlIGJlaW5nIG1hbmlwdWxhdGVkLCBsZXNzIHRoZSBvcHBvc2luZyBoYW5kbGUncyBsZWZ0L3RvcCBwb3NpdGlvbiwgcGx1cyB0aGUgcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBpdHNlbGZcXG5cXG4gICAgICAgICAgZGltID0gbW92ZW1lbnQgLSAoaXNOYU4oaGFuZGxlUG9zKSA/ICh0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAvICgodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkgLyAxMDApIDogaGFuZGxlUG9zKSArIGhhbmRsZVBjdDtcXG4gICAgICAgIH0gLy8gYXNzaWduIHRoZSBtaW4taGVpZ2h0L3dpZHRoIHRvIG91ciBjc3Mgb2JqZWN0XFxuXFxuXFxuICAgICAgICBjc3NbXFxcIm1pbi1cXFwiLmNvbmNhdChoT3JXKV0gPSBcXFwiXFxcIi5jb25jYXQoZGltLCBcXFwiJVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGFuZGxlIGlzIGRvbmUgbW92aW5nLlxcbiAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdtb3ZlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcXG4gICAgICB9KTsgLy9iZWNhdXNlIHdlIGRvbid0IGtub3cgZXhhY3RseSBob3cgdGhlIGhhbmRsZSB3aWxsIGJlIG1vdmVkLCBjaGVjayB0aGUgYW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gbW92ZS5cXG5cXG4gICAgICB2YXIgbW92ZVRpbWUgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJykgPyAxMDAwIC8gNjAgOiB0aGlzLm9wdGlvbnMubW92ZVRpbWU7XFxuICAgICAgT2JqZWN0KF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1vdmVcXFwiXSkobW92ZVRpbWUsICRobmRsLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBhZGp1c3RpbmcgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIGNhbGN1bGF0ZWQgYWJvdmVcXG4gICAgICAgIC8vIGlmIG1vdmVtZW50IGlzTmFOLCB0aGF0IGlzIGJlY2F1c2UgdGhlIHNsaWRlciBpcyBoaWRkZW4gYW5kIHdlIGNhbm5vdCBkZXRlcm1pbmUgaGFuZGxlIHdpZHRoLFxcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG5leHQgYmVzdCBndWVzcy5cXG4gICAgICAgIGlmIChpc05hTihtb3ZlbWVudCkpIHtcXG4gICAgICAgICAgJGhuZGwuY3NzKGxPclQsIFxcXCJcXFwiLmNvbmNhdChwY3RPZkJhciAqIDEwMCwgXFxcIiVcXFwiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkaG5kbC5jc3MobE9yVCwgXFxcIlxcXCIuY29uY2F0KG1vdmVtZW50LCBcXFwiJVxcXCIpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xcbiAgICAgICAgICAvL2lmIHNpbmdsZS1oYW5kbGVkLCBhIHNpbXBsZSBtZXRob2QgdG8gZXhwYW5kIHRoZSBmaWxsIGJhclxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoaE9yVywgXFxcIlxcXCIuY29uY2F0KHBjdE9mQmFyICogMTAwLCBcXFwiJVxcXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vb3RoZXJ3aXNlLCB1c2UgdGhlIGNzcyBvYmplY3Qgd2UgY3JlYXRlZCBhYm92ZVxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoY3NzKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSB2YWx1ZSBoYXMgbm90IGJlZW4gY2hhbmdlIGZvciBhIGdpdmVuIHRpbWUuXFxuICAgICAgICogQGV2ZW50IFNsaWRlciNjaGFuZ2VkXFxuICAgICAgICovXFxuXFxuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XFxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5jaGFuZ2VkRGVsYXkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBpbml0aWFsIGF0dHJpYnV0ZSBmb3IgdGhlIHNsaWRlciBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSBjdXJyZW50IGhhbmRsZS9pbnB1dCB0byB1c2UuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0SW5pdEF0dHJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEluaXRBdHRyKGlkeCkge1xcbiAgICAgIHZhciBpbml0VmFsID0gaWR4ID09PSAwID8gdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCA6IHRoaXMub3B0aW9ucy5pbml0aWFsRW5kO1xcbiAgICAgIHZhciBpZCA9IHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cignaWQnKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnc2xpZGVyJyk7XFxuICAgICAgdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKHtcXG4gICAgICAgICdpZCc6IGlkLFxcbiAgICAgICAgJ21heCc6IHRoaXMub3B0aW9ucy5lbmQsXFxuICAgICAgICAnbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxcbiAgICAgICAgJ3N0ZXAnOiB0aGlzLm9wdGlvbnMuc3RlcFxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKGluaXRWYWwpO1xcbiAgICAgIHRoaXMuaGFuZGxlcy5lcShpZHgpLmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXFxuICAgICAgICAnYXJpYS12YWx1ZW1heCc6IHRoaXMub3B0aW9ucy5lbmQsXFxuICAgICAgICAnYXJpYS12YWx1ZW1pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcXG4gICAgICAgICdhcmlhLXZhbHVlbm93JzogaW5pdFZhbCxcXG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogdGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcXG4gICAgICAgICd0YWJpbmRleCc6IDBcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgaW5wdXQgYW5kIGBhcmlhLXZhbHVlbm93YCB2YWx1ZXMgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBoYW5kbGUuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBvZiB0aGUgbmV3IHZhbHVlLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFZhbHVlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVzKCRoYW5kbGUsIHZhbCkge1xcbiAgICAgIHZhciBpZHggPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPyB0aGlzLmhhbmRsZXMuaW5kZXgoJGhhbmRsZSkgOiAwO1xcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKHZhbCk7XFxuICAgICAgJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JywgdmFsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIHNsaWRlciBlbGVtZW50LlxcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgaGFuZGxlLlxcbiAgICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGNhbGN1bGF0ZSBmb3IsIGlmIHNlbGVjdGVkLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGZvciB0aGUgbmV3IHZhbHVlIG9mIHRoZSBzbGlkZXIuXFxuICAgICAqIFRPRE8gY2xlYW4gdGhpcyB1cCwgdGhlcmUncyBhIGxvdCBvZiByZXBlYXRlZCBjb2RlIGJldHdlZW4gdGhpcyBhbmQgdGhlIF9zZXRIYW5kbGVQb3MgZm4uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfaGFuZGxlRXZlbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUV2ZW50KGUsICRoYW5kbGUsIHZhbCkge1xcbiAgICAgIHZhciB2YWx1ZSwgaGFzVmFsO1xcblxcbiAgICAgIGlmICghdmFsKSB7XFxuICAgICAgICAvL2NsaWNrIG9yIGRyYWcgZXZlbnRzXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgIHZlcnRpY2FsID0gdGhpcy5vcHRpb25zLnZlcnRpY2FsLFxcbiAgICAgICAgICAgIHBhcmFtID0gdmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcXG4gICAgICAgICAgICBldmVudE9mZnNldCA9IHZlcnRpY2FsID8gZS5wYWdlWSA6IGUucGFnZVgsXFxuICAgICAgICAgICAgYmFyRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0sXFxuICAgICAgICAgICAgd2luZG93U2Nyb2xsID0gdmVydGljYWwgPyBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5zY3JvbGxUb3AoKSA6IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLnNjcm9sbExlZnQoKTtcXG5cXG4gICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dOyAvLyB0b3VjaCBldmVudHMgZW11bGF0ZWQgYnkgdGhlIHRvdWNoIHV0aWwgZ2l2ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JlZW4sIGFkZCB3aW5kb3cuc2Nyb2xsIHRvIGV2ZW50IGNvb3JkaW5hdGVzLi4uXFxuICAgICAgICAvLyBiZXN0IHdheSB0byBndWVzcyB0aGlzIGlzIHNpbXVsYXRlZCBpcyBpZiBjbGllbnRZID09IHBhZ2VZXFxuXFxuICAgICAgICBpZiAoZS5jbGllbnRZID09PSBlLnBhZ2VZKSB7XFxuICAgICAgICAgIGV2ZW50T2Zmc2V0ID0gZXZlbnRPZmZzZXQgKyB3aW5kb3dTY3JvbGw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZXZlbnRGcm9tQmFyID0gZXZlbnRPZmZzZXQgLSBlbGVtT2Zmc2V0O1xcbiAgICAgICAgdmFyIGJhclhZO1xcblxcbiAgICAgICAgaWYgKGV2ZW50RnJvbUJhciA8IDApIHtcXG4gICAgICAgICAgYmFyWFkgPSAwO1xcbiAgICAgICAgfSBlbHNlIGlmIChldmVudEZyb21CYXIgPiBiYXJEaW0pIHtcXG4gICAgICAgICAgYmFyWFkgPSBiYXJEaW07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBiYXJYWSA9IGV2ZW50RnJvbUJhcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBvZmZzZXRQY3QgPSBwZXJjZW50KGJhclhZLCBiYXJEaW0pO1xcbiAgICAgICAgdmFsdWUgPSB0aGlzLl92YWx1ZShvZmZzZXRQY3QpOyAvLyB0dXJuIGV2ZXJ5dGhpbmcgYXJvdW5kIGZvciBSVEwsIHlheSBtYXRoIVxcblxcbiAgICAgICAgaWYgKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcInJ0bFxcXCJdKSgpICYmICF0aGlzLm9wdGlvbnMudmVydGljYWwpIHtcXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLm9wdGlvbnMuZW5kIC0gdmFsdWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YWx1ZSA9IF90aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWx1ZSk7IC8vYm9vbGVhbiBmbGFnIGZvciB0aGUgc2V0SGFuZGxlUG9zIGZuLCBzcGVjaWZpY2FsbHkgZm9yIHZlcnRpY2FsIHNsaWRlcnNcXG5cXG4gICAgICAgIGhhc1ZhbCA9IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKCEkaGFuZGxlKSB7XFxuICAgICAgICAgIC8vZmlndXJlIG91dCB3aGljaCBoYW5kbGUgaXQgaXMsIHBhc3MgaXQgdG8gdGhlIG5leHQgZnVuY3Rpb24uXFxuICAgICAgICAgIHZhciBmaXJzdEhuZGxQb3MgPSBhYnNQb3NpdGlvbih0aGlzLiRoYW5kbGUsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKSxcXG4gICAgICAgICAgICAgIHNlY25kSG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZTIsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKTtcXG4gICAgICAgICAgJGhhbmRsZSA9IGZpcnN0SG5kbFBvcyA8PSBzZWNuZEhuZGxQb3MgPyB0aGlzLiRoYW5kbGUgOiB0aGlzLiRoYW5kbGUyO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvL2NoYW5nZSBldmVudCBvbiBpbnB1dFxcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWwpO1xcbiAgICAgICAgaGFzVmFsID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKCRoYW5kbGUsIHZhbHVlKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRqdXN0ZXMgdmFsdWUgZm9yIGhhbmRsZSBpbiByZWdhcmQgdG8gc3RlcCB2YWx1ZS4gcmV0dXJucyBhZGp1c3RlZCB2YWx1ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgc2VsZWN0ZWQgaGFuZGxlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBhZGp1c3QuIHVzZWQgaWYgJGhhbmRsZSBpcyBmYWxzeVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkanVzdFZhbHVlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGp1c3RWYWx1ZSgkaGFuZGxlLCB2YWx1ZSkge1xcbiAgICAgIHZhciB2YWwsXFxuICAgICAgICAgIHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcCxcXG4gICAgICAgICAgZGl2ID0gcGFyc2VGbG9hdChzdGVwIC8gMiksXFxuICAgICAgICAgIGxlZnQsXFxuICAgICAgICAgIHByZXZfdmFsLFxcbiAgICAgICAgICBuZXh0X3ZhbDtcXG5cXG4gICAgICBpZiAoISEkaGFuZGxlKSB7XFxuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KCRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFsID0gdmFsdWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh2YWwgPj0gMCkge1xcbiAgICAgICAgbGVmdCA9IHZhbCAlIHN0ZXA7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxlZnQgPSBzdGVwICsgdmFsICUgc3RlcDtcXG4gICAgICB9XFxuXFxuICAgICAgcHJldl92YWwgPSB2YWwgLSBsZWZ0O1xcbiAgICAgIG5leHRfdmFsID0gcHJldl92YWwgKyBzdGVwO1xcblxcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7XFxuICAgICAgICByZXR1cm4gdmFsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YWwgPSB2YWwgPj0gcHJldl92YWwgKyBkaXYgPyBuZXh0X3ZhbCA6IHByZXZfdmFsO1xcbiAgICAgIHJldHVybiB2YWw7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzbGlkZXIgZWxlbWVudHMuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHRoaXMuX2V2ZW50c0ZvckhhbmRsZSh0aGlzLiRoYW5kbGUpO1xcblxcbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcXG4gICAgICAgIHRoaXMuX2V2ZW50c0ZvckhhbmRsZSh0aGlzLiRoYW5kbGUyKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGEgcGFydGljdWxhciBoYW5kbGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGFwcGx5IGxpc3RlbmVycyB0by5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNGb3JIYW5kbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50c0ZvckhhbmRsZSgkaGFuZGxlKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgY3VySGFuZGxlO1xcblxcbiAgICAgIHZhciBoYW5kbGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUV2ZW50KGUpIHtcXG4gICAgICAgIHZhciBpZHggPSBfdGhpcy5pbnB1dHMuaW5kZXgoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG5cXG4gICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy5oYW5kbGVzLmVxKGlkeCksIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS52YWwoKSk7XFxuICAgICAgfTsgLy8gSUUgb25seSB0cmlnZ2VycyB0aGUgY2hhbmdlIGV2ZW50IHdoZW4gdGhlIGlucHV0IGxvc2VzIGZvY3VzIHdoaWNoIHN0cmljdGx5IGZvbGxvd3MgdGhlIEhUTUwgc3BlY2lmaWNhdGlvblxcbiAgICAgIC8vIGxpc3RlbiBmb3IgdGhlIGVudGVyIGtleSBhbmQgdHJpZ2dlciBhIGNoYW5nZVxcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNjb21tb24taW5wdXQtZWxlbWVudC1ldmVudHNcXG5cXG5cXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2tleXVwLnpmLnNsaWRlcicpLm9uKCdrZXl1cC56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykgaGFuZGxlQ2hhbmdlRXZlbnQuY2FsbCh0aGlzLCBlKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGhhbmRsZUNoYW5nZUV2ZW50KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc2xpZGVyJykub24oJ2NsaWNrLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUudGFyZ2V0KS5pcygnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKSkge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy4kaGFuZGxlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xcbiAgICAgICAgdGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7XFxuICAgICAgICB2YXIgJGJvZHkgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJ2JvZHknKTtcXG4gICAgICAgICRoYW5kbGUub2ZmKCdtb3VzZWRvd24uemYuc2xpZGVyJykub24oJ21vdXNlZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAkaGFuZGxlLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpO1xcblxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTsgLy9cXG5cXG5cXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCB0cnVlKTtcXG5cXG4gICAgICAgICAgY3VySGFuZGxlID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGUuY3VycmVudFRhcmdldCk7XFxuICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuICAgICAgICAgIH0pLm9uKCdtb3VzZXVwLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuXFxuICAgICAgICAgICAgJGhhbmRsZS5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG5cXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIGZhbHNlKTtcXG5cXG4gICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXInKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KSAvLyBwcmV2ZW50IGV2ZW50cyB0cmlnZ2VyZWQgYnkgdG91Y2hcXG4gICAgICAgIC5vbignc2VsZWN0c3RhcnQuemYuc2xpZGVyIHRvdWNobW92ZS56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgJGhhbmRsZS5vZmYoJ2tleWRvd24uemYuc2xpZGVyJykub24oJ2tleWRvd24uemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciBfJGhhbmRsZSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICBpZHggPSBfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gX3RoaXMuaGFuZGxlcy5pbmRleChfJGhhbmRsZSkgOiAwLFxcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcGFyc2VGbG9hdChfdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwoKSksXFxuICAgICAgICAgICAgbmV3VmFsdWU7IC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG5cXG5cXG4gICAgICAgIF9mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiS2V5Ym9hcmRcXFwiXS5oYW5kbGVLZXkoZSwgJ1NsaWRlcicsIHtcXG4gICAgICAgICAgZGVjcmVhc2U6IGZ1bmN0aW9uIGRlY3JlYXNlKCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGluY3JlYXNlOiBmdW5jdGlvbiBpbmNyZWFzZSgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkZWNyZWFzZV9mYXN0OiBmdW5jdGlvbiBkZWNyZWFzZV9mYXN0KCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXAgKiAxMDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaW5jcmVhc2VfZmFzdDogZnVuY3Rpb24gaW5jcmVhc2VfZmFzdCgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIG1pbjogZnVuY3Rpb24gbWluKCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5zdGFydDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbWF4OiBmdW5jdGlvbiBtYXgoKSB7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcy5vcHRpb25zLmVuZDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICAvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICAvKmlmIChuZXdWYWx1ZSkgeyAvLyBpZiBwcmVzc2VkIGtleSBoYXMgc3BlY2lhbCBmdW5jdGlvbiwgdXBkYXRlIHZhbHVlXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUpO1xcbiAgICAgICAgfSovXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBzbGlkZXIgcGx1Z2luLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5oYW5kbGVzLm9mZignLnpmLnNsaWRlcicpO1xcbiAgICAgIHRoaXMuaW5wdXRzLm9mZignLnpmLnNsaWRlcicpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuc2xpZGVyJyk7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTbGlkZXI7XFxufShfZm91bmRhdGlvbl9jb3JlX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJQbHVnaW5cXFwiXSk7XFxuXFxuU2xpZGVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgc3RhcnQ6IDAsXFxuXFxuICAvKipcXG4gICAqIE1heGltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMTAwXFxuICAgKi9cXG4gIGVuZDogMTAwLFxcblxcbiAgLyoqXFxuICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDFcXG4gICAqL1xcbiAgc3RlcDogMSxcXG5cXG4gIC8qKlxcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIGhhbmRsZS9pbnB1dCAqKGxlZnQgaGFuZGxlL2ZpcnN0IGlucHV0KSogc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGluaXRpYWxTdGFydDogMCxcXG5cXG4gIC8qKlxcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIHJpZ2h0IGhhbmRsZS9zZWNvbmQgaW5wdXQgc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxMDBcXG4gICAqL1xcbiAgaW5pdGlhbEVuZDogMTAwLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGJpbmRpbmc6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gY2xpY2svdGFwIG9uIHRoZSBzbGlkZXIgYmFyIHRvIHNlbGVjdCBhIHZhbHVlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNsaWNrU2VsZWN0OiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBTZXQgdG8gdHJ1ZSBhbmQgdXNlIHRoZSBgdmVydGljYWxgIGNsYXNzIHRvIGNoYW5nZSBhbGlnbm1lbnQgdG8gdmVydGljYWwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHZlcnRpY2FsOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgZHJhZ2dhYmxlOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBEaXNhYmxlcyB0aGUgc2xpZGVyIGFuZCBwcmV2ZW50cyBldmVudCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBhcHBsaWVkLiBEb3VibGUgY2hlY2tlZCBieSBKUyB3aXRoIGBkaXNhYmxlZENsYXNzYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGlzYWJsZWQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHVzZSBvZiB0d28gaGFuZGxlcy4gRG91YmxlIGNoZWNrZWQgYnkgdGhlIEpTLiBDaGFuZ2VzIHNvbWUgbG9naWMgaGFuZGxpbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRvdWJsZVNpZGVkOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxcbiAgICovXFxuICAvLyBzdGVwczogMTAwLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhlIHBsdWdpbiBzaG91bGQgZ28gdG8gZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAyXFxuICAgKi9cXG4gIGRlY2ltYWw6IDIsXFxuXFxuICAvKipcXG4gICAqIFRpbWUgZGVsYXkgZm9yIGRyYWdnZWQgZWxlbWVudHMuXFxuICAgKi9cXG4gIC8vIGRyYWdEZWxheTogMCxcXG5cXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDIwMFxcbiAgICovXFxuICBtb3ZlVGltZTogMjAwLFxcbiAgLy91cGRhdGUgdGhpcyBpZiBjaGFuZ2luZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBzYXNzXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gZGlzYWJsZWQgc2xpZGVycy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnZGlzYWJsZWQnXFxuICAgKi9cXG4gIGRpc2FibGVkQ2xhc3M6ICdkaXNhYmxlZCcsXFxuXFxuICAvKipcXG4gICAqIFdpbGwgaW52ZXJ0IHRoZSBkZWZhdWx0IGxheW91dCBmb3IgYSB2ZXJ0aWNhbDxzcGFuIGRhdGEtdG9vbHRpcCB0aXRsZT1cXFwid2hvIHdvdWxkIGRvIHRoaXM/Pz9cXFwiPiA8L3NwYW4+c2xpZGVyLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBpbnZlcnRWZXJ0aWNhbDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIE1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIGBjaGFuZ2VkLnpmLXNsaWRlcmAgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHZhbHVlIGNoYW5nZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MDBcXG4gICAqL1xcbiAgY2hhbmdlZERlbGF5OiA1MDAsXFxuXFxuICAvKipcXG4gICogQmFzZXZhbHVlIGZvciBub24tbGluZWFyIHNsaWRlcnNcXG4gICogQG9wdGlvblxcbiAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgKiBAZGVmYXVsdCA1XFxuICAqL1xcbiAgbm9uTGluZWFyQmFzZTogNSxcXG5cXG4gIC8qKlxcbiAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVycywgcG9zc2libGUgdmFsdWVzIGFyZTogYCdsaW5lYXInYCwgYCdwb3cnYCAmIGAnbG9nJ2AuIFBvdyBhbmQgTG9nIHVzZSB0aGUgbm9uTGluZWFyQmFzZSBzZXR0aW5nLlxcbiAgKiBAb3B0aW9uXFxuICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdsaW5lYXInXFxuICAqL1xcbiAgcG9zaXRpb25WYWx1ZUZ1bmN0aW9uOiAnbGluZWFyJ1xcbn07XFxuXFxuZnVuY3Rpb24gcGVyY2VudChmcmFjLCBudW0pIHtcXG4gIHJldHVybiBmcmFjIC8gbnVtO1xcbn1cXG5cXG5mdW5jdGlvbiBhYnNQb3NpdGlvbigkaGFuZGxlLCBkaXIsIGNsaWNrUG9zLCBwYXJhbSkge1xcbiAgcmV0dXJuIE1hdGguYWJzKCRoYW5kbGUucG9zaXRpb24oKVtkaXJdICsgJGhhbmRsZVtwYXJhbV0oKSAvIDIgLSBjbGlja1Bvcyk7XFxufVxcblxcbmZ1bmN0aW9uIGJhc2VMb2coYmFzZSwgdmFsdWUpIHtcXG4gIHJldHVybiBNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZyhiYXNlKTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5zbGlkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uc21vb3RoU2Nyb2xsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnNtb290aFNjcm9sbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFNtb290aFNjcm9sbCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiU21vb3RoU2Nyb2xsXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTbW9vdGhTY3JvbGw7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS5wbHVnaW4gKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnBsdWdpbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cXG5cXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxcblxcblxcblxcblxcbi8qKlxcbiAqIFNtb290aFNjcm9sbCBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnNtb290aFNjcm9sbFxcbiAqL1xcblxcbnZhciBTbW9vdGhTY3JvbGwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFNtb290aFNjcm9sbCwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBTbW9vdGhTY3JvbGwoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbW9vdGhTY3JvbGwpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNtb290aFNjcm9sbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU21vb3RoU2Nyb2xsLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBTbW9vdGhTY3JvbGwuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBTbW9vdGhTY3JvbGxcXG4gICAgICogQGZpcmVzIFNtb290aFNjcm9sbCNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFNtb290aFNjcm9sbC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Ntb290aFNjcm9sbCc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgU21vb3RoU2Nyb2xsIHBsdWdpblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAnc21vb3RoLXNjcm9sbCcpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICBpZDogaWRcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBTbW9vdGhTY3JvbGwuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdGhpcy5fbGlua0NsaWNrTGlzdGVuZXIgPSB0aGlzLl9oYW5kbGVMaW5rQ2xpY2suYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay56Zi5zbW9vdGhTY3JvbGwnLCB0aGlzLl9saW5rQ2xpY2tMaXN0ZW5lcik7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suemYuc21vb3RoU2Nyb2xsJywgJ2FbaHJlZl49XFxcIiNcXFwiXScsIHRoaXMuX2xpbmtDbGlja0xpc3RlbmVyKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSGFuZGxlIHRoZSBnaXZlbiBldmVudCB0byBzbW9vdGhseSBzY3JvbGwgdG8gdGhlIGFuY2hvciBwb2ludGVkIGJ5IHRoZSBldmVudCB0YXJnZXQuXFxuICAgICAqIEBwYXJhbSB7Kn0gZSAtIGV2ZW50XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hhbmRsZUxpbmtDbGlja1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTGlua0NsaWNrKGUpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIC8vIEZvbGxvdyB0aGUgbGluayBpZiBpdCBkb2VzIG5vdCBwb2ludCB0byBhbiBhbmNob3IuXFxuICAgICAgaWYgKCFqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZS5jdXJyZW50VGFyZ2V0KS5pcygnYVtocmVmXj1cXFwiI1xcXCJdJykpIHJldHVybjtcXG4gICAgICB2YXIgYXJyaXZhbCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcXG4gICAgICB0aGlzLl9pblRyYW5zaXRpb24gPSB0cnVlO1xcbiAgICAgIFNtb290aFNjcm9sbC5zY3JvbGxUb0xvYyhhcnJpdmFsLCB0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLl9pblRyYW5zaXRpb24gPSBmYWxzZTtcXG4gICAgICB9KTtcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIFNtb290aFNjcm9sbCBpbnN0YW5jZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2NsaWNrLnpmLnNtb290aFNjcm9sbCcsIHRoaXMuX2xpbmtDbGlja0xpc3RlbmVyKTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc21vb3RoU2Nyb2xsJywgJ2FbaHJlZl49XFxcIiNcXFwiXScsIHRoaXMuX2xpbmtDbGlja0xpc3RlbmVyKTtcXG4gICAgfVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcInNjcm9sbFRvTG9jXFxcIixcXG5cXG4gICAgLyoqXFxuICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jIC0gQSBwcm9wZXJseSBmb3JtYXR0ZWQgalF1ZXJ5IGlkIHNlbGVjdG9yLiBFeGFtcGxlOiAnI2ZvbydcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2UuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxcbiAgICAgKiBAc3RhdGljXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFRvTG9jKGxvYykge1xcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTbW9vdGhTY3JvbGwuZGVmYXVsdHM7XFxuICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XFxuICAgICAgdmFyICRsb2MgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkobG9jKTsgLy8gRG8gbm90aGluZyBpZiB0YXJnZXQgZG9lcyBub3QgZXhpc3QgdG8gcHJldmVudCBlcnJvcnNcXG5cXG4gICAgICBpZiAoISRsb2MubGVuZ3RoKSByZXR1cm4gZmFsc2U7XFxuICAgICAgdmFyIHNjcm9sbFBvcyA9IE1hdGgucm91bmQoJGxvYy5vZmZzZXQoKS50b3AgLSBvcHRpb25zLnRocmVzaG9sZCAvIDIgLSBvcHRpb25zLm9mZnNldCk7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHtcXG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsUG9zXFxuICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgb3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFNtb290aFNjcm9sbDtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlBsdWdpblxcXCJdKTtcXG4vKipcXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW4uXFxuICovXFxuXFxuXFxuU21vb3RoU2Nyb2xsLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTAwXFxuICAgKi9cXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXFxuXFxuICAvKipcXG4gICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuIENhbiBiZSBgJ3N3aW5nJ2Agb3IgYCdsaW5lYXInYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnbGluZWFyJ1xcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpxdWVyeSBhbmltYXRlfVxcbiAgICovXFxuICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MFxcbiAgICovXFxuICB0aHJlc2hvbGQ6IDUwLFxcblxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIG9mZnNldCB0aGUgc2Nyb2xsIG9mIHRoZSBwYWdlIG9uIGl0ZW0gY2xpY2sgaWYgdXNpbmcgYSBzdGlja3kgbmF2IGJhci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIG9mZnNldDogMFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi5zbW9vdGhTY3JvbGwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24uc3RpY2t5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnN0aWNreS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFN0aWNreSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiU3RpY2t5XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTdGlja3k7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogU3RpY2t5IG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uc3RpY2t5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqL1xcblxcbnZhciBTdGlja3kgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFN0aWNreSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBTdGlja3koKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGlja3kpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFN0aWNreSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU3RpY2t5LCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHN0aWNreSB0aGluZy5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIFN0aWNreVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBzdGlja3kuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3QgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIGVsZW1lbnQgcHJvZ3JhbW1hdGljYWxseS5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFN0aWNreS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1N0aWNreSc7IC8vIGllOSBiYWNrIGNvbXBhdFxcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgc3RpY2t5IGVsZW1lbnQgYnkgYWRkaW5nIGNsYXNzZXMsIGdldHRpbmcvc2V0dGluZyBkaW1lbnNpb25zLCBicmVha3BvaW50cyBhbmQgYXR0cmlidXRlc1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9pbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJNZWRpYVF1ZXJ5XFxcIl0uX2luaXQoKTtcXG5cXG4gICAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdGlja3ktY29udGFpbmVyXScpLFxcbiAgICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiR2V0WW9EaWdpdHNcXFwiXSkoNiwgJ3N0aWNreScpLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCRwYXJlbnQubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkcGFyZW50O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLndhc1dyYXBwZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC53cmFwKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXFxuICAgICAgICAnZGF0YS1tdXRhdGUnOiBpZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9yICE9PSAnJykge1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCcjJyArIF90aGlzLm9wdGlvbnMuYW5jaG9yKS5hdHRyKHtcXG4gICAgICAgICAgJ2RhdGEtbXV0YXRlJzogaWRcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnNjcm9sbENvdW50ID0gdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XFxuICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XFxuICAgICAgdGhpcy5vbkxvYWRMaXN0ZW5lciA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIm9uTG9hZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy9XZSBjYWxjdWxhdGUgdGhlIGNvbnRhaW5lciBoZWlnaHQgdG8gaGF2ZSBjb3JyZWN0IHZhbHVlcyBmb3IgYW5jaG9yIHBvaW50cyBvZmZzZXQgY2FsY3VsYXRpb24uXFxuICAgICAgICBfdGhpcy5jb250YWluZXJIZWlnaHQgPSBfdGhpcy4kZWxlbWVudC5jc3MoXFxcImRpc3BsYXlcXFwiKSA9PSBcXFwibm9uZVxcXCIgPyAwIDogX3RoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcblxcbiAgICAgICAgX3RoaXMuJGNvbnRhaW5lci5jc3MoJ2hlaWdodCcsIF90aGlzLmNvbnRhaW5lckhlaWdodCk7XFxuXFxuICAgICAgICBfdGhpcy5lbGVtSGVpZ2h0ID0gX3RoaXMuY29udGFpbmVySGVpZ2h0O1xcblxcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYW5jaG9yICE9PSAnJykge1xcbiAgICAgICAgICBfdGhpcy4kYW5jaG9yID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCcjJyArIF90aGlzLm9wdGlvbnMuYW5jaG9yKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIF90aGlzLl9wYXJzZVBvaW50cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcXG5cXG4gICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHNjcm9sbCk7IC8vVW5zdGljayB0aGUgZWxlbWVudCB3aWxsIGVuc3VyZSB0aGF0IHByb3BlciBjbGFzc2VzIGFyZSBzZXQuXFxuXFxuXFxuICAgICAgICAgIGlmICghX3RoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVTdGlja3koc2Nyb2xsID49IF90aGlzLnRvcFBvaW50ID8gZmFsc2UgOiB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBfdGhpcy5fZXZlbnRzKGlkLnNwbGl0KCctJykucmV2ZXJzZSgpLmpvaW4oJy0nKSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIElmIHVzaW5nIG11bHRpcGxlIGVsZW1lbnRzIGFzIGFuY2hvcnMsIGNhbGN1bGF0ZXMgdGhlIHRvcCBhbmQgYm90dG9tIHBpeGVsIHZhbHVlcyB0aGUgc3RpY2t5IHRoaW5nIHNob3VsZCBzdGljayBhbmQgdW5zdGljayBvbi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcGFyc2VQb2ludHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUG9pbnRzKCkge1xcbiAgICAgIHZhciB0b3AgPSB0aGlzLm9wdGlvbnMudG9wQW5jaG9yID09IFxcXCJcXFwiID8gMSA6IHRoaXMub3B0aW9ucy50b3BBbmNob3IsXFxuICAgICAgICAgIGJ0bSA9IHRoaXMub3B0aW9ucy5idG1BbmNob3IgPT0gXFxcIlxcXCIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogdGhpcy5vcHRpb25zLmJ0bUFuY2hvcixcXG4gICAgICAgICAgcHRzID0gW3RvcCwgYnRtXSxcXG4gICAgICAgICAgYnJlYWtzID0ge307XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW4gJiYgcHRzW2ldOyBpKyspIHtcXG4gICAgICAgIHZhciBwdDtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgcHRzW2ldID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgICBwdCA9IHB0c1tpXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBwbGFjZSA9IHB0c1tpXS5zcGxpdCgnOicpLFxcbiAgICAgICAgICAgICAgYW5jaG9yID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIjXFxcIi5jb25jYXQocGxhY2VbMF0pKTtcXG4gICAgICAgICAgcHQgPSBhbmNob3Iub2Zmc2V0KCkudG9wO1xcblxcbiAgICAgICAgICBpZiAocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgICAgICBwdCArPSBhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBicmVha3NbaV0gPSBwdDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5wb2ludHMgPSBicmVha3M7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHBzZXVkby1yYW5kb20gaWQgZm9yIHVuaXF1ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoaWQpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBzY3JvbGxMaXN0ZW5lciA9IHRoaXMuc2Nyb2xsTGlzdGVuZXIgPSBcXFwic2Nyb2xsLnpmLlxcXCIuY29uY2F0KGlkKTtcXG5cXG4gICAgICBpZiAodGhpcy5pc09uKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmNhblN0aWNrKSB7XFxuICAgICAgICB0aGlzLmlzT24gPSB0cnVlO1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKS5vbihzY3JvbGxMaXN0ZW5lciwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKF90aGlzLnNjcm9sbENvdW50ID09PSAwKSB7XFxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQgPSBfdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50LS07XFxuXFxuICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpLm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUsIGVsKSB7XFxuICAgICAgICBfdGhpcy5fZXZlbnRzSGFuZGxlcihpZCk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlLCBlbCkge1xcbiAgICAgICAgX3RoaXMuX2V2ZW50c0hhbmRsZXIoaWQpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLiRhbmNob3IpIHtcXG4gICAgICAgIHRoaXMuJGFuY2hvci5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlLCBlbCkge1xcbiAgICAgICAgICBfdGhpcy5fZXZlbnRzSGFuZGxlcihpZCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEhhbmRsZXIgZm9yIGV2ZW50cy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gcHNldWRvLXJhbmRvbSBpZCBmb3IgdW5pcXVlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNIYW5kbGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHNIYW5kbGVyKGlkKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgc2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnNjcm9sbExpc3RlbmVyID0gXFxcInNjcm9sbC56Zi5cXFwiLmNvbmNhdChpZCk7XFxuXFxuICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcXG5cXG4gICAgICAgIGlmIChfdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgICBpZiAoIV90aGlzLmlzT24pIHtcXG4gICAgICAgICAgICBfdGhpcy5fZXZlbnRzKGlkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5pc09uKSB7XFxuICAgICAgICAgIF90aGlzLl9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlcnMgZm9yIHNjcm9sbCBhbmQgY2hhbmdlIGV2ZW50cyBvbiBhbmNob3IuXFxuICAgICAqIEBmaXJlcyBTdGlja3kjcGF1c2VcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNjcm9sbExpc3RlbmVyIC0gdW5pcXVlLCBuYW1lc3BhY2VkIHNjcm9sbCBsaXN0ZW5lciBhdHRhY2hlZCB0byBgd2luZG93YFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3BhdXNlTGlzdGVuZXJzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcikge1xcbiAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGlzIHBhdXNlZCBkdWUgdG8gcmVzaXplIGV2ZW50IHNocmlua2luZyB0aGUgdmlldy5cXG4gICAgICAgKiBAZXZlbnQgU3RpY2t5I3BhdXNlXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhdXNlLnpmLnN0aWNreScpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDYWxsZWQgb24gZXZlcnkgYHNjcm9sbGAgZXZlbnQgYW5kIG9uIGBfaW5pdGBcXG4gICAgICogZmlyZXMgZnVuY3Rpb25zIGJhc2VkIG9uIGJvb2xlYW5zIGFuZCBjYWNoZWQgdmFsdWVzXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTaXplcyAtIHRydWUgaWYgcGx1Z2luIHNob3VsZCByZWNhbGN1bGF0ZSBzaXplcyBhbmQgYnJlYWtwb2ludHMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGwgLSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwYXNzZWQgZnJvbSBzY3JvbGwgZXZlbnQgY2IgZnVuY3Rpb24uIElmIG5vdCBwYXNzZWQsIGRlZmF1bHRzIHRvIGB3aW5kb3cucGFnZVlPZmZzZXRgLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2NhbGNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGMoY2hlY2tTaXplcywgc2Nyb2xsKSB7XFxuICAgICAgaWYgKGNoZWNrU2l6ZXMpIHtcXG4gICAgICAgIHRoaXMuX3NldFNpemVzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc2Nyb2xsKSB7XFxuICAgICAgICBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzY3JvbGwgPj0gdGhpcy50b3BQb2ludCkge1xcbiAgICAgICAgaWYgKHNjcm9sbCA8PSB0aGlzLmJvdHRvbVBvaW50KSB7XFxuICAgICAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICAgICAgdGhpcy5fc2V0U3RpY2t5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3koZmFsc2UpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgc3R1Y2suXFxuICAgICAqIEFkZHMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXFxuICAgICAqIEBmaXJlcyBTdGlja3kjc3R1Y2t0b1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zZXRTdGlja3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0aWNreSgpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXFxuICAgICAgICAgIG1yZ24gPSBzdGlja1RvID09PSAndG9wJyA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXFxuICAgICAgICAgIG5vdFN0dWNrVG8gPSBzdGlja1RvID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCcsXFxuICAgICAgICAgIGNzcyA9IHt9O1xcblxcbiAgICAgIGNzc1ttcmduXSA9IFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnNbbXJnbl0sIFxcXCJlbVxcXCIpO1xcbiAgICAgIGNzc1tzdGlja1RvXSA9IDA7XFxuICAgICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xcbiAgICAgIHRoaXMuaXNTdHVjayA9IHRydWU7XFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtYW5jaG9yZWQgaXMtYXQtXFxcIi5jb25jYXQobm90U3R1Y2tUbykpLmFkZENsYXNzKFxcXCJpcy1zdHVjayBpcy1hdC1cXFwiLmNvbmNhdChzdGlja1RvKSkuY3NzKGNzcylcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGBwb3NpdGlvbjogZml4ZWQ7YFxcbiAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAsIGUuZy4gYHN0aWNreS56Zi5zdHVja3RvOnRvcGBcXG4gICAgICAgKiBAZXZlbnQgU3RpY2t5I3N0dWNrdG9cXG4gICAgICAgKi9cXG4gICAgICAudHJpZ2dlcihcXFwic3RpY2t5LnpmLnN0dWNrdG86XFxcIi5jb25jYXQoc3RpY2tUbykpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oXFxcInRyYW5zaXRpb25lbmQgd2Via2l0VHJhbnNpdGlvbkVuZCBvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCBNU1RyYW5zaXRpb25FbmRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgdW5zdHVjay5cXG4gICAgICogUmVtb3ZlcyBgcG9zaXRpb246IGZpeGVkO2AsIGFuZCBoZWxwZXIgY2xhc3Nlcy5cXG4gICAgICogQWRkcyBvdGhlciBoZWxwZXIgY2xhc3Nlcy5cXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1RvcCAtIHRlbGxzIHRoZSBmdW5jdGlvbiBpZiB0aGUgJGVsZW1lbnQgc2hvdWxkIGFuY2hvciB0byB0aGUgdG9wIG9yIGJvdHRvbSBvZiBpdHMgJGFuY2hvciBlbGVtZW50LlxcbiAgICAgKiBAZmlyZXMgU3RpY2t5I3Vuc3R1Y2tmcm9tXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfcmVtb3ZlU3RpY2t5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVTdGlja3koaXNUb3ApIHtcXG4gICAgICB2YXIgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxcbiAgICAgICAgICBzdGlja1RvVG9wID0gc3RpY2tUbyA9PT0gJ3RvcCcsXFxuICAgICAgICAgIGNzcyA9IHt9LFxcbiAgICAgICAgICBhbmNob3JQdCA9ICh0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIC0gdGhpcy5wb2ludHNbMF0gOiB0aGlzLmFuY2hvckhlaWdodCkgLSB0aGlzLmVsZW1IZWlnaHQsXFxuICAgICAgICAgIG1yZ24gPSBzdGlja1RvVG9wID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcXG4gICAgICAgICAgdG9wT3JCb3R0b20gPSBpc1RvcCA/ICd0b3AnIDogJ2JvdHRvbSc7XFxuICAgICAgY3NzW21yZ25dID0gMDtcXG4gICAgICBjc3NbJ2JvdHRvbSddID0gJ2F1dG8nO1xcblxcbiAgICAgIGlmIChpc1RvcCkge1xcbiAgICAgICAgY3NzWyd0b3AnXSA9IDA7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNzc1sndG9wJ10gPSBhbmNob3JQdDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIi5jb25jYXQoc3RpY2tUbykpLmFkZENsYXNzKFxcXCJpcy1hbmNob3JlZCBpcy1hdC1cXFwiLmNvbmNhdCh0b3BPckJvdHRvbSkpLmNzcyhjc3MpXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBhbmNob3JlZC5cXG4gICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYudW5zdHVja2Zyb206Ym90dG9tYFxcbiAgICAgICAqIEBldmVudCBTdGlja3kjdW5zdHVja2Zyb21cXG4gICAgICAgKi9cXG4gICAgICAudHJpZ2dlcihcXFwic3RpY2t5LnpmLnVuc3R1Y2tmcm9tOlxcXCIuY29uY2F0KHRvcE9yQm90dG9tKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXFxuICAgICAqIENhbGxzIGBfc2V0QnJlYWtQb2ludHNgLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9zZXRTaXplc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2l6ZXMoY2IpIHtcXG4gICAgICB0aGlzLmNhblN0aWNrID0gX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5pcyh0aGlzLm9wdGlvbnMuc3RpY2t5T24pO1xcblxcbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBjYigpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBuZXdFbGVtV2lkdGggPSB0aGlzLiRjb250YWluZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXFxuICAgICAgICAgIGNvbXAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pLFxcbiAgICAgICAgICBwZG5nbCA9IHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctbGVmdCddLCAxMCksXFxuICAgICAgICAgIHBkbmdyID0gcGFyc2VJbnQoY29tcFsncGFkZGluZy1yaWdodCddLCAxMCk7XFxuXFxuICAgICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLmFuY2hvckhlaWdodCA9IHRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX3BhcnNlUG9pbnRzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICdtYXgtd2lkdGgnOiBcXFwiXFxcIi5jb25jYXQobmV3RWxlbVdpZHRoIC0gcGRuZ2wgLSBwZG5nciwgXFxcInB4XFxcIilcXG4gICAgICB9KTsgLy8gUmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvbmx5IGlmIGl0IGlzIFxcXCJkeW5hbWljXFxcIlxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHluYW1pY0hlaWdodCB8fCAhdGhpcy5jb250YWluZXJIZWlnaHQpIHtcXG4gICAgICAgIC8vIEdldCB0aGUgc3RpY2tlZCBlbGVtZW50IGhlaWdodCBhbmQgYXBwbHkgaXQgdG8gdGhlIGNvbnRhaW5lciB0byBcXFwiaG9sZCB0aGUgcGxhY2VcXFwiXFxuICAgICAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XFxuICAgICAgICBuZXdDb250YWluZXJIZWlnaHQgPSB0aGlzLiRlbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpID09IFxcXCJub25lXFxcIiA/IDAgOiBuZXdDb250YWluZXJIZWlnaHQ7XFxuICAgICAgICB0aGlzLiRjb250YWluZXIuY3NzKCdoZWlnaHQnLCBuZXdDb250YWluZXJIZWlnaHQpO1xcbiAgICAgICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBuZXdDb250YWluZXJIZWlnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZWxlbUhlaWdodCA9IHRoaXMuY29udGFpbmVySGVpZ2h0O1xcblxcbiAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtYXQtYm90dG9tJykpIHtcXG4gICAgICAgICAgdmFyIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCkudG9wIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0O1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcygndG9wJywgYW5jaG9yUHQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zZXRCcmVha1BvaW50cyh0aGlzLmNvbnRhaW5lckhlaWdodCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBjYigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYnJlYWtwb2ludHMgZm9yIHRoZSBlbGVtZW50IHRvIGJlY29tZSBzdGlja3kvdW5zdGlja3kuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbGVtSGVpZ2h0IC0gcHggdmFsdWUgZm9yIHN0aWNreS4kZWxlbWVudCBoZWlnaHQsIGNhbGN1bGF0ZWQgYnkgYF9zZXRTaXplc2AuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfc2V0QnJlYWtQb2ludHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyZWFrUG9pbnRzKGVsZW1IZWlnaHQsIGNiKSB7XFxuICAgICAgaWYgKCF0aGlzLmNhblN0aWNrKSB7XFxuICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIGNiKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxcbiAgICAgICAgICBtQnRtID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Cb3R0b20pLFxcbiAgICAgICAgICB0b3BQb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMF0gOiB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wLFxcbiAgICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxcbiAgICAgICAgICAvLyB0b3BQb2ludCA9IHRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AgfHwgdGhpcy5wb2ludHNbMF0sXFxuICAgICAgLy8gYm90dG9tUG9pbnQgPSB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0IHx8IHRoaXMucG9pbnRzWzFdLFxcbiAgICAgIHdpbkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICd0b3AnKSB7XFxuICAgICAgICB0b3BQb2ludCAtPSBtVG9wO1xcbiAgICAgICAgYm90dG9tUG9pbnQgLT0gZWxlbUhlaWdodCArIG1Ub3A7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3RpY2tUbyA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHRvcFBvaW50IC09IHdpbkhlaWdodCAtIChlbGVtSGVpZ2h0ICsgbUJ0bSk7XFxuICAgICAgICBib3R0b21Qb2ludCAtPSB3aW5IZWlnaHQgLSBtQnRtO1xcbiAgICAgIH0gZWxzZSB7Ly90aGlzIHdvdWxkIGJlIHRoZSBzdGlja1RvOiBib3RoIG9wdGlvbi4uLiB0cmlja3lcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy50b3BQb2ludCA9IHRvcFBvaW50O1xcbiAgICAgIHRoaXMuYm90dG9tUG9pbnQgPSBib3R0b21Qb2ludDtcXG5cXG4gICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBjYigpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIGN1cnJlbnQgc3RpY2t5IGVsZW1lbnQuXFxuICAgICAqIFJlc2V0cyB0aGUgZWxlbWVudCB0byB0aGUgdG9wIHBvc2l0aW9uIGZpcnN0LlxcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2Rlc3Ryb3lcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcIlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcywgXFxcIiBpcy1hbmNob3JlZCBpcy1hdC10b3BcXFwiKSkuY3NzKHtcXG4gICAgICAgIGhlaWdodDogJycsXFxuICAgICAgICB0b3A6ICcnLFxcbiAgICAgICAgYm90dG9tOiAnJyxcXG4gICAgICAgICdtYXgtd2lkdGgnOiAnJ1xcbiAgICAgIH0pLm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpLm9mZignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcblxcbiAgICAgIGlmICh0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy4kYW5jaG9yLm9mZignY2hhbmdlLnpmLnN0aWNreScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zY3JvbGxMaXN0ZW5lcikganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRoaXMuc2Nyb2xsTGlzdGVuZXIpO1xcbiAgICAgIGlmICh0aGlzLm9uTG9hZExpc3RlbmVyKSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYodGhpcy5vbkxvYWRMaXN0ZW5lcik7XFxuXFxuICAgICAgaWYgKHRoaXMud2FzV3JhcHBlZCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC51bndyYXAoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtcXG4gICAgICAgICAgaGVpZ2h0OiAnJ1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gU3RpY2t5O1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcblN0aWNreS5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQ3VzdG9taXphYmxlIGNvbnRhaW5lciB0ZW1wbGF0ZS4gQWRkIHlvdXIgb3duIGNsYXNzZXMgZm9yIHN0eWxpbmcgYW5kIHNpemluZy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJmx0O2RpdiBkYXRhLXN0aWNreS1jb250YWluZXImZ3Q7Jmx0Oy9kaXYmZ3Q7J1xcbiAgICovXFxuICBjb250YWluZXI6ICc8ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lcj48L2Rpdj4nLFxcblxcbiAgLyoqXFxuICAgKiBMb2NhdGlvbiBpbiB0aGUgdmlldyB0aGUgZWxlbWVudCBzdGlja3MgdG8uIENhbiBiZSBgJ3RvcCdgIG9yIGAnYm90dG9tJ2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3RvcCdcXG4gICAqL1xcbiAgc3RpY2tUbzogJ3RvcCcsXFxuXFxuICAvKipcXG4gICAqIElmIGFuY2hvcmVkIHRvIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBpZCBvZiB0aGF0IGVsZW1lbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgYW5jaG9yOiAnJyxcXG5cXG4gIC8qKlxcbiAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgdG9wIGFuY2hvci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICB0b3BBbmNob3I6ICcnLFxcblxcbiAgLyoqXFxuICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSBib3R0b20gYW5jaG9yLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGJ0bUFuY2hvcjogJycsXFxuXFxuICAvKipcXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxXFxuICAgKi9cXG4gIG1hcmdpblRvcDogMSxcXG5cXG4gIC8qKlxcbiAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDFcXG4gICAqL1xcbiAgbWFyZ2luQm90dG9tOiAxLFxcblxcbiAgLyoqXFxuICAgKiBCcmVha3BvaW50IHN0cmluZyB0aGF0IGlzIHRoZSBtaW5pbXVtIHNjcmVlbiBzaXplIGFuIGVsZW1lbnQgc2hvdWxkIGJlY29tZSBzdGlja3kuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcXG4gICAqL1xcbiAgc3RpY2t5T246ICdtZWRpdW0nLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBlbGVtZW50LCBhbmQgcmVtb3ZlZCBvbiBkZXN0cnVjdGlvbi4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5YC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnc3RpY2t5J1xcbiAgICovXFxuICBzdGlja3lDbGFzczogJ3N0aWNreScsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGNvbnRhaW5lci4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5LWNvbnRhaW5lcmAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3N0aWNreS1jb250YWluZXInXFxuICAgKi9cXG4gIGNvbnRhaW5lckNsYXNzOiAnc3RpY2t5LWNvbnRhaW5lcicsXFxuXFxuICAvKipcXG4gICAqIElmIHRydWUgKGJ5IGRlZmF1bHQpLCBrZWVwIHRoZSBzdGlja3kgY29udGFpbmVyIHRoZSBzYW1lIGhlaWdodCBhcyB0aGUgZWxlbWVudC4gT3RoZXJ3aXNlLCB0aGUgY29udGFpbmVyIGhlaWdodCBpcyBzZXQgb25jZSBhbmQgZG9lcyBub3QgY2hhbmdlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGR5bmFtaWNIZWlnaHQ6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBzY3JvbGwgZXZlbnRzIGJldHdlZW4gdGhlIHBsdWdpbidzIHJlY2FsY3VsYXRpbmcgc3RpY2t5IHBvaW50cy4gU2V0dGluZyBpdCB0byBgMGAgd2lsbCBjYXVzZSBpdCB0byByZWNhbGMgZXZlcnkgc2Nyb2xsIGV2ZW50LCBzZXR0aW5nIGl0IHRvIGAtMWAgd2lsbCBwcmV2ZW50IHJlY2FsYyBvbiBzY3JvbGwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgLTFcXG4gICAqL1xcbiAgY2hlY2tFdmVyeTogLTFcXG59O1xcbi8qKlxcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZW0gdmFsdWVzXFxuICogQHBhcmFtIE51bWJlciB7ZW19IC0gbnVtYmVyIG9mIGVtJ3MgdG8gY2FsY3VsYXRlIGludG8gcGl4ZWxzXFxuICovXFxuXFxuZnVuY3Rpb24gZW1DYWxjKGVtKSB7XFxuICByZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSwgbnVsbCkuZm9udFNpemUsIDEwKSAqIGVtO1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnN0aWNreS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi50YWJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi50YWJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRhYnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRhYnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZCAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIgKi8gXFxcIi4vanMvZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogVGFicyBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRhYnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlciBpZiB0YWJzIGNvbnRhaW4gaW1hZ2VzXFxuICovXFxuXFxudmFyIFRhYnMgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFRhYnMsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gVGFicygpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYnMpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFRhYnMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFRhYnMsIFt7XFxuICAgIGtleTogXFxcIl9zZXR1cFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRhYnMuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBUYWJzXFxuICAgICAqIEBmaXJlcyBUYWJzI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byB0YWJzLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBUYWJzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnVGFicyc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcIktleWJvYXJkXFxcIl0ucmVnaXN0ZXIoJ1RhYnMnLCB7XFxuICAgICAgICAnRU5URVInOiAnb3BlbicsXFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXFxuICAgICAgICAnQVJST1dfVVAnOiAncHJldmlvdXMnLFxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnbmV4dCcsXFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycgLy8gJ1RBQic6ICduZXh0JyxcXG4gICAgICAgIC8vICdTSElGVF9UQUInOiAncHJldmlvdXMnXFxuXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSB0YWJzIGJ5IHNob3dpbmcgYW5kIGZvY3VzaW5nIChpZiBhdXRvRm9jdXM9dHJ1ZSkgdGhlIHByZXNldCBhY3RpdmUgdGFiLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IHRydWU7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3RhYmxpc3QnXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kdGFiVGl0bGVzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtDbGFzcykpO1xcbiAgICAgIHRoaXMuJHRhYkNvbnRlbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIltkYXRhLXRhYnMtY29udGVudD1cXFxcXFxcIlxcXCIuY29uY2F0KHRoaXMuJGVsZW1lbnRbMF0uaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgICAgdGhpcy4kdGFiVGl0bGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRlbGVtID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICRsaW5rID0gJGVsZW0uZmluZCgnYScpLFxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gJGVsZW0uaGFzQ2xhc3MoXFxcIlxcXCIuY29uY2F0KF90aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSksXFxuICAgICAgICAgICAgaGFzaCA9ICRsaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSB8fCAkbGlua1swXS5oYXNoLnNsaWNlKDEpLFxcbiAgICAgICAgICAgIGxpbmtJZCA9ICRsaW5rWzBdLmlkID8gJGxpbmtbMF0uaWQgOiBcXFwiXFxcIi5jb25jYXQoaGFzaCwgXFxcIi1sYWJlbFxcXCIpLFxcbiAgICAgICAgICAgICR0YWJDb250ZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIjXFxcIi5jb25jYXQoaGFzaCkpO1xcbiAgICAgICAgJGVsZW0uYXR0cih7XFxuICAgICAgICAgICdyb2xlJzogJ3ByZXNlbnRhdGlvbidcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJGxpbmsuYXR0cih7XFxuICAgICAgICAgICdyb2xlJzogJ3RhYicsXFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogaGFzaCxcXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBpc0FjdGl2ZSxcXG4gICAgICAgICAgJ2lkJzogbGlua0lkLFxcbiAgICAgICAgICAndGFiaW5kZXgnOiBpc0FjdGl2ZSA/ICcwJyA6ICctMSdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJHRhYkNvbnRlbnQuYXR0cih7XFxuICAgICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcXG4gICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxpbmtJZFxcbiAgICAgICAgfSk7IC8vIFNhdmUgdXAgdGhlIGluaXRpYWwgaGFzaCB0byByZXR1cm4gdG8gaXQgbGF0ZXIgd2hlbiBnb2luZyBiYWNrIGluIGhpc3RvcnlcXG5cXG4gICAgICAgIGlmIChpc0FjdGl2ZSkge1xcbiAgICAgICAgICBfdGhpcy5faW5pdGlhbEFuY2hvciA9IFxcXCIjXFxcIi5jb25jYXQoaGFzaCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XFxuICAgICAgICAgICR0YWJDb250ZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpc0FjdGl2ZSAmJiBfdGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xcbiAgICAgICAgICBfdGhpcy5vbkxvYWRMaXN0ZW5lciA9IE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIm9uTG9hZFxcXCJdKShqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiAkZWxlbS5vZmZzZXQoKS50b3BcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmRlZXBMaW5rU211ZGdlRGVsYXksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICRsaW5rLmZvY3VzKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcXG4gICAgICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kdGFiQ29udGVudC5maW5kKCdpbWcnKTtcXG5cXG4gICAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCkge1xcbiAgICAgICAgICBPYmplY3QoX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJvbkltYWdlc0xvYWRlZFxcXCJdKSgkaW1hZ2VzLCB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLl9zZXRIZWlnaHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIEN1cnJlbnQgY29udGV4dC1ib3VuZCBmdW5jdGlvbiB0byBvcGVuIHRhYnMgb24gcGFnZSBsb2FkIG9yIGhpc3RvcnkgaGFzaGNoYW5nZVxcblxcblxcbiAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYW5jaG9yID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XFxuXFxuICAgICAgICBpZiAoIWFuY2hvci5sZW5ndGgpIHtcXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIHN0aWxsIGluaXRpYWxpemluZyBhbmQgdGhlcmUgaXMgbm8gYW5jaG9yLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cXG4gICAgICAgICAgaWYgKF90aGlzMi5faXNJbml0aWFsaXppbmcpIHJldHVybjsgLy8gT3RoZXJ3aXNlLCBtb3ZlIHRvIHRoZSBpbml0aWFsIGFuY2hvclxcblxcbiAgICAgICAgICBpZiAoX3RoaXMyLl9pbml0aWFsQW5jaG9yKSBhbmNob3IgPSBfdGhpczIuX2luaXRpYWxBbmNob3I7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgYW5jaG9yTm9IYXNoID0gYW5jaG9yLmluZGV4T2YoJyMnKSA+PSAwID8gYW5jaG9yLnNsaWNlKDEpIDogYW5jaG9yO1xcbiAgICAgICAgdmFyICRhbmNob3IgPSBhbmNob3JOb0hhc2ggJiYganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCIjXFxcIi5jb25jYXQoYW5jaG9yTm9IYXNoKSk7XFxuXFxuICAgICAgICB2YXIgJGxpbmsgPSBhbmNob3IgJiYgX3RoaXMyLiRlbGVtZW50LmZpbmQoXFxcIltocmVmJD1cXFxcXFxcIlxcXCIuY29uY2F0KGFuY2hvciwgXFxcIlxcXFxcXFwiXSxbZGF0YS10YWJzLXRhcmdldD1cXFxcXFxcIlxcXCIpLmNvbmNhdChhbmNob3JOb0hhc2gsIFxcXCJcXFxcXFxcIl1cXFwiKSkuZmlyc3QoKTsgLy8gV2hldGhlciB0aGUgYW5jaG9yIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBmb3VuZCBpcyBwYXJ0IG9mIHRoaXMgZWxlbWVudFxcblxcblxcbiAgICAgICAgdmFyIGlzT3duQW5jaG9yID0gISEoJGFuY2hvci5sZW5ndGggJiYgJGxpbmsubGVuZ3RoKTtcXG5cXG4gICAgICAgIGlmIChpc093bkFuY2hvcikge1xcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBhbmNob3IgZm9yIHRoZSBoYXNoLCBzZWxlY3QgaXRcXG4gICAgICAgICAgaWYgKCRhbmNob3IgJiYgJGFuY2hvci5sZW5ndGggJiYgJGxpbmsgJiYgJGxpbmsubGVuZ3RoKSB7XFxuICAgICAgICAgICAgX3RoaXMyLnNlbGVjdFRhYigkYW5jaG9yLCB0cnVlKTtcXG4gICAgICAgICAgfSAvLyBPdGhlcndpc2UsIGNvbGxhcHNlIGV2ZXJ5dGhpbmdcXG4gICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBfdGhpczIuX2NvbGxhcHNlKCk7XFxuICAgICAgICAgICAgfSAvLyBSb2xsIHVwIGEgbGl0dGxlIHRvIHNob3cgdGhlIHRpdGxlc1xcblxcblxcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2UpIHtcXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xcblxcbiAgICAgICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBvZmZzZXQudG9wXFxuICAgICAgICAgICAgfSwgX3RoaXMyLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgZGVlcGxpbmtlZCBhdCBwYWdlbG9hZFxcbiAgICAgICAgICAgKiBAZXZlbnQgVGFicyNkZWVwbGlua1xcbiAgICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgICAgX3RoaXMyLiRlbGVtZW50LnRyaWdnZXIoJ2RlZXBsaW5rLnpmLnRhYnMnLCBbJGxpbmssICRhbmNob3JdKTtcXG4gICAgICAgIH1cXG4gICAgICB9OyAvL3VzZSBicm93c2VyIHRvIG9wZW4gYSB0YWIsIGlmIGl0IGV4aXN0cyBpbiB0aGlzIHRhYnNldFxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgdGhpcy5faXNJbml0aWFsaXppbmcgPSBmYWxzZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2V2ZW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHRoaXMuX2FkZEtleUhhbmRsZXIoKTtcXG5cXG4gICAgICB0aGlzLl9hZGRDbGlja0hhbmRsZXIoKTtcXG5cXG4gICAgICB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgPSBudWxsO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcXG4gICAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpO1xcbiAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlJywgdGhpcy5fY2hlY2tEZWVwTGluayk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGNsaWNrIGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRkQ2xpY2tIYW5kbGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDbGlja0hhbmRsZXIoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYudGFicycpLm9uKCdjbGljay56Zi50YWJzJywgXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0NsYXNzKSwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyBrZXlib2FyZCBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEtleUhhbmRsZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEtleUhhbmRsZXIoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiR0YWJUaXRsZXMub2ZmKCdrZXlkb3duLnpmLnRhYnMnKS5vbigna2V5ZG93bi56Zi50YWJzJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChlLndoaWNoID09PSA5KSByZXR1cm47XFxuICAgICAgICB2YXIgJGVsZW1lbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLFxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQ7XFxuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpZiAoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLndyYXBPbktleXMpIHtcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGkgLSAxKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9IGkgPT09ICRlbGVtZW50cy5sZW5ndGggLSAxID8gJGVsZW1lbnRzLmZpcnN0KCkgOiAkZWxlbWVudHMuZXEoaSArIDEpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpICsgMSwgJGVsZW1lbnRzLmxlbmd0aCAtIDEpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTsgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxcblxcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJLZXlib2FyZFxcXCJdLmhhbmRsZUtleShlLCAnVGFicycsIHtcXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAgICAgICAkZWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJGVsZW1lbnQpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCk7XFxuXFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkcHJldkVsZW1lbnQpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICAgICRuZXh0RWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcblxcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJG5leHRFbGVtZW50KTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuIENvbGxhcHNlcyBhY3RpdmUgdGFiLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFRhYiB0byBvcGVuLlxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpc3RvcnlIYW5kbGVkIC0gYnJvd3NlciBoYXMgYWxyZWFkeSBoYW5kbGVkIGEgaGlzdG9yeSB1cGRhdGVcXG4gICAgICogQGZpcmVzIFRhYnMjY2hhbmdlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2hhbmRsZVRhYkNoYW5nZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVGFiQ2hhbmdlKCR0YXJnZXQsIGhpc3RvcnlIYW5kbGVkKSB7XFxuICAgICAgLy8gV2l0aCBgYWN0aXZlQ29sbGFwc2VgLCBpZiB0aGUgdGFyZ2V0IGlzIHRoZSBhY3RpdmUgVGFiLCBjb2xsYXBzZSBpdC5cXG4gICAgICBpZiAoJHRhcmdldC5oYXNDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjdGl2ZUNvbGxhcHNlKSB7XFxuICAgICAgICAgIHRoaXMuX2NvbGxhcHNlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkb2xkVGFiID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtDbGFzcywgXFxcIi5cXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpLFxcbiAgICAgICAgICAkdGFiTGluayA9ICR0YXJnZXQuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJyksXFxuICAgICAgICAgIHRhcmdldCA9ICR0YWJMaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSxcXG4gICAgICAgICAgYW5jaG9yID0gdGFyZ2V0ICYmIHRhcmdldC5sZW5ndGggPyBcXFwiI1xcXCIuY29uY2F0KHRhcmdldCkgOiAkdGFiTGlua1swXS5oYXNoLFxcbiAgICAgICAgICAkdGFyZ2V0Q29udGVudCA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZChhbmNob3IpOyAvL2Nsb3NlIG9sZCB0YWJcXG5cXG4gICAgICB0aGlzLl9jb2xsYXBzZVRhYigkb2xkVGFiKTsgLy9vcGVuIG5ldyB0YWJcXG5cXG5cXG4gICAgICB0aGlzLl9vcGVuVGFiKCR0YXJnZXQpOyAvL2VpdGhlciByZXBsYWNlIG9yIHVwZGF0ZSBicm93c2VyIGhpc3RvcnlcXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmICFoaXN0b3J5SGFuZGxlZCkge1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XFxuICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgYW5jaG9yKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgYW5jaG9yKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBzdWNjZXNzZnVsbHkgY2hhbmdlZCB0YWJzLlxcbiAgICAgICAqIEBldmVudCBUYWJzI2NoYW5nZVxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlLnpmLnRhYnMnLCBbJHRhcmdldCwgJHRhcmdldENvbnRlbnRdKTsgLy9maXJlIHRvIGNoaWxkcmVuIGEgbXV0YXRpb24gZXZlbnRcXG5cXG4gICAgICAkdGFyZ2V0Q29udGVudC5maW5kKFxcXCJbZGF0YS1tdXRhdGVdXFxcIikudHJpZ2dlcihcXFwibXV0YXRlbWUuemYudHJpZ2dlclxcXCIpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIG9wZW4uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX29wZW5UYWJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5UYWIoJHRhcmdldCkge1xcbiAgICAgIHZhciAkdGFiTGluayA9ICR0YXJnZXQuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJyksXFxuICAgICAgICAgIGhhc2ggPSAkdGFiTGluay5hdHRyKCdkYXRhLXRhYnMtdGFyZ2V0JykgfHwgJHRhYkxpbmtbMF0uaGFzaC5zbGljZSgxKSxcXG4gICAgICAgICAgJHRhcmdldENvbnRlbnQgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoXFxcIiNcXFwiLmNvbmNhdChoYXNoKSk7XFxuICAgICAgJHRhcmdldC5hZGRDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpO1xcbiAgICAgICR0YWJMaW5rLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAndHJ1ZScsXFxuICAgICAgICAndGFiaW5kZXgnOiAnMCdcXG4gICAgICB9KTtcXG4gICAgICAkdGFyZ2V0Q29udGVudC5hZGRDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3MpKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDb2xsYXBzZXMgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gY29sbGFwc2UuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2NvbGxhcHNlVGFiXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb2xsYXBzZVRhYigkdGFyZ2V0KSB7XFxuICAgICAgdmFyICR0YXJnZXRfYW5jaG9yID0gJHRhcmdldC5yZW1vdmVDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnLFxcbiAgICAgICAgJ3RhYmluZGV4JzogLTFcXG4gICAgICB9KTtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdCgkdGFyZ2V0X2FuY2hvci5hdHRyKCdhcmlhLWNvbnRyb2xzJykpKS5yZW1vdmVDbGFzcyhcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3MpKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDb2xsYXBzZXMgdGhlIGFjdGl2ZSBUYWIuXFxuICAgICAqIEBmaXJlcyBUYWJzI2NvbGxhcHNlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2NvbGxhcHNlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb2xsYXBzZSgpIHtcXG4gICAgICB2YXIgJGFjdGl2ZVRhYiA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MsIFxcXCIuXFxcIikuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpKTtcXG5cXG4gICAgICBpZiAoJGFjdGl2ZVRhYi5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX2NvbGxhcHNlVGFiKCRhY3RpdmVUYWIpO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNvbGxhcHNlZCB0YWJzLlxcbiAgICAgICAgKiBAZXZlbnQgVGFicyNjb2xsYXBzZVxcbiAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY29sbGFwc2UuemYudGFicycsIFskYWN0aXZlVGFiXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBQdWJsaWMgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjb250ZW50IHBhbmUgdG8gZGlzcGxheS5cXG4gICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoaXN0b3J5SGFuZGxlZCAtIGJyb3dzZXIgaGFzIGFscmVhZHkgaGFuZGxlZCBhIGhpc3RvcnkgdXBkYXRlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2VsZWN0VGFiXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFRhYihlbGVtLCBoaXN0b3J5SGFuZGxlZCkge1xcbiAgICAgIHZhciBpZFN0ciwgaGFzaElkU3RyO1xcblxcbiAgICAgIGlmIChfdHlwZW9mKGVsZW0pID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgaWRTdHIgPSBlbGVtWzBdLmlkO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZFN0ciA9IGVsZW07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpZFN0ci5pbmRleE9mKCcjJykgPCAwKSB7XFxuICAgICAgICBoYXNoSWRTdHIgPSBcXFwiI1xcXCIuY29uY2F0KGlkU3RyKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaGFzaElkU3RyID0gaWRTdHI7XFxuICAgICAgICBpZFN0ciA9IGlkU3RyLnNsaWNlKDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJHRhcmdldCA9IHRoaXMuJHRhYlRpdGxlcy5oYXMoXFxcIltocmVmJD1cXFxcXFxcIlxcXCIuY29uY2F0KGhhc2hJZFN0ciwgXFxcIlxcXFxcXFwiXSxbZGF0YS10YWJzLXRhcmdldD1cXFxcXFxcIlxcXCIpLmNvbmNhdChpZFN0ciwgXFxcIlxcXFxcXFwiXVxcXCIpKS5maXJzdCgpO1xcblxcbiAgICAgIHRoaXMuX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldEhlaWdodFxcXCIsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBwYW5lbCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IHBhbmVsLlxcbiAgICAgKiBJZiBlbmFibGVkIGluIG9wdGlvbnMsIGdldHMgY2FsbGVkIG9uIG1lZGlhIHF1ZXJ5IGNoYW5nZS5cXG4gICAgICogSWYgbG9hZGluZyBjb250ZW50IHZpYSBleHRlcm5hbCBzb3VyY2UsIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgb3Igd2l0aCBfcmVmbG93LlxcbiAgICAgKiBJZiBlbmFibGVkIHdpdGggYGRhdGEtbWF0Y2gtaGVpZ2h0PVxcXCJ0cnVlXFxcImAsIHRhYnMgc2V0cyB0byBlcXVhbCBoZWlnaHRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhlaWdodCgpIHtcXG4gICAgICB2YXIgbWF4ID0gMCxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBMb2NrIGRvd24gdGhlIGB0aGlzYCB2YWx1ZSBmb3IgdGhlIHJvb3QgdGFicyBvYmplY3RcXG5cXG5cXG4gICAgICB0aGlzLiR0YWJDb250ZW50LmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykpLmNzcygnaGVpZ2h0JywgJycpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHBhbmVsID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gcGFuZWwuaGFzQ2xhc3MoXFxcIlxcXCIuY29uY2F0KF90aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykpOyAvLyBnZXQgdGhlIG9wdGlvbnMgZnJvbSB0aGUgcGFyZW50IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGdldCB0aGVtIGZyb20gdGhlIGNoaWxkXFxuXFxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XFxuICAgICAgICAgIHBhbmVsLmNzcyh7XFxuICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJyxcXG4gICAgICAgICAgICAnZGlzcGxheSc6ICdibG9jaydcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcblxcbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xcbiAgICAgICAgICBwYW5lbC5jc3Moe1xcbiAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXFxuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xcbiAgICAgIH0pLmNzcygnaGVpZ2h0JywgXFxcIlxcXCIuY29uY2F0KG1heCwgXFxcInB4XFxcIikpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiB0YWJzLlxcbiAgICAgKiBAZmlyZXMgVGFicyNkZXN0cm95ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpKS5vZmYoJy56Zi50YWJzJykuaGlkZSgpLmVuZCgpLmZpbmQoXFxcIi5cXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykpLmhpZGUoKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XFxuICAgICAgICBpZiAodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyICE9IG51bGwpIHtcXG4gICAgICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub25Mb2FkTGlzdGVuZXIpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUYWJzO1xcbn0oX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiUGx1Z2luXFxcIl0pO1xcblxcblRhYnMuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIGFjdGl2ZSBwYW5lLlxcbiAgICogU2V0IHRoZSBsb2NhdGlvbiBoYXNoIHdoZW4gdGhlIGFjdGl2ZSBwYW5lIGNoYW5nZXMsIGFuZCBvcGVuIHRoZSBjb3JyZXNwb25kaW5nIHBhbmUgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGVlcExpbms6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIGFkanVzdCB0aGUgZGVlcCBsaW5rIHNjcm9sbCB0byBtYWtlIHN1cmUgdGhlIHRvcCBvZiB0aGUgdGFiIHBhbmVsIGlzIHZpc2libGVcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGVlcExpbmtTbXVkZ2U6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgZGVlcExpbmtTbXVkZ2VgIGlzIGVuYWJsZWQsIGFuaW1hdGlvbiB0aW1lIChtcykgZm9yIHRoZSBkZWVwIGxpbmsgYWRqdXN0bWVudFxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDMwMFxcbiAgICovXFxuICBkZWVwTGlua1NtdWRnZURlbGF5OiAzMDAsXFxuXFxuICAvKipcXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgdXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgb3BlbiB0YWJcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIGFjdGl2ZSBwYW5lIG9uIGxvYWQuXFxuICAgKiBOb3QgcmVjb21tZW5kZWQgaWYgbW9yZSB0aGFuIG9uZSB0YWIgcGFuZWwgcGVyIHBhZ2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGF1dG9Gb2N1czogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBrZXlib2FyZCBpbnB1dCB0byAnd3JhcCcgYXJvdW5kIHRoZSB0YWIgbGlua3MuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgd3JhcE9uS2V5czogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB0YWIgY29udGVudCBwYW5lcyB0byBtYXRjaCBoZWlnaHRzIGlmIHNldCB0byB0cnVlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBtYXRjaEhlaWdodDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyBhY3RpdmUgdGFicyB0byBjb2xsYXBzZSB3aGVuIGNsaWNrZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFjdGl2ZUNvbGxhcHNlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byBgbGlgJ3MgaW4gdGFiIGxpbmsgbGlzdC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndGFicy10aXRsZSdcXG4gICAqL1xcbiAgbGlua0NsYXNzOiAndGFicy10aXRsZScsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBgbGlgIGluIHRhYiBsaW5rIGxpc3QuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2lzLWFjdGl2ZSdcXG4gICAqL1xcbiAgbGlua0FjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGVudCBjb250YWluZXJzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICd0YWJzLXBhbmVsJ1xcbiAgICovXFxuICBwYW5lbENsYXNzOiAndGFicy1wYW5lbCcsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBjb250ZW50IGNvbnRhaW5lci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnaXMtYWN0aXZlJ1xcbiAgICovXFxuICBwYW5lbEFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJ1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi50YWJzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLnRvZ2dsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnRvZ2dsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVG9nZ2xlciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVG9nZ2xlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVG9nZ2xlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX21vdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubW90aW9uICovIFxcXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnBsdWdpbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUucGx1Z2luLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XFxuXFxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBUb2dnbGVyIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBUb2dnbGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhUb2dnbGVyLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFRvZ2dsZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2dnbGVyKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihUb2dnbGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhUb2dnbGVyLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUb2dnbGVyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgVG9nZ2xlclxcbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RvZ2dsZXInOyAvLyBpZTkgYmFjayBjb21wYXRcXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gICAgICBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcIlRyaWdnZXJzXFxcIl0uaW5pdChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFRvZ2dsZXIgcGx1Z2luIGJ5IHBhcnNpbmcgdGhlIHRvZ2dsZSBjbGFzcyBmcm9tIGRhdGEtdG9nZ2xlciwgb3IgYW5pbWF0aW9uIGNsYXNzZXMgZnJvbSBkYXRhLWFuaW1hdGUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgLy8gQ29sbGVjdCB0cmlnZ2VycyB0byBzZXQgQVJJQSBhdHRyaWJ1dGVzIHRvXFxuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCxcXG4gICAgICAgICAgJHRyaWdnZXJzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKFxcXCJbZGF0YS1vcGVufj1cXFxcXFxcIlxcXCIuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdLCBbZGF0YS1jbG9zZX49XFxcXFxcXCJcXFwiKS5jb25jYXQoaWQsIFxcXCJcXFxcXFxcIl0sIFtkYXRhLXRvZ2dsZX49XFxcXFxcXCJcXFwiKS5jb25jYXQoaWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgICAgdmFyIGlucHV0OyAvLyBQYXJzZSBhbmltYXRpb24gY2xhc3NlcyBpZiB0aGV5IHdlcmUgc2V0XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XFxuICAgICAgICB0aGlzLmFuaW1hdGlvbkluID0gaW5wdXRbMF07XFxuICAgICAgICB0aGlzLmFuaW1hdGlvbk91dCA9IGlucHV0WzFdIHx8IG51bGw7IC8vIC0gYXJpYS1leHBhbmRlZDogYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50IHZpc2liaWxpdHkuXFxuXFxuICAgICAgICAkdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICF0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpO1xcbiAgICAgIH0gLy8gT3RoZXJ3aXNlLCBwYXJzZSB0b2dnbGUgY2xhc3NcXG4gICAgICBlbHNlIHtcXG4gICAgICAgICAgaW5wdXQgPSB0aGlzLm9wdGlvbnMudG9nZ2xlcjtcXG5cXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgfHwgIWlucHV0Lmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVGhlICd0b29nbGVyJyBvcHRpb24gY29udGFpbmluZyB0aGUgdGFyZ2V0IGNsYXNzIGlzIHJlcXVpcmVkLCBnb3QgXFxcXFxcXCJcXFwiLmNvbmNhdChpbnB1dCwgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgICAgICB9IC8vIEFsbG93IGZvciBhIC4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nXFxuXFxuXFxuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gaW5wdXRbMF0gPT09ICcuJyA/IGlucHV0LnNsaWNlKDEpIDogaW5wdXQ7IC8vIC0gYXJpYS1leHBhbmRlZDogYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50cyBjbGFzcyBzZXQuXFxuXFxuICAgICAgICAgICR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSkpO1xcbiAgICAgICAgfSAvLyAtIGFyaWEtY29udHJvbHM6IGFkZGluZyB0aGUgZWxlbWVudCBpZCB0byBpdCBpZiBub3QgYWxyZWFkeSBpbiBpdC5cXG5cXG5cXG4gICAgICAkdHJpZ2dlcnMuZWFjaChmdW5jdGlvbiAoaW5kZXgsIHRyaWdnZXIpIHtcXG4gICAgICAgIHZhciAkdHJpZ2dlciA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0cmlnZ2VyKTtcXG4gICAgICAgIHZhciBjb250cm9scyA9ICR0cmlnZ2VyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSB8fCAnJztcXG4gICAgICAgIHZhciBjb250YWluc0lkID0gbmV3IFJlZ0V4cChcXFwiXFxcXFxcXFxiXFxcIi5jb25jYXQoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiUmVnRXhwRXNjYXBlXFxcIl0pKGlkKSwgXFxcIlxcXFxcXFxcYlxcXCIpKS50ZXN0KGNvbnRyb2xzKTtcXG4gICAgICAgIGlmICghY29udGFpbnNJZCkgJHRyaWdnZXIuYXR0cignYXJpYS1jb250cm9scycsIGNvbnRyb2xzID8gXFxcIlxcXCIuY29uY2F0KGNvbnRyb2xzLCBcXFwiIFxcXCIpLmNvbmNhdChpZCkgOiBpZCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIHRvZ2dsZSB0cmlnZ2VyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9ldmVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG9nZ2xlLnpmLnRyaWdnZXInKS5vbigndG9nZ2xlLnpmLnRyaWdnZXInLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC4gQW4gZXZlbnQgaXMgZmlyZWQgZnJvbSB0aGUgb3JpZ2luYWwgdHJpZ2dlciBkZXBlbmRpbmcgb24gaWYgdGhlIHJlc3VsdGFudCBzdGF0ZSB3YXMgXFxcIm9uXFxcIiBvciBcXFwib2ZmXFxcIi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI29uXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI29mZlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9nZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICB0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlID8gJ190b2dnbGVBbmltYXRlJyA6ICdfdG9nZ2xlQ2xhc3MnXSgpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl90b2dnbGVDbGFzc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3MoKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XFxuICAgICAgdmFyIGlzT24gPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKTtcXG5cXG4gICAgICBpZiAoaXNPbikge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29mZi56Zi50b2dnbGVyJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3VwZGF0ZUFSSUEoaXNPbik7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl90b2dnbGVBbmltYXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVBbmltYXRlKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTW90aW9uXFxcIl0uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX3VwZGF0ZUFSSUEodHJ1ZSk7XFxuXFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xcbiAgICAgICAgICB0aGlzLmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiTW90aW9uXFxcIl0uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLmFuaW1hdGlvbk91dCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQShmYWxzZSk7XFxuXFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcXG4gICAgICAgICAgdGhpcy5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl91cGRhdGVBUklBXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVBUklBKGlzT24pIHtcXG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtb3Blbj1cXFxcXFxcIlxcXCIuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdLCBbZGF0YS1jbG9zZT1cXFxcXFxcIlxcXCIpLmNvbmNhdChpZCwgXFxcIlxcXFxcXFwiXSwgW2RhdGEtdG9nZ2xlPVxcXFxcXFwiXFxcIikuY29uY2F0KGlkLCBcXFwiXFxcXFxcXCJdXFxcIikpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBpc09uID8gdHJ1ZSA6IGZhbHNlXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiBUb2dnbGVyIG9uIHRoZSBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9kZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudG9nZ2xlcicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gVG9nZ2xlcjtcXG59KF9mb3VuZGF0aW9uX2NvcmVfcGx1Z2luX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIlBsdWdpblxcXCJdKTtcXG5cXG5Ub2dnbGVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBDbGFzcyBvZiB0aGUgZWxlbWVudCB0byB0b2dnbGUuIEl0IGNhbiBiZSBwcm92aWRlZCB3aXRoIG9yIHdpdGhvdXQgXFxcIi5cXFwiXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICovXFxuICB0b2dnbGVyOiB1bmRlZmluZWQsXFxuXFxuICAvKipcXG4gICAqIFRlbGxzIHRoZSBwbHVnaW4gaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGFuaW1hdGVkIHdoZW4gdG9nZ2xlZC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYW5pbWF0ZTogZmFsc2VcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL2pzL2ZvdW5kYXRpb24udG9nZ2xlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi50b29sdGlwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi50b29sdGlwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRvb2x0aXAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvb2x0aXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRvb2x0aXA7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLmNvcmUudXRpbHMgKi8gXFxcIi4vanMvZm91bmRhdGlvbi5jb3JlLnV0aWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeSAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fcG9zaXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlICovIFxcXCIuL2pzL2ZvdW5kYXRpb24ucG9zaXRpb25hYmxlLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XFxuXFxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxcblxcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBUb29sdGlwIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9vbHRpcFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBUb29sdGlwID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9Qb3NpdGlvbmFibGUpIHtcXG4gIF9pbmhlcml0cyhUb29sdGlwLCBfUG9zaXRpb25hYmxlKTtcXG5cXG4gIGZ1bmN0aW9uIFRvb2x0aXAoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihUb29sdGlwKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xcbiAgICBrZXk6IFxcXCJfc2V0dXBcXFwiLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBUb29sdGlwXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCBhIHRvb2x0aXAgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHRvIGV4dGVuZCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgVG9vbHRpcC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Rvb2x0aXAnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XFxuICAgICAgdGhpcy5pc0NsaWNrID0gZmFsc2U7IC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcblxcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiVHJpZ2dlcnNcXFwiXS5pbml0KGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdG9vbHRpcCBieSBzZXR0aW5nIHRoZSBjcmVhdGluZyB0aGUgdGlwIGVsZW1lbnQsIGFkZGluZyBpdCdzIHRleHQsIHNldHRpbmcgcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgYW5jaG9yLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2luaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5faW5pdCgpO1xcblxcbiAgICAgIHZhciBlbGVtSWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKSB8fCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJHZXRZb0RpZ2l0c1xcXCJdKSg2LCAndG9vbHRpcCcpO1xcbiAgICAgIHRoaXMub3B0aW9ucy50aXBUZXh0ID0gdGhpcy5vcHRpb25zLnRpcFRleHQgfHwgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPyBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZWxlbUlkKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93SHRtbCkge1xcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5odG1sKHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ3RpdGxlJzogJycsXFxuICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGVsZW1JZCxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogZWxlbUlkLFxcbiAgICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogZWxlbUlkXFxuICAgICAgfSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnRyaWdnZXJDbGFzcyk7XFxuXFxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVG9vbHRpcC5wcm90b3R5cGUpLCBcXFwiX2luaXRcXFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXREZWZhdWx0UG9zaXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcXG4gICAgICAvLyBoYW5kbGUgbGVnYWN5IGNsYXNzbmFtZXNcXG4gICAgICB2YXIgZWxlbWVudENsYXNzTmFtZSA9IHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lO1xcblxcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xcbiAgICAgICAgZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnRDbGFzc05hbWUuYmFzZVZhbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHBvc2l0aW9uID0gZWxlbWVudENsYXNzTmFtZS5tYXRjaCgvXFxcXGIodG9wfGxlZnR8cmlnaHR8Ym90dG9tKVxcXFxiL2cpO1xcbiAgICAgIHJldHVybiBwb3NpdGlvbiA/IHBvc2l0aW9uWzBdIDogJ3RvcCc7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2dldERlZmF1bHRBbGlnbm1lbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XFxuICAgICAgcmV0dXJuICdjZW50ZXInO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9nZXRIT2Zmc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIT2Zmc2V0KCkge1xcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAnbGVmdCcgfHwgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oT2Zmc2V0ICsgdGhpcy5vcHRpb25zLnRvb2x0aXBXaWR0aDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oT2Zmc2V0O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0Vk9mZnNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Vk9mZnNldCgpIHtcXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudk9mZnNldCArIHRoaXMub3B0aW9ucy50b29sdGlwSGVpZ2h0O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZPZmZzZXQ7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBidWlsZHMgdGhlIHRvb2x0aXAgZWxlbWVudCwgYWRkcyBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyB0aGUgdGVtcGxhdGUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYnVpbGRUZW1wbGF0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRUZW1wbGF0ZShpZCkge1xcbiAgICAgIHZhciB0ZW1wbGF0ZUNsYXNzZXMgPSBcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcywgXFxcIiBcXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3NlcykudHJpbSgpO1xcbiAgICAgIHZhciAkdGVtcGxhdGUgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3ModGVtcGxhdGVDbGFzc2VzKS5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3Rvb2x0aXAnLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IGZhbHNlLFxcbiAgICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuICR0ZW1wbGF0ZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogc2V0cyB0aGUgcG9zaXRpb24gY2xhc3Mgb2YgYW4gZWxlbWVudCBhbmQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIHBvc3NpYmxlIHBvc2l0aW9ucyB0byBhdHRlbXB0LCBvciB0aGUgdG9vbHRpcCBlbGVtZW50IGlzIG5vIGxvbmdlciBjb2xsaWRpbmcuXFxuICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3NldFBvc2l0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUb29sdGlwLnByb3RvdHlwZSksIFxcXCJfc2V0UG9zaXRpb25cXFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuJGVsZW1lbnQsIHRoaXMudGVtcGxhdGUpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcXG4gICAgICogQGZpcmVzIFRvb2x0aXAjY2xvc2VtZVxcbiAgICAgKiBAZmlyZXMgVG9vbHRpcCNzaG93XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2hvd1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd09uICE9PSAnYWxsJyAmJiAhX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1lZGlhUXVlcnlcXFwiXS5pcyh0aGlzLm9wdGlvbnMuc2hvd09uKSkge1xcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignVGhlIHNjcmVlbiBpcyB0b28gc21hbGwgdG8gZGlzcGxheSB0aGlzIHRvb2x0aXAnKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5zaG93KCk7XFxuXFxuICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKCd0b3AgYm90dG9tIGxlZnQgcmlnaHQnKS5hZGRDbGFzcyh0aGlzLnBvc2l0aW9uKTtcXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKCdhbGlnbi10b3AgYWxpZ24tYm90dG9tIGFsaWduLWxlZnQgYWxpZ24tcmlnaHQgYWxpZ24tY2VudGVyJykuYWRkQ2xhc3MoJ2FsaWduLScgKyB0aGlzLmFsaWdubWVudCk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgdG8gY2xvc2UgYWxsIG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcXG4gICAgICAgKiBAZXZlbnQgQ2xvc2VtZSN0b29sdGlwXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnRvb2x0aXAnLCB0aGlzLnRlbXBsYXRlLmF0dHIoJ2lkJykpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUuYXR0cih7XFxuICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7IC8vIGNvbnNvbGUubG9nKHRoaXMudGVtcGxhdGUpO1xcblxcbiAgICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoJ3Zpc2liaWxpdHknLCAnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24gKCkgey8vbWF5YmUgZG8gc3R1ZmY/XFxuICAgICAgfSk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93blxcbiAgICAgICAqIEBldmVudCBUb29sdGlwI3Nob3dcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYudG9vbHRpcCcpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBIaWRlcyB0aGUgY3VycmVudCB0b29sdGlwLCBhbmQgcmVzZXRzIHRoZSBwb3NpdGlvbmluZyBjbGFzcyBpZiBpdCB3YXMgY2hhbmdlZCBkdWUgdG8gY29sbGlzaW9uXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2hpZGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJoaWRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XFxuICAgICAgLy8gY29uc29sZS5sb2coJ2hpZGluZycsIHRoaXMuJGVsZW1lbnQuZGF0YSgneWV0aS1ib3gnKSk7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXFxuICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiBmYWxzZVxcbiAgICAgIH0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBmaXJlcyB3aGVuIHRoZSB0b29sdGlwIGlzIGhpZGRlblxcbiAgICAgICAqIEBldmVudCBUb29sdGlwI2hpZGVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYudG9vbHRpcCcpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHRvb2x0aXAgYW5kIGl0cyBhbmNob3JcXG4gICAgICogVE9ETyBjb21iaW5lIHNvbWUgb2YgdGhlIGxpc3RlbmVycyBsaWtlIGZvY3VzIGFuZCBtb3VzZWVudGVyLCBldGMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZXZlbnRzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB2YXIgaGFzVG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgdHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09ICd1bmRlZmluZWQnO1xcbiAgICAgIHZhciAkdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xcbiAgICAgIHZhciBpc0ZvY3VzID0gZmFsc2U7IC8vIGBkaXNhYmxlRm9yVG91Y2g6IEZ1bGx5IGRpc2FibGUgdGhlIHRvb2x0aXAgb24gdG91Y2ggZGV2aWNlc1xcblxcbiAgICAgIGlmIChoYXNUb3VjaCAmJiB0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNoKSByZXR1cm47XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWVudGVyLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoIV90aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLnRvb2x0aXAnLCBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpZ25vcmVNb3VzZWRpc2FwcGVhclxcXCJdKShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuXFxuICAgICAgICAgIGlmICghaXNGb2N1cyB8fCBfdGhpcy5pc0NsaWNrICYmICFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xcbiAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaGFzVG91Y2gpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA/IF90aGlzLmhpZGUoKSA6IF90aGlzLnNob3coKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykgey8vX3RoaXMuaGlkZSgpO1xcbiAgICAgICAgICAgIC8vIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICBpZiAoKF90aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyIHx8ICFfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSAmJiAhX3RoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnNob3coKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWRvd24uemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF90aGlzLmlzQ2xpY2sgPSB0cnVlO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xcbiAgICAgICAgLy8gJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgIC8vICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdmb2N1cy56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlzRm9jdXMgPSB0cnVlO1xcblxcbiAgICAgICAgaWYgKF90aGlzLmlzQ2xpY2spIHtcXG4gICAgICAgICAgLy8gSWYgd2UncmUgbm90IHNob3dpbmcgb3BlbiBvbiBjbGlja3MsIHdlIG5lZWQgdG8gcHJldGVuZCBhIGNsaWNrLWxhdW5jaGVkIGZvY3VzIGlzbid0XFxuICAgICAgICAgIC8vIGEgcmVhbCBmb2N1cywgb3RoZXJ3aXNlIG9uIGhvdmVyIGFuZCBjb21lIGJhY2sgd2UgZ2V0IGJhZCBiZWhhdmlvclxcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XFxuICAgICAgICAgICAgaXNGb2N1cyA9IGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIF90aGlzLnNob3coKTtcXG4gICAgICAgIH1cXG4gICAgICB9KS5vbignZm9jdXNvdXQuemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XFxuICAgICAgICBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XFxuXFxuICAgICAgICBfdGhpcy5oaWRlKCk7XFxuICAgICAgfSkub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoX3RoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgICAgX3RoaXMuX3NldFBvc2l0aW9uKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIGFkZHMgYSB0b2dnbGUgbWV0aG9kLCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhdGljIHNob3coKSAmIGhpZGUoKSBmdW5jdGlvbnNcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b2dnbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICB0aGlzLmhpZGUoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5zaG93KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiB0b29sdGlwLCByZW1vdmVzIHRlbXBsYXRlIGVsZW1lbnQgZnJvbSB0aGUgdmlldy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZGVzdHJveVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJywgdGhpcy50ZW1wbGF0ZS50ZXh0KCkpLm9mZignLnpmLnRyaWdnZXIgLnpmLnRvb2x0aXAnKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudHJpZ2dlckNsYXNzKS5yZW1vdmVDbGFzcygndG9wIHJpZ2h0IGxlZnQgYm90dG9tJykucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieSBkYXRhLWRpc2FibGUtaG92ZXIgZGF0YS1yZXNpemUgZGF0YS10b2dnbGUgZGF0YS10b29sdGlwIGRhdGEteWV0aS1ib3gnKTtcXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZSgpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gVG9vbHRpcDtcXG59KF9mb3VuZGF0aW9uX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJQb3NpdGlvbmFibGVcXFwiXSk7XFxuXFxuVG9vbHRpcC5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIGJlZm9yZSBhIHRvb2x0aXAgc2hvdWxkIG9wZW4gb24gaG92ZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMjAwXFxuICAgKi9cXG4gIGhvdmVyRGVsYXk6IDIwMCxcXG5cXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIGludG8gdmlldy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxNTBcXG4gICAqL1xcbiAgZmFkZUluRHVyYXRpb246IDE1MCxcXG5cXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDE1MFxcbiAgICovXFxuICBmYWRlT3V0RHVyYXRpb246IDE1MCxcXG5cXG4gIC8qKlxcbiAgICogRGlzYWJsZXMgaG92ZXIgZXZlbnRzIGZyb20gb3BlbmluZyB0aGUgdG9vbHRpcCBpZiBzZXQgdG8gdHJ1ZVxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBEaXNhYmxlIHRoZSB0b29sdGlwIGZvciB0b3VjaCBkZXZpY2VzLlxcbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1ha2UgZWxlbWVudHMgd2l0aCBhIHRvb2x0aXAgb24gaXQgdHJpZ2dlciB0aGVpclxcbiAgICogYWN0aW9uIG9uIHRoZSBmaXJzdCB0YXAgaW5zdGVhZCBvZiBkaXNwbGF5aW5nIHRoZSB0b29sdGlwLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2VsYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkaXNhYmxlRm9yVG91Y2g6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBPcHRpb25hbCBhZGR0aW9uYWwgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBpbml0LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIHRlbXBsYXRlQ2xhc3NlczogJycsXFxuXFxuICAvKipcXG4gICAqIE5vbi1vcHRpb25hbCBjbGFzcyBhZGRlZCB0byB0b29sdGlwIHRlbXBsYXRlcy4gRm91bmRhdGlvbiBkZWZhdWx0IGlzICd0b29sdGlwJy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndG9vbHRpcCdcXG4gICAqL1xcbiAgdG9vbHRpcENsYXNzOiAndG9vbHRpcCcsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIHRvb2x0aXAgYW5jaG9yIGVsZW1lbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2hhcy10aXAnXFxuICAgKi9cXG4gIHRyaWdnZXJDbGFzczogJ2hhcy10aXAnLFxcblxcbiAgLyoqXFxuICAgKiBNaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSBhdCB3aGljaCB0byBvcGVuIHRoZSB0b29sdGlwLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdzbWFsbCdcXG4gICAqL1xcbiAgc2hvd09uOiAnc21hbGwnLFxcblxcbiAgLyoqXFxuICAgKiBDdXN0b20gdGVtcGxhdGUgdG8gYmUgdXNlZCB0byBnZW5lcmF0ZSBtYXJrdXAgZm9yIHRvb2x0aXAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgdGVtcGxhdGU6ICcnLFxcblxcbiAgLyoqXFxuICAgKiBUZXh0IGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIHRpcFRleHQ6ICcnLFxcbiAgdG91Y2hDbG9zZVRleHQ6ICdUYXAgdG8gY2xvc2UuJyxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB0b29sdGlwIHRvIHJlbWFpbiBvcGVuIGlmIHRyaWdnZXJlZCB3aXRoIGEgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgY2xpY2tPcGVuOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBQb3NpdGlvbiBvZiB0b29sdGlwLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBwb3NpdGlvbjogJ2F1dG8nLFxcblxcbiAgLyoqXFxuICAgKiBBbGlnbm1lbnQgb2YgdG9vbHRpcCByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIGNlbnRlciwgb3IgYXV0by5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgYWxpZ25tZW50OiAnYXV0bycsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIHRvb2x0aXAgd2lsbCBmaXJzdCB0cnkgdG9cXG4gICAqIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dCByZXBvc2l0aW9uIGlmXFxuICAgKiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy4gIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXFxuICAgKiBMZXNzIGNvbW1vbiBmb3IgdG9vbHRpcHMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFsbG93Qm90dG9tT3ZlcmxhcDogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgcHVzaCBhd2F5IGZyb20gdGhlIGFuY2hvciBvbiB0aGUgWSBheGlzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgdk9mZnNldDogMCxcXG5cXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBYIGF4aXNcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGhPZmZzZXQ6IDAsXFxuXFxuICAvKipcXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzcGFjaW5nIGF1dG8tYWRqdXN0IGZvciBhIHZlcnRpY2FsIHRvb2x0aXBcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxNFxcbiAgICovXFxuICB0b29sdGlwSGVpZ2h0OiAxNCxcXG5cXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNwYWNpbmcgYXV0by1hZGp1c3QgZm9yIGEgaG9yaXpvbnRhbCB0b29sdGlwXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMTJcXG4gICAqL1xcbiAgdG9vbHRpcFdpZHRoOiAxMixcXG5cXG4gIC8qKlxcbiAgKiBBbGxvdyBIVE1MIGluIHRvb2x0aXAuIFdhcm5pbmc6IElmIHlvdSBhcmUgbG9hZGluZyB1c2VyLWdlbmVyYXRlZCBjb250ZW50IGludG8gdG9vbHRpcHMsXFxuICAqIGFsbG93aW5nIEhUTUwgbWF5IG9wZW4geW91cnNlbGYgdXAgdG8gWFNTIGF0dGFja3MuXFxuICAqIEBvcHRpb25cXG4gICogQHR5cGUge2Jvb2xlYW59XFxuICAqIEBkZWZhdWx0IGZhbHNlXFxuICAqL1xcbiAgYWxsb3dIdG1sOiBmYWxzZVxcbn07XFxuLyoqXFxuICogVE9ETyB1dGlsaXplIHJlc2l6ZSBldmVudCB0cmlnZ2VyXFxuICovXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi50b29sdGlwLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwuYm94LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24udXRpbC5ib3guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEJveCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQm94XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCb3g7IH0pO1xcblxcblxcbnZhciBCb3ggPSB7XFxuICBJbU5vdFRvdWNoaW5nWW91OiBJbU5vdFRvdWNoaW5nWW91LFxcbiAgT3ZlcmxhcEFyZWE6IE92ZXJsYXBBcmVhLFxcbiAgR2V0RGltZW5zaW9uczogR2V0RGltZW5zaW9ucyxcXG4gIEdldEV4cGxpY2l0T2Zmc2V0czogR2V0RXhwbGljaXRPZmZzZXRzXFxuICAvKipcXG4gICAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHRlc3QgZm9yIGNvbGxpc2lvbnMuXFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxcbiAgICogQHBhcmFtIHtCb29sZWFufSBsck9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayBsZWZ0IGFuZCByaWdodCB2YWx1ZXMgb25seS5cXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdGJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgdG9wIGFuZCBib3R0b20gdmFsdWVzIG9ubHkuXFxuICAgKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGxpc2lvbiBmcmVlLCBmYWxzZSBpZiBhIGNvbGxpc2lvbiBpbiBhbnkgZGlyZWN0aW9uLlxcbiAgICovXFxuXFxufTtcXG5cXG5mdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkge1xcbiAgcmV0dXJuIE92ZXJsYXBBcmVhKGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkgPT09IDA7XFxufVxcblxcbmZ1bmN0aW9uIE92ZXJsYXBBcmVhKGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkge1xcbiAgdmFyIGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxcbiAgICAgIHRvcE92ZXIsXFxuICAgICAgYm90dG9tT3ZlcixcXG4gICAgICBsZWZ0T3ZlcixcXG4gICAgICByaWdodE92ZXI7XFxuXFxuICBpZiAocGFyZW50KSB7XFxuICAgIHZhciBwYXJEaW1zID0gR2V0RGltZW5zaW9ucyhwYXJlbnQpO1xcbiAgICBib3R0b21PdmVyID0gcGFyRGltcy5oZWlnaHQgKyBwYXJEaW1zLm9mZnNldC50b3AgLSAoZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQpO1xcbiAgICB0b3BPdmVyID0gZWxlRGltcy5vZmZzZXQudG9wIC0gcGFyRGltcy5vZmZzZXQudG9wO1xcbiAgICBsZWZ0T3ZlciA9IGVsZURpbXMub2Zmc2V0LmxlZnQgLSBwYXJEaW1zLm9mZnNldC5sZWZ0O1xcbiAgICByaWdodE92ZXIgPSBwYXJEaW1zLndpZHRoICsgcGFyRGltcy5vZmZzZXQubGVmdCAtIChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCk7XFxuICB9IGVsc2Uge1xcbiAgICBib3R0b21PdmVyID0gZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCArIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wIC0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0KTtcXG4gICAgdG9wT3ZlciA9IGVsZURpbXMub2Zmc2V0LnRvcCAtIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wO1xcbiAgICBsZWZ0T3ZlciA9IGVsZURpbXMub2Zmc2V0LmxlZnQgLSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQ7XFxuICAgIHJpZ2h0T3ZlciA9IGVsZURpbXMud2luZG93RGltcy53aWR0aCAtIChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCk7XFxuICB9XFxuXFxuICBib3R0b21PdmVyID0gaWdub3JlQm90dG9tID8gMCA6IE1hdGgubWluKGJvdHRvbU92ZXIsIDApO1xcbiAgdG9wT3ZlciA9IE1hdGgubWluKHRvcE92ZXIsIDApO1xcbiAgbGVmdE92ZXIgPSBNYXRoLm1pbihsZWZ0T3ZlciwgMCk7XFxuICByaWdodE92ZXIgPSBNYXRoLm1pbihyaWdodE92ZXIsIDApO1xcblxcbiAgaWYgKGxyT25seSkge1xcbiAgICByZXR1cm4gbGVmdE92ZXIgKyByaWdodE92ZXI7XFxuICB9XFxuXFxuICBpZiAodGJPbmx5KSB7XFxuICAgIHJldHVybiB0b3BPdmVyICsgYm90dG9tT3ZlcjtcXG4gIH0gLy8gdXNlIHN1bSBvZiBzcXVhcmVzIGIvYyB3ZSBjYXJlIGFib3V0IG92ZXJsYXAgYXJlYS5cXG5cXG5cXG4gIHJldHVybiBNYXRoLnNxcnQodG9wT3ZlciAqIHRvcE92ZXIgKyBib3R0b21PdmVyICogYm90dG9tT3ZlciArIGxlZnRPdmVyICogbGVmdE92ZXIgKyByaWdodE92ZXIgKiByaWdodE92ZXIpO1xcbn1cXG4vKipcXG4gKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cXG4gKiBAZnVuY3Rpb25cXG4gKiBAcGFyYW0ge2pRdWVyeSB8fCBIVE1MfSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBvciBET00gZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBkaW1lbnNpb25zLiBDYW4gYmUgYW55IGVsZW1lbnQgb3RoZXIgdGhhdCBkb2N1bWVudCBvciB3aW5kb3cuXFxuICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXFxuICogVE9ETyAtIGlmIGVsZW1lbnQgaXMgd2luZG93LCByZXR1cm4gb25seSB0aG9zZSB2YWx1ZXMuXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gR2V0RGltZW5zaW9ucyhlbGVtKSB7XFxuICBlbGVtID0gZWxlbS5sZW5ndGggPyBlbGVtWzBdIDogZWxlbTtcXG5cXG4gIGlmIChlbGVtID09PSB3aW5kb3cgfHwgZWxlbSA9PT0gZG9jdW1lbnQpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlxcXCIpO1xcbiAgfVxcblxcbiAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxcbiAgICAgIHBhclJlY3QgPSBlbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXFxuICAgICAgd2luUmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXFxuICAgICAgd2luWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcXG4gICAgICB3aW5YID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xcbiAgcmV0dXJuIHtcXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXFxuICAgIG9mZnNldDoge1xcbiAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5ZLFxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpblhcXG4gICAgfSxcXG4gICAgcGFyZW50RGltczoge1xcbiAgICAgIHdpZHRoOiBwYXJSZWN0LndpZHRoLFxcbiAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXFxuICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICB0b3A6IHBhclJlY3QudG9wICsgd2luWSxcXG4gICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHdpbmRvd0RpbXM6IHtcXG4gICAgICB3aWR0aDogd2luUmVjdC53aWR0aCxcXG4gICAgICBoZWlnaHQ6IHdpblJlY3QuaGVpZ2h0LFxcbiAgICAgIG9mZnNldDoge1xcbiAgICAgICAgdG9wOiB3aW5ZLFxcbiAgICAgICAgbGVmdDogd2luWFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG59XFxuLyoqXFxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgdG9wIGFuZCBsZWZ0IGludGVnZXIgcGl4ZWwgdmFsdWVzIGZvciBkeW5hbWljYWxseSByZW5kZXJlZCBlbGVtZW50cyxcXG4gKiBzdWNoIGFzOiBUb29sdGlwLCBSZXZlYWwsIGFuZCBEcm9wZG93bi4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB3aGVyZVxcbiAqIHlvdSBkb24ndCBrbm93IGFsaWdubWVudCwgYnV0IGdlbmVyYWxseSBmcm9tXFxuICogNi40IGZvcndhcmQgeW91IHNob3VsZCB1c2UgR2V0RXhwbGljaXRPZmZzZXRzLCBhcyBHZXRPZmZzZXRzIGNvbmZsYXRlcyBwb3NpdGlvbiBhbmQgYWxpZ25tZW50LlxcbiAqIEBmdW5jdGlvblxcbiAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cXG4gKiBAcGFyYW0ge2pRdWVyeX0gYW5jaG9yIC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQncyBhbmNob3IgcG9pbnQuXFxuICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXFxuICogQHBhcmFtIHtOdW1iZXJ9IHZPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgdmVydGljYWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cXG4gKiBAcGFyYW0ge051bWJlcn0gaE9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCBob3Jpem9udGFsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXFxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXFxuICogVE9ETyBhbHRlci9yZXdyaXRlIHRvIHdvcmsgd2l0aCBgZW1gIHZhbHVlcyBhcyB3ZWxsL2luc3RlYWQgb2YgcGl4ZWxzXFxuICovXFxuXFxuXFxuZnVuY3Rpb24gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIGFsaWdubWVudCwgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdykge1xcbiAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcXG4gICAgICAkYW5jaG9yRGltcyA9IGFuY2hvciA/IEdldERpbWVuc2lvbnMoYW5jaG9yKSA6IG51bGw7XFxuICB2YXIgdG9wVmFsLCBsZWZ0VmFsO1xcblxcbiAgaWYgKCRhbmNob3JEaW1zICE9PSBudWxsKSB7XFxuICAgIC8vIHNldCBwb3NpdGlvbiByZWxhdGVkIGF0dHJpYnV0ZVxcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XFxuICAgICAgY2FzZSAndG9wJzpcXG4gICAgICAgIHRvcFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldCk7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBjYXNlICdib3R0b20nOlxcbiAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXQ7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0O1xcbiAgICAgICAgYnJlYWs7XFxuICAgIH0gLy8gc2V0IGFsaWdubWVudCByZWxhdGVkIGF0dHJpYnV0ZVxcblxcblxcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XFxuICAgICAgY2FzZSAndG9wJzpcXG4gICAgICBjYXNlICdib3R0b20nOlxcbiAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcXG4gICAgICAgICAgY2FzZSAnbGVmdCc6XFxuICAgICAgICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgaE9mZnNldDtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICRlbGVEaW1zLndpZHRoICsgJGFuY2hvckRpbXMud2lkdGggLSBoT2Zmc2V0O1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxcbiAgICAgICAgICAgIGxlZnRWYWwgPSBpc092ZXJmbG93ID8gaE9mZnNldCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggLyAyIC0gJGVsZURpbXMud2lkdGggLyAyICsgaE9mZnNldDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XFxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XFxuICAgICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCAtIHZPZmZzZXQgKyAkYW5jaG9yRGltcy5oZWlnaHQgLSAkZWxlRGltcy5oZWlnaHQ7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgJ3RvcCc6XFxuICAgICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArIHZPZmZzZXQ7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XFxuICAgICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArIHZPZmZzZXQgKyAkYW5jaG9yRGltcy5oZWlnaHQgLyAyIC0gJGVsZURpbXMuaGVpZ2h0IC8gMjtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJyZWFrO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB0b3A6IHRvcFZhbCxcXG4gICAgbGVmdDogbGVmdFZhbFxcbiAgfTtcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLmJveC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IG9uSW1hZ2VzTG9hZGVkICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJvbkltYWdlc0xvYWRlZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb25JbWFnZXNMb2FkZWQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG5cXG5cXG5cXG4vKipcXG4gKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBpbWFnZXMgYXJlIGZ1bGx5IGxvYWRlZC5cXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VzIC0gSW1hZ2UocykgdG8gY2hlY2sgaWYgbG9hZGVkLlxcbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxcbiAqL1xcblxcbmZ1bmN0aW9uIG9uSW1hZ2VzTG9hZGVkKGltYWdlcywgY2FsbGJhY2spIHtcXG4gIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICB1bmxvYWRlZCA9IGltYWdlcy5sZW5ndGg7XFxuXFxuICBpZiAodW5sb2FkZWQgPT09IDApIHtcXG4gICAgY2FsbGJhY2soKTtcXG4gIH1cXG5cXG4gIGltYWdlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gQ2hlY2sgaWYgaW1hZ2UgaXMgbG9hZGVkXFxuICAgIGlmICh0aGlzLmNvbXBsZXRlICYmIHR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIElmIHRoZSBhYm92ZSBjaGVjayBmYWlsZWQsIHNpbXVsYXRlIGxvYWRpbmcgb24gZGV0YWNoZWQgZWxlbWVudC5cXG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gU3RpbGwgY291bnQgaW1hZ2UgYXMgbG9hZGVkIGlmIGl0IGZpbmFsaXplcyB3aXRoIGFuIGVycm9yLlxcblxcbiAgICAgIHZhciBldmVudHMgPSBcXFwibG9hZC56Zi5pbWFnZXMgZXJyb3IuemYuaW1hZ2VzXFxcIjtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoaW1hZ2UpLm9uZShldmVudHMsIGZ1bmN0aW9uIG1lKGV2ZW50KSB7XFxuICAgICAgICAvLyBVbmJpbmQgdGhlIGV2ZW50IGxpc3RlbmVycy4gV2UncmUgdXNpbmcgJ29uZScgYnV0IG9ubHkgb25lIG9mIHRoZSB0d28gZXZlbnRzIHdpbGwgaGF2ZSBmaXJlZC5cXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5vZmYoZXZlbnRzLCBtZSk7XFxuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xcbiAgICAgIH0pO1xcbiAgICAgIGltYWdlLnNyYyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5hdHRyKCdzcmMnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBmdW5jdGlvbiBzaW5nbGVJbWFnZUxvYWRlZCgpIHtcXG4gICAgdW5sb2FkZWQtLTtcXG5cXG4gICAgaWYgKHVubG9hZGVkID09PSAwKSB7XFxuICAgICAgY2FsbGJhY2soKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBLZXlib2FyZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiS2V5Ym9hcmRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEtleWJvYXJkOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcXG4gKiBUaGlzIHV0aWwgd2FzIGNyZWF0ZWQgYnkgTWFyaXVzIE9sYmVydHogKlxcbiAqIFBsZWFzZSB0aGFuayBNYXJpdXMgb24gR2l0SHViIC9vd2xiZXJ0eiAqXFxuICogb3IgdGhlIHdlYiBodHRwOi8vd3d3Lm1hcml1c29sYmVydHouZGUvICpcXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuXFxuXFxuXFxudmFyIGtleUNvZGVzID0ge1xcbiAgOTogJ1RBQicsXFxuICAxMzogJ0VOVEVSJyxcXG4gIDI3OiAnRVNDQVBFJyxcXG4gIDMyOiAnU1BBQ0UnLFxcbiAgMzU6ICdFTkQnLFxcbiAgMzY6ICdIT01FJyxcXG4gIDM3OiAnQVJST1dfTEVGVCcsXFxuICAzODogJ0FSUk9XX1VQJyxcXG4gIDM5OiAnQVJST1dfUklHSFQnLFxcbiAgNDA6ICdBUlJPV19ET1dOJ1xcbn07XFxudmFyIGNvbW1hbmRzID0ge307IC8vIEZ1bmN0aW9ucyBwdWxsZWQgb3V0IHRvIGJlIHJlZmVyZW5jZWFibGUgZnJvbSBpbnRlcm5hbHNcXG5cXG5mdW5jdGlvbiBmaW5kRm9jdXNhYmxlKCRlbGVtZW50KSB7XFxuICBpZiAoISRlbGVtZW50KSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiAkZWxlbWVudC5maW5kKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuaXMoJzp2aXNpYmxlJykgfHwganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmF0dHIoJ3RhYmluZGV4JykgPCAwKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9IC8vb25seSBoYXZlIHZpc2libGUgZWxlbWVudHMgYW5kIHRob3NlIHRoYXQgaGF2ZSBhIHRhYmluZGV4IGdyZWF0ZXIgb3IgZXF1YWwgMFxcblxcblxcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZUtleShldmVudCkge1xcbiAgdmFyIGtleSA9IGtleUNvZGVzW2V2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2gpLnRvVXBwZXJDYXNlKCk7IC8vIFJlbW92ZSB1bi1wcmludGFibGUgY2hhcmFjdGVycywgZS5nLiBmb3IgYGZyb21DaGFyQ29kZWAgY2FsbHMgZm9yIENUUkwgb25seSBldmVudHNcXG5cXG4gIGtleSA9IGtleS5yZXBsYWNlKC9cXFxcVysvLCAnJyk7XFxuICBpZiAoZXZlbnQuc2hpZnRLZXkpIGtleSA9IFxcXCJTSElGVF9cXFwiLmNvbmNhdChrZXkpO1xcbiAgaWYgKGV2ZW50LmN0cmxLZXkpIGtleSA9IFxcXCJDVFJMX1xcXCIuY29uY2F0KGtleSk7XFxuICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSBcXFwiQUxUX1xcXCIuY29uY2F0KGtleSk7IC8vIFJlbW92ZSB0cmFpbGluZyB1bmRlcnNjb3JlLCBpbiBjYXNlIG9ubHkgbW9kaWZpZXJzIHdlcmUgdXNlZCAoZS5nLiBvbmx5IGBDVFJMX0FMVGApXFxuXFxuICBrZXkgPSBrZXkucmVwbGFjZSgvXyQvLCAnJyk7XFxuICByZXR1cm4ga2V5O1xcbn1cXG5cXG52YXIgS2V5Ym9hcmQgPSB7XFxuICBrZXlzOiBnZXRLZXlDb2RlcyhrZXlDb2RlcyksXFxuXFxuICAvKipcXG4gICAqIFBhcnNlcyB0aGUgKGtleWJvYXJkKSBldmVudCBhbmQgcmV0dXJucyBhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaXRzIGtleVxcbiAgICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBldmVudCBnZW5lcmF0ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXJcXG4gICAqIEByZXR1cm4gU3RyaW5nIGtleSAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGtleSBwcmVzc2VkXFxuICAgKi9cXG4gIHBhcnNlS2V5OiBwYXJzZUtleSxcXG5cXG4gIC8qKlxcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4gKGtleWJvYXJkKSBldmVudFxcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQncyBuYW1lLCBlLmcuIFNsaWRlciBvciBSZXZlYWxcXG4gICAqIEBwYXJhbSB7T2JqZWN0c30gZnVuY3Rpb25zIC0gY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgdG8gYmUgZXhlY3V0ZWRcXG4gICAqL1xcbiAgaGFuZGxlS2V5OiBmdW5jdGlvbiBoYW5kbGVLZXkoZXZlbnQsIGNvbXBvbmVudCwgZnVuY3Rpb25zKSB7XFxuICAgIHZhciBjb21tYW5kTGlzdCA9IGNvbW1hbmRzW2NvbXBvbmVudF0sXFxuICAgICAgICBrZXlDb2RlID0gdGhpcy5wYXJzZUtleShldmVudCksXFxuICAgICAgICBjbWRzLFxcbiAgICAgICAgY29tbWFuZCxcXG4gICAgICAgIGZuO1xcbiAgICBpZiAoIWNvbW1hbmRMaXN0KSByZXR1cm4gY29uc29sZS53YXJuKCdDb21wb25lbnQgbm90IGRlZmluZWQhJyk7IC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgaXQgd2FzIGFscmVhZHkgaGFuZGxlZFxcblxcbiAgICBpZiAoZXZlbnQuemZJc0tleUhhbmRsZWQgPT09IHRydWUpIHJldHVybjsgLy8gVGhpcyBjb21wb25lbnQgZG9lcyBub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGx0ciBhbmQgcnRsXFxuXFxuICAgIGlmICh0eXBlb2YgY29tbWFuZExpc3QubHRyID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGNtZHMgPSBjb21tYW5kTGlzdDsgLy8gdXNlIHBsYWluIGxpc3RcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBtZXJnZSBsdHIgYW5kIHJ0bDogaWYgZG9jdW1lbnQgaXMgcnRsLCBydGwgb3ZlcndyaXRlcyBsdHIgYW5kIHZpY2UgdmVyc2FcXG4gICAgICBpZiAoT2JqZWN0KF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicnRsXFxcIl0pKCkpIGNtZHMgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5sdHIsIGNvbW1hbmRMaXN0LnJ0bCk7ZWxzZSBjbWRzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgY29tbWFuZExpc3QucnRsLCBjb21tYW5kTGlzdC5sdHIpO1xcbiAgICB9XFxuXFxuICAgIGNvbW1hbmQgPSBjbWRzW2tleUNvZGVdO1xcbiAgICBmbiA9IGZ1bmN0aW9uc1tjb21tYW5kXTsgLy8gRXhlY3V0ZSB0aGUgaGFuZGxlciBpZiBmb3VuZFxcblxcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoKTsgLy8gTWFyayB0aGUgZXZlbnQgYXMgXFxcImhhbmRsZWRcXFwiIHRvIHByZXZlbnQgZnV0dXJlIGhhbmRsaW5nc1xcblxcbiAgICAgIGV2ZW50LnpmSXNLZXlIYW5kbGVkID0gdHJ1ZTsgLy8gRXhlY3V0ZSBmdW5jdGlvbiB3aGVuIGV2ZW50IHdhcyBoYW5kbGVkXFxuXFxuICAgICAgaWYgKGZ1bmN0aW9ucy5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgZnVuY3Rpb25zLmhhbmRsZWQocmV0dXJuVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBFeGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIG5vdCBoYW5kbGVkXFxuICAgICAgaWYgKGZ1bmN0aW9ucy51bmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy51bmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHNlYXJjaCB3aXRoaW5cXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gJGZvY3VzYWJsZSAtIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIGAkZWxlbWVudGBcXG4gICAqL1xcbiAgZmluZEZvY3VzYWJsZTogZmluZEZvY3VzYWJsZSxcXG5cXG4gIC8qKlxcbiAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG5hbWUgbmFtZVxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50LCBlLmcuIFNsaWRlciBvciBSZXZlYWxcXG4gICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcXG4gICAqL1xcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbXBvbmVudE5hbWUsIGNtZHMpIHtcXG4gICAgY29tbWFuZHNbY29tcG9uZW50TmFtZV0gPSBjbWRzO1xcbiAgfSxcXG4gIC8vIFRPRE85NDM4OiBUaGVzZSByZWZlcmVuY2VzIHRvIEtleWJvYXJkIG5lZWQgdG8gbm90IHJlcXVpcmUgZ2xvYmFsLiBXaWxsICd0aGlzJyB3b3JrIGluIHRoaXMgY29udGV4dD9cXG4gIC8vXFxuXFxuICAvKipcXG4gICAqIFRyYXBzIHRoZSBmb2N1cyBpbiB0aGUgZ2l2ZW4gZWxlbWVudC5cXG4gICAqIEBwYXJhbSAge2pRdWVyeX0gJGVsZW1lbnQgIGpRdWVyeSBvYmplY3QgdG8gdHJhcCB0aGUgZm91Y3MgaW50by5cXG4gICAqL1xcbiAgdHJhcEZvY3VzOiBmdW5jdGlvbiB0cmFwRm9jdXMoJGVsZW1lbnQpIHtcXG4gICAgdmFyICRmb2N1c2FibGUgPSBmaW5kRm9jdXNhYmxlKCRlbGVtZW50KSxcXG4gICAgICAgICRmaXJzdEZvY3VzYWJsZSA9ICRmb2N1c2FibGUuZXEoMCksXFxuICAgICAgICAkbGFzdEZvY3VzYWJsZSA9ICRmb2N1c2FibGUuZXEoLTEpO1xcbiAgICAkZWxlbWVudC5vbigna2V5ZG93bi56Zi50cmFwZm9jdXMnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSAkbGFzdEZvY3VzYWJsZVswXSAmJiBwYXJzZUtleShldmVudCkgPT09ICdUQUInKSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgJGZpcnN0Rm9jdXNhYmxlLmZvY3VzKCk7XFxuICAgICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09ICRmaXJzdEZvY3VzYWJsZVswXSAmJiBwYXJzZUtleShldmVudCkgPT09ICdTSElGVF9UQUInKSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgJGxhc3RGb2N1c2FibGUuZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogUmVsZWFzZXMgdGhlIHRyYXBwZWQgZm9jdXMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cXG4gICAqIEBwYXJhbSAge2pRdWVyeX0gJGVsZW1lbnQgIGpRdWVyeSBvYmplY3QgdG8gcmVsZWFzZSB0aGUgZm9jdXMgZm9yLlxcbiAgICovXFxuICByZWxlYXNlRm9jdXM6IGZ1bmN0aW9uIHJlbGVhc2VGb2N1cygkZWxlbWVudCkge1xcbiAgICAkZWxlbWVudC5vZmYoJ2tleWRvd24uemYudHJhcGZvY3VzJyk7XFxuICB9XFxufTtcXG4vKlxcbiAqIENvbnN0YW50cyBmb3IgZWFzaWVyIGNvbXBhcmluZy5cXG4gKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcXG4gKi9cXG5cXG5mdW5jdGlvbiBnZXRLZXlDb2RlcyhrY3MpIHtcXG4gIHZhciBrID0ge307XFxuXFxuICBmb3IgKHZhciBrYyBpbiBrY3MpIHtcXG4gICAga1trY3Nba2NdXSA9IGtjc1trY107XFxuICB9XFxuXFxuICByZXR1cm4gaztcXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBNZWRpYVF1ZXJ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJNZWRpYVF1ZXJ5XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNZWRpYVF1ZXJ5OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cXG5cXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXFxcIik7IH1cXG5cXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1xcXCJyZXR1cm5cXFwiXSAhPSBudWxsKSBfaVtcXFwicmV0dXJuXFxcIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XFxuXFxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XFxuXFxuIC8vIERlZmF1bHQgc2V0IG9mIG1lZGlhIHF1ZXJpZXNcXG5cXG52YXIgZGVmYXVsdFF1ZXJpZXMgPSB7XFxuICAnZGVmYXVsdCc6ICdvbmx5IHNjcmVlbicsXFxuICBsYW5kc2NhcGU6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyxcXG4gIHBvcnRyYWl0OiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcXG4gIHJldGluYTogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCcgKyAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xcbn07IC8vIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCAtIFRlc3QgYSBDU1MgbWVkaWEgdHlwZS9xdWVyeSBpbiBKUy5cXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IMKpIDIwMTI6IFNjb3R0IEplaGwsIFBhdWwgSXJpc2gsIE5pY2hvbGFzIFpha2FzLCBEYXZpZCBLbmlnaHQuIE1JVCBsaWNlbnNlXFxuXFxuLyogZXNsaW50LWRpc2FibGUgKi9cXG5cXG53aW5kb3cubWF0Y2hNZWRpYSB8fCAod2luZG93Lm1hdGNoTWVkaWEgPSBmdW5jdGlvbiAoKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7IC8vIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgbWF0Y2hNZWRpdW0gYXBpIHN1Y2ggYXMgSUUgOSBhbmQgd2Via2l0XFxuXFxuICB2YXIgc3R5bGVNZWRpYSA9IHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYTsgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxcblxcbiAgaWYgKCFzdHlsZU1lZGlhKSB7XFxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXFxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXFxuICAgICAgICBpbmZvID0gbnVsbDtcXG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XFxuICAgIHN0eWxlLmlkID0gJ21hdGNobWVkaWFqcy10ZXN0JztcXG5cXG4gICAgaWYgKCFzY3JpcHQpIHtcXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XFxuICAgIH0gLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcXG5cXG5cXG4gICAgaW5mbyA9ICdnZXRDb21wdXRlZFN0eWxlJyBpbiB3aW5kb3cgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3R5bGUsIG51bGwpIHx8IHN0eWxlLmN1cnJlbnRTdHlsZTtcXG4gICAgc3R5bGVNZWRpYSA9IHtcXG4gICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24gbWF0Y2hNZWRpdW0obWVkaWEpIHtcXG4gICAgICAgIHZhciB0ZXh0ID0gJ0BtZWRpYSAnICsgbWVkaWEgKyAneyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH0nOyAvLyAnc3R5bGUuc3R5bGVTaGVldCcgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnc3R5bGUudGV4dENvbnRlbnQnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcXG5cXG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XFxuICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRleHQ7XFxuICAgICAgICB9IC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxcblxcblxcbiAgICAgICAgcmV0dXJuIGluZm8ud2lkdGggPT09ICcxcHgnO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbiAobWVkaWEpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBtYXRjaGVzOiBzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhIHx8ICdhbGwnKSxcXG4gICAgICBtZWRpYTogbWVkaWEgfHwgJ2FsbCdcXG4gICAgfTtcXG4gIH07XFxufSgpKTtcXG4vKiBlc2xpbnQtZW5hYmxlICovXFxuXFxudmFyIE1lZGlhUXVlcnkgPSB7XFxuICBxdWVyaWVzOiBbXSxcXG4gIGN1cnJlbnQ6ICcnLFxcblxcbiAgLyoqXFxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLCBieSBleHRyYWN0aW5nIHRoZSBicmVha3BvaW50IGxpc3QgZnJvbSB0aGUgQ1NTIGFuZCBhY3RpdmF0aW5nIHRoZSBicmVha3BvaW50IHdhdGNoZXIuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBpbml0aWFsaXphdGlvbiBpcyBvbmx5IGRvbmUgb25jZSB3aGVuIGNhbGxpbmcgX2luaXQoKSBzZXZlcmFsIHRpbWVzXFxuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQgPT09IHRydWUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciAkbWV0YSA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnbWV0YS5mb3VuZGF0aW9uLW1xJyk7XFxuXFxuICAgIGlmICghJG1ldGEubGVuZ3RoKSB7XFxuICAgICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCc8bWV0YSBjbGFzcz1cXFwiZm91bmRhdGlvbi1tcVxcXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGV4dHJhY3RlZFN0eWxlcyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnLmZvdW5kYXRpb24tbXEnKS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XFxuICAgIHZhciBuYW1lZFF1ZXJpZXM7XFxuICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xcbiAgICBzZWxmLnF1ZXJpZXMgPSBbXTsgLy8gcmVzZXRcXG5cXG4gICAgZm9yICh2YXIga2V5IGluIG5hbWVkUXVlcmllcykge1xcbiAgICAgIGlmIChuYW1lZFF1ZXJpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgc2VsZi5xdWVyaWVzLnB1c2goe1xcbiAgICAgICAgICBuYW1lOiBrZXksXFxuICAgICAgICAgIHZhbHVlOiBcXFwib25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IFxcXCIuY29uY2F0KG5hbWVkUXVlcmllc1trZXldLCBcXFwiKVxcXCIpXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcXG5cXG4gICAgdGhpcy5fd2F0Y2hlcigpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogUmVpbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLlxcbiAgICogVXNlZnVsIGlmIHlvdXIgQ1NTIGJyZWFrcG9pbnQgY29uZmlndXJhdGlvbiBoYXMganVzdCBiZWVuIGxvYWRlZCBvciBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgaW5pdGlhbGl6YXRpb24uXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9yZUluaXQ6IGZ1bmN0aW9uIF9yZUluaXQoKSB7XFxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xcblxcbiAgICB0aGlzLl9pbml0KCk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyBhdCBsZWFzdCBhcyB3aWRlIGFzIGEgYnJlYWtwb2ludC5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGNoZWNrLlxcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0J3Mgc21hbGxlci5cXG4gICAqL1xcbiAgYXRMZWFzdDogZnVuY3Rpb24gYXRMZWFzdChzaXplKSB7XFxuICAgIHZhciBxdWVyeSA9IHRoaXMuZ2V0KHNpemUpO1xcblxcbiAgICBpZiAocXVlcnkpIHtcXG4gICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgd2l0aGluIHRoZSBnaXZlbiBicmVha3BvaW50LlxcbiAgICogSWYgc21hbGxlciB0aGFuIHRoZSBicmVha3BvaW50IG9mIGxhcmdlciB0aGFuIGl0cyB1cHBlciBsaW1pdCBpdCByZXR1cm5zIGZhbHNlLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxcbiAgICovXFxuICBvbmx5OiBmdW5jdGlvbiBvbmx5KHNpemUpIHtcXG4gICAgcmV0dXJuIHNpemUgPT09IHRoaXMuX2dldEN1cnJlbnRTaXplKCk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyB3aXRoaW4gYSBicmVha3BvaW50IG9yIHNtYWxsZXIuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjay5cXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIGxhcmdlci5cXG4gICAqL1xcbiAgdXBUbzogZnVuY3Rpb24gdXBUbyhzaXplKSB7XFxuICAgIHZhciBuZXh0U2l6ZSA9IHRoaXMubmV4dChzaXplKTsgLy8gSWYgdGhlIG5leHQgYnJlYWtwb2ludCBkb2VzIG5vdCBtYXRjaCwgdGhlIHNjcmVlbiBpcyBzbWFsbGVyIHRoYW5cXG4gICAgLy8gdGhlIHVwcGVyIGxpbWl0IG9mIHRoaXMgYnJlYWtwb2ludC5cXG5cXG4gICAgaWYgKG5leHRTaXplKSB7XFxuICAgICAgcmV0dXJuICF0aGlzLmF0TGVhc3QobmV4dFNpemUpO1xcbiAgICB9IC8vIElmIHRoZXJlIGlzIG5vIG5leHQgYnJlYWtwb2ludCwgdGhlIFxcXCJzaXplXFxcIiBicmVha3BvaW50IGRvZXMgbm90IGhhdmVcXG4gICAgLy8gYW4gdXBwZXIgbGltaXQgYW5kIHRoZSBzY3JlZW4gd2lsbCBhbHdheXMgYmUgd2l0aGluIGl0IG9yIHNtYWxsZXIuXFxuXFxuXFxuICAgIHJldHVybiB0cnVlO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gbWF0Y2hlcyB0byBhIGJyZWFrcG9pbnQuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjaywgZWl0aGVyICdzbWFsbCBvbmx5JyBvciAnc21hbGwnLiBPbWl0dGluZyAnb25seScgZmFsbHMgYmFjayB0byB1c2luZyBhdExlYXN0KCkgbWV0aG9kLlxcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0IGRvZXMgbm90LlxcbiAgICovXFxuICBpczogZnVuY3Rpb24gaXMoc2l6ZSkge1xcbiAgICB2YXIgcGFydHMgPSBzaXplLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihmdW5jdGlvbiAocCkge1xcbiAgICAgIHJldHVybiAhIXAubGVuZ3RoO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIF9wYXJ0cyA9IF9zbGljZWRUb0FycmF5KHBhcnRzLCAyKSxcXG4gICAgICAgIGJwU2l6ZSA9IF9wYXJ0c1swXSxcXG4gICAgICAgIF9wYXJ0cyQgPSBfcGFydHNbMV0sXFxuICAgICAgICBicE1vZGlmaWVyID0gX3BhcnRzJCA9PT0gdm9pZCAwID8gJycgOiBfcGFydHMkOyAvLyBPbmx5IHRoZSBicmVha3BvbnRcXG5cXG5cXG4gICAgaWYgKGJwTW9kaWZpZXIgPT09ICdvbmx5Jykge1xcbiAgICAgIHJldHVybiB0aGlzLm9ubHkoYnBTaXplKTtcXG4gICAgfSAvLyBBdCBsZWFzdCB0aGUgYnJlYWtwb2ludCAoaW5jbHVkZWQpXFxuXFxuXFxuICAgIGlmICghYnBNb2RpZmllciB8fCBicE1vZGlmaWVyID09PSAndXAnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdChicFNpemUpO1xcbiAgICB9IC8vIFVwIHRvIHRoZSBicmVha3BvaW50IChpbmNsdWRlZClcXG5cXG5cXG4gICAgaWYgKGJwTW9kaWZpZXIgPT09ICdkb3duJykge1xcbiAgICAgIHJldHVybiB0aGlzLnVwVG8oYnBTaXplKTtcXG4gICAgfVxcblxcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlxcXFxuICAgICAgSW52YWxpZCBicmVha3BvaW50IHBhc3NlZCB0byBNZWRpYVF1ZXJ5LmlzKCkuXFxcXG4gICAgICBFeHBlY3RlZCBhIGJyZWFrcG9pbnQgbmFtZSBmb3JtYXR0ZWQgbGlrZSBcXFxcXFxcIjxzaXplPiA8bW9kaWZpZXI+XFxcXFxcXCIsIGdvdCBcXFxcXFxcIlxcXCIuY29uY2F0KHNpemUsIFxcXCJcXFxcXFxcIi5cXFxcbiAgICBcXFwiKSk7XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBnZXQuXFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cXG4gICAqL1xcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc2l6ZSkge1xcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucXVlcmllcykge1xcbiAgICAgIGlmICh0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcXG4gICAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBudWxsO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogR2V0IHRoZSBicmVha3BvaW50IGZvbGxvd2luZyB0aGUgZ2l2ZW4gYnJlYWtwb2ludC5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50LlxcbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSAtIFRoZSBuYW1lIG9mIHRoZSBmb2xsb3dpbmcgYnJlYWtwb2ludCwgb3IgYG51bGxgIGlmIHRoZSBwYXNzZWQgYnJlYWtwb2ludCB3YXMgdGhlIGxhc3Qgb25lLlxcbiAgICovXFxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHNpemUpIHtcXG4gICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgdmFyIHF1ZXJ5SW5kZXggPSB0aGlzLnF1ZXJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChxKSB7XFxuICAgICAgcmV0dXJuIF90aGlzLl9nZXRRdWVyeU5hbWUocSkgPT09IHNpemU7XFxuICAgIH0pO1xcblxcbiAgICBpZiAocXVlcnlJbmRleCA9PT0gLTEpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlxcXFxuICAgICAgICBVbmtub3duIGJyZWFrcG9pbnQgXFxcXFxcXCJcXFwiLmNvbmNhdChzaXplLCBcXFwiXFxcXFxcXCIgcGFzc2VkIHRvIE1lZGlhUXVlcnkubmV4dCgpLlxcXFxuICAgICAgICBFbnN1cmUgaXQgaXMgcHJlc2VudCBpbiB5b3VyIFNhc3MgXFxcXFxcXCIkYnJlYWtwb2ludHNcXFxcXFxcIiBzZXR0aW5nLlxcXFxuICAgICAgXFxcIikpO1xcbiAgICB9XFxuXFxuICAgIHZhciBuZXh0UXVlcnkgPSB0aGlzLnF1ZXJpZXNbcXVlcnlJbmRleCArIDFdO1xcbiAgICByZXR1cm4gbmV4dFF1ZXJ5ID8gbmV4dFF1ZXJ5Lm5hbWUgOiBudWxsO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYnJlYWtwb2ludCByZWxhdGVkIHRvIHRoZSBnaXZlbiB2YWx1ZS5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgLSBCcmVha3BvaW50IG5hbWUgb3IgcXVlcnkgb2JqZWN0LlxcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgYnJlYWtwb2ludC5cXG4gICAqL1xcbiAgX2dldFF1ZXJ5TmFtZTogZnVuY3Rpb24gX2dldFF1ZXJ5TmFtZSh2YWx1ZSkge1xcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlO1xcbiAgICBpZiAoX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnKSByZXR1cm4gdmFsdWUubmFtZTtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiXFxcXG4gICAgICBJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBNZWRpYVF1ZXJ5Ll9nZXRRdWVyeU5hbWUoKS5cXFxcbiAgICAgIEV4cGVjdGVkIGEgYnJlYWtwb2ludCBuYW1lIChTdHJpbmcpIG9yIGEgYnJlYWtwb2ludCBxdWVyeSAoT2JqZWN0KSwgZ290IFxcXFxcXFwiXFxcIi5jb25jYXQodmFsdWUsIFxcXCJcXFxcXFxcIiAoXFxcIikuY29uY2F0KF90eXBlb2YodmFsdWUpLCBcXFwiKVxcXFxuICAgIFxcXCIpKTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBuYW1lIGJ5IHRlc3RpbmcgZXZlcnkgYnJlYWtwb2ludCBhbmQgcmV0dXJuaW5nIHRoZSBsYXN0IG9uZSB0byBtYXRjaCAodGhlIGJpZ2dlc3Qgb25lKS5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHByaXZhdGVcXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGN1cnJlbnQgYnJlYWtwb2ludC5cXG4gICAqL1xcbiAgX2dldEN1cnJlbnRTaXplOiBmdW5jdGlvbiBfZ2V0Q3VycmVudFNpemUoKSB7XFxuICAgIHZhciBtYXRjaGVkO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcXG5cXG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXVlcnkudmFsdWUpLm1hdGNoZXMpIHtcXG4gICAgICAgIG1hdGNoZWQgPSBxdWVyeTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1hdGNoZWQgJiYgdGhpcy5fZ2V0UXVlcnlOYW1lKG1hdGNoZWQpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX3dhdGNoZXI6IGZ1bmN0aW9uIF93YXRjaGVyKCkge1xcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdyZXNpemUuemYubWVkaWFxdWVyeScpLm9uKCdyZXNpemUuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgbmV3U2l6ZSA9IF90aGlzMi5fZ2V0Q3VycmVudFNpemUoKSxcXG4gICAgICAgICAgY3VycmVudFNpemUgPSBfdGhpczIuY3VycmVudDtcXG5cXG4gICAgICBpZiAobmV3U2l6ZSAhPT0gY3VycmVudFNpemUpIHtcXG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxcbiAgICAgICAgX3RoaXMyLmN1cnJlbnQgPSBuZXdTaXplOyAvLyBCcm9hZGNhc3QgdGhlIG1lZGlhIHF1ZXJ5IGNoYW5nZSBvbiB0aGUgd2luZG93XFxuXFxuICAgICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS50cmlnZ2VyKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBbbmV3U2l6ZSwgY3VycmVudFNpemVdKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcbn07IC8vIFRoYW5rIHlvdTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmdcXG5cXG5mdW5jdGlvbiBwYXJzZVN0eWxlVG9PYmplY3Qoc3RyKSB7XFxuICB2YXIgc3R5bGVPYmplY3QgPSB7fTtcXG5cXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XFxuICB9XFxuXFxuICBzdHIgPSBzdHIudHJpbSgpLnNsaWNlKDEsIC0xKTsgLy8gYnJvd3NlcnMgcmUtcXVvdGUgc3RyaW5nIHN0eWxlIHZhbHVlc1xcblxcbiAgaWYgKCFzdHIpIHtcXG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xcbiAgfVxcblxcbiAgc3R5bGVPYmplY3QgPSBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcXG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFxcXCsvZywgJyAnKS5zcGxpdCgnPScpO1xcbiAgICB2YXIga2V5ID0gcGFydHNbMF07XFxuICAgIHZhciB2YWwgPSBwYXJ0c1sxXTtcXG4gICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7IC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XFxuICAgIC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcXG5cXG4gICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XFxuXFxuICAgIGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICByZXRba2V5XSA9IHZhbDtcXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xcbiAgICAgIHJldFtrZXldLnB1c2godmFsKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmV0O1xcbiAgfSwge30pO1xcbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBNb3ZlLCBNb3Rpb24gKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk1vdmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1vdmU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk1vdGlvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW90aW9uOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3VuZGF0aW9uX2NvcmVfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi5jb3JlLnV0aWxzICovIFxcXCIuL2pzL2ZvdW5kYXRpb24uY29yZS51dGlscy5qc1xcXCIpO1xcblxcblxcblxcblxcbi8qKlxcbiAqIE1vdGlvbiBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm1vdGlvblxcbiAqL1xcblxcbnZhciBpbml0Q2xhc3NlcyA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xcbnZhciBhY3RpdmVDbGFzc2VzID0gWydtdWktZW50ZXItYWN0aXZlJywgJ211aS1sZWF2ZS1hY3RpdmUnXTtcXG52YXIgTW90aW9uID0ge1xcbiAgYW5pbWF0ZUluOiBmdW5jdGlvbiBhbmltYXRlSW4oZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xcbiAgICBhbmltYXRlKHRydWUsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xcbiAgfSxcXG4gIGFuaW1hdGVPdXQ6IGZ1bmN0aW9uIGFuaW1hdGVPdXQoZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xcbiAgICBhbmltYXRlKGZhbHNlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIE1vdmUoZHVyYXRpb24sIGVsZW0sIGZuKSB7XFxuICB2YXIgYW5pbSxcXG4gICAgICBwcm9nLFxcbiAgICAgIHN0YXJ0ID0gbnVsbDsgLy8gY29uc29sZS5sb2coJ2NhbGxlZCcpO1xcblxcbiAgaWYgKGR1cmF0aW9uID09PSAwKSB7XFxuICAgIGZuLmFwcGx5KGVsZW0pO1xcbiAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbW92ZSh0cykge1xcbiAgICBpZiAoIXN0YXJ0KSBzdGFydCA9IHRzOyAvLyBjb25zb2xlLmxvZyhzdGFydCwgdHMpO1xcblxcbiAgICBwcm9nID0gdHMgLSBzdGFydDtcXG4gICAgZm4uYXBwbHkoZWxlbSk7XFxuXFxuICAgIGlmIChwcm9nIDwgZHVyYXRpb24pIHtcXG4gICAgICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlLCBlbGVtKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbSk7XFxuICAgICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUpO1xcbn1cXG4vKipcXG4gKiBBbmltYXRlcyBhbiBlbGVtZW50IGluIG9yIG91dCB1c2luZyBhIENTUyB0cmFuc2l0aW9uIGNsYXNzLlxcbiAqIEBmdW5jdGlvblxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtCb29sZWFufSBpc0luIC0gRGVmaW5lcyBpZiB0aGUgYW5pbWF0aW9uIGlzIGluIG9yIG91dC5cXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvciBIVE1MIG9iamVjdCB0byBhbmltYXRlLlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gLSBDU1MgY2xhc3MgdG8gdXNlLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQ2FsbGJhY2sgdG8gcnVuIHdoZW4gYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlxcbiAqL1xcblxcblxcbmZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xcbiAgZWxlbWVudCA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShlbGVtZW50KS5lcSgwKTtcXG4gIGlmICghZWxlbWVudC5sZW5ndGgpIHJldHVybjtcXG4gIHZhciBpbml0Q2xhc3MgPSBpc0luID8gaW5pdENsYXNzZXNbMF0gOiBpbml0Q2xhc3Nlc1sxXTtcXG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzSW4gPyBhY3RpdmVDbGFzc2VzWzBdIDogYWN0aXZlQ2xhc3Nlc1sxXTsgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cXG5cXG4gIHJlc2V0KCk7XFxuICBlbGVtZW50LmFkZENsYXNzKGFuaW1hdGlvbikuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxuICAgIGVsZW1lbnQuYWRkQ2xhc3MoaW5pdENsYXNzKTtcXG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xcbiAgfSk7IC8vIFN0YXJ0IHRoZSBhbmltYXRpb25cXG5cXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxuICAgIC8vIHdpbGwgdHJpZ2dlciB0aGUgYnJvd3NlciB0byBzeW5jaHJvbm91c2x5IGNhbGN1bGF0ZSB0aGUgc3R5bGUgYW5kIGxheW91dFxcbiAgICAvLyBhbHNvIGNhbGxlZCByZWZsb3cgb3IgbGF5b3V0IHRocmFzaGluZ1xcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhXFxuICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XFxuICAgIGVsZW1lbnQuY3NzKCd0cmFuc2l0aW9uJywgJycpLmFkZENsYXNzKGFjdGl2ZUNsYXNzKTtcXG4gIH0pOyAvLyBDbGVhbiB1cCB0aGUgYW5pbWF0aW9uIHdoZW4gaXQgZmluaXNoZXNcXG5cXG4gIGVsZW1lbnQub25lKE9iamVjdChfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInRyYW5zaXRpb25lbmRcXFwiXSkoZWxlbWVudCksIGZpbmlzaCk7IC8vIEhpZGVzIHRoZSBlbGVtZW50IChmb3Igb3V0IGFuaW1hdGlvbnMpLCByZXNldHMgdGhlIGVsZW1lbnQsIGFuZCBydW5zIGEgY2FsbGJhY2tcXG5cXG4gIGZ1bmN0aW9uIGZpbmlzaCgpIHtcXG4gICAgaWYgKCFpc0luKSBlbGVtZW50LmhpZGUoKTtcXG4gICAgcmVzZXQoKTtcXG4gICAgaWYgKGNiKSBjYi5hcHBseShlbGVtZW50KTtcXG4gIH0gLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXFxuXFxuXFxuICBmdW5jdGlvbiByZXNldCgpIHtcXG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJcXFwiLmNvbmNhdChpbml0Q2xhc3MsIFxcXCIgXFxcIikuY29uY2F0KGFjdGl2ZUNsYXNzLCBcXFwiIFxcXCIpLmNvbmNhdChhbmltYXRpb24pKTtcXG4gIH1cXG59XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi51dGlsLm5lc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogTmVzdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiTmVzdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTmVzdDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcblxcblxcbnZhciBOZXN0ID0ge1xcbiAgRmVhdGhlcjogZnVuY3Rpb24gRmVhdGhlcihtZW51KSB7XFxuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnemYnO1xcbiAgICBtZW51LmF0dHIoJ3JvbGUnLCAnbWVudWJhcicpO1xcbiAgICBtZW51LmZpbmQoJ2EnKS5hdHRyKHtcXG4gICAgICAncm9sZSc6ICdtZW51aXRlbSdcXG4gICAgfSk7XFxuICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5hdHRyKHtcXG4gICAgICAncm9sZSc6ICdub25lJ1xcbiAgICB9KSxcXG4gICAgICAgIHN1Yk1lbnVDbGFzcyA9IFxcXCJpcy1cXFwiLmNvbmNhdCh0eXBlLCBcXFwiLXN1Ym1lbnVcXFwiKSxcXG4gICAgICAgIHN1Ykl0ZW1DbGFzcyA9IFxcXCJcXFwiLmNvbmNhdChzdWJNZW51Q2xhc3MsIFxcXCItaXRlbVxcXCIpLFxcbiAgICAgICAgaGFzU3ViQ2xhc3MgPSBcXFwiaXMtXFxcIi5jb25jYXQodHlwZSwgXFxcIi1zdWJtZW51LXBhcmVudFxcXCIpLFxcbiAgICAgICAgYXBwbHlBcmlhID0gdHlwZSAhPT0gJ2FjY29yZGlvbic7IC8vIEFjY29yZGlvbnMgaGFuZGxlIHRoZWlyIG93biBBUklBIGF0dHJpdXRlcy5cXG5cXG4gICAgaXRlbXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRpdGVtID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XFxuXFxuICAgICAgaWYgKCRzdWIubGVuZ3RoKSB7XFxuICAgICAgICAkaXRlbS5hZGRDbGFzcyhoYXNTdWJDbGFzcyk7XFxuXFxuICAgICAgICBpZiAoYXBwbHlBcmlhKSB7XFxuICAgICAgICAgICRpdGVtLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6ICRpdGVtLmNoaWxkcmVuKCdhOmZpcnN0JykudGV4dCgpXFxuICAgICAgICAgIH0pOyAvLyBOb3RlOiAgRHJpbGxkb3ducyBiZWhhdmUgZGlmZmVyZW50bHkgaW4gaG93IHRoZXkgaGlkZSwgYW5kIHNvIG5lZWRcXG4gICAgICAgICAgLy8gYWRkaXRpb25hbCBhdHRyaWJ1dGVzLiAgV2Ugc2hvdWxkIGxvb2sgaWYgdGhpcyBwb3NzaWJseSBvdmVyLWdlbmVyYWxpemVkXFxuICAgICAgICAgIC8vIHV0aWxpdHkgKE5lc3QpIGlzIGFwcHJvcHJpYXRlIHdoZW4gd2UgcmV3b3JrIG1lbnVzIGluIDYuNFxcblxcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcXG4gICAgICAgICAgICAkaXRlbS5hdHRyKHtcXG4gICAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgJHN1Yi5hZGRDbGFzcyhcXFwic3VibWVudSBcXFwiLmNvbmNhdChzdWJNZW51Q2xhc3MpKS5hdHRyKHtcXG4gICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxcbiAgICAgICAgICAncm9sZSc6ICdtZW51YmFyJ1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcXG4gICAgICAgICAgJHN1Yi5hdHRyKHtcXG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xcbiAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoXFxcImlzLXN1Ym1lbnUtaXRlbSBcXFwiLmNvbmNhdChzdWJJdGVtQ2xhc3MpKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICByZXR1cm47XFxuICB9LFxcbiAgQnVybjogZnVuY3Rpb24gQnVybihtZW51LCB0eXBlKSB7XFxuICAgIHZhciAvL2l0ZW1zID0gbWVudS5maW5kKCdsaScpLFxcbiAgICBzdWJNZW51Q2xhc3MgPSBcXFwiaXMtXFxcIi5jb25jYXQodHlwZSwgXFxcIi1zdWJtZW51XFxcIiksXFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBcXFwiXFxcIi5jb25jYXQoc3ViTWVudUNsYXNzLCBcXFwiLWl0ZW1cXFwiKSxcXG4gICAgICAgIGhhc1N1YkNsYXNzID0gXFxcImlzLVxcXCIuY29uY2F0KHR5cGUsIFxcXCItc3VibWVudS1wYXJlbnRcXFwiKTtcXG4gICAgbWVudS5maW5kKCc+bGksID4gbGkgPiB1bCwgLm1lbnUsIC5tZW51ID4gbGksIFtkYXRhLXN1Ym1lbnVdID4gbGknKS5yZW1vdmVDbGFzcyhcXFwiXFxcIi5jb25jYXQoc3ViTWVudUNsYXNzLCBcXFwiIFxcXCIpLmNvbmNhdChzdWJJdGVtQ2xhc3MsIFxcXCIgXFxcIikuY29uY2F0KGhhc1N1YkNsYXNzLCBcXFwiIGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51IGlzLWFjdGl2ZVxcXCIpKS5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XFxuICB9XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwubmVzdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vanMvZm91bmRhdGlvbi51dGlsLnRpbWVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vanMvZm91bmRhdGlvbi51dGlsLnRpbWVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFRpbWVyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJUaW1lclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVGltZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpxdWVyeSAqLyBcXFwianF1ZXJ5XFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBUaW1lcihlbGVtLCBvcHRpb25zLCBjYikge1xcbiAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24sXFxuICAgICAgLy9vcHRpb25zIGlzIGFuIG9iamVjdCBmb3IgZWFzaWx5IGFkZGluZyBmZWF0dXJlcyBsYXRlci5cXG4gIG5hbWVTcGFjZSA9IE9iamVjdC5rZXlzKGVsZW0uZGF0YSgpKVswXSB8fCAndGltZXInLFxcbiAgICAgIHJlbWFpbiA9IC0xLFxcbiAgICAgIHN0YXJ0LFxcbiAgICAgIHRpbWVyO1xcblxcbiAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xcblxcbiAgdGhpcy5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICByZW1haW4gPSAtMTtcXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG4gICAgdGhpcy5zdGFydCgpO1xcbiAgfTtcXG5cXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTsgLy8gaWYoIWVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXFxuXFxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIHJlbWFpbiA9IHJlbWFpbiA8PSAwID8gZHVyYXRpb24gOiByZW1haW47XFxuICAgIGVsZW0uZGF0YSgncGF1c2VkJywgZmFsc2UpO1xcbiAgICBzdGFydCA9IERhdGUubm93KCk7XFxuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKG9wdGlvbnMuaW5maW5pdGUpIHtcXG4gICAgICAgIF90aGlzLnJlc3RhcnQoKTsgLy9yZXJ1biB0aGUgdGltZXIuXFxuXFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGNiKCk7XFxuICAgICAgfVxcbiAgICB9LCByZW1haW4pO1xcbiAgICBlbGVtLnRyaWdnZXIoXFxcInRpbWVyc3RhcnQuemYuXFxcIi5jb25jYXQobmFtZVNwYWNlKSk7XFxuICB9O1xcblxcbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7IC8vaWYoZWxlbS5kYXRhKCdwYXVzZWQnKSl7IHJldHVybiBmYWxzZTsgfS8vbWF5YmUgaW1wbGVtZW50IHRoaXMgc2FuaXR5IGNoZWNrIGlmIHVzZWQgZm9yIG90aGVyIHRoaW5ncy5cXG5cXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCB0cnVlKTtcXG4gICAgdmFyIGVuZCA9IERhdGUubm93KCk7XFxuICAgIHJlbWFpbiA9IHJlbWFpbiAtIChlbmQgLSBzdGFydCk7XFxuICAgIGVsZW0udHJpZ2dlcihcXFwidGltZXJwYXVzZWQuemYuXFxcIi5jb25jYXQobmFtZVNwYWNlKSk7XFxuICB9O1xcbn1cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwudGltZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2pzL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2pzL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBUb3VjaCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVG91Y2hcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRvdWNoOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBqcXVlcnkgKi8gXFxcImpxdWVyeVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vLyoqV29yayBpbnNwaXJlZCBieSBtdWx0aXBsZSBqcXVlcnkgc3dpcGUgcGx1Z2lucyoqXFxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXG52YXIgVG91Y2ggPSB7fTtcXG52YXIgc3RhcnRQb3NYLFxcbiAgICBzdGFydFBvc1ksXFxuICAgIHN0YXJ0VGltZSxcXG4gICAgZWxhcHNlZFRpbWUsXFxuICAgIHN0YXJ0RXZlbnQsXFxuICAgIGlzTW92aW5nID0gZmFsc2UsXFxuICAgIGRpZE1vdmVkID0gZmFsc2U7XFxuXFxuZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XFxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTsgLy8gSWYgdGhlIHRvdWNoIGRpZCBub3QgbW92ZSwgY29uc2lkZXIgaXQgYXMgYSBcXFwidGFwXFxcIlxcblxcbiAgaWYgKCFkaWRNb3ZlZCkge1xcbiAgICB2YXIgdGFwRXZlbnQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuRXZlbnQoJ3RhcCcsIHN0YXJ0RXZlbnQgfHwgZSk7XFxuICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKHRhcEV2ZW50KTtcXG4gIH1cXG5cXG4gIHN0YXJ0RXZlbnQgPSBudWxsO1xcbiAgaXNNb3ZpbmcgPSBmYWxzZTtcXG4gIGRpZE1vdmVkID0gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcXG4gIGlmIChqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KSB7XFxuICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIGlmIChpc01vdmluZykge1xcbiAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5wYWdlWDtcXG4gICAgdmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XFxuICAgIHZhciBkeCA9IHN0YXJ0UG9zWCAtIHg7XFxuICAgIHZhciBkeSA9IHN0YXJ0UG9zWSAtIHk7XFxuICAgIHZhciBkaXI7XFxuICAgIGRpZE1vdmVkID0gdHJ1ZTtcXG4gICAgZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcXG5cXG4gICAgaWYgKE1hdGguYWJzKGR4KSA+PSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XFxuICAgICAgZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG4gICAgfSAvLyBlbHNlIGlmKE1hdGguYWJzKGR5KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcXG4gICAgLy8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xcbiAgICAvLyB9XFxuXFxuXFxuICAgIGlmIChkaXIpIHtcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgb25Ub3VjaEVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5FdmVudCgnc3dpcGUnLCBPYmplY3QuYXNzaWduKHt9LCBlKSksIGRpcikudHJpZ2dlcihqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuRXZlbnQoXFxcInN3aXBlXFxcIi5jb25jYXQoZGlyKSwgT2JqZWN0LmFzc2lnbih7fSwgZSkpKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xcbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xcbiAgICBzdGFydFBvc1ggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XFxuICAgIHN0YXJ0UG9zWSA9IGUudG91Y2hlc1swXS5wYWdlWTtcXG4gICAgc3RhcnRFdmVudCA9IGU7XFxuICAgIGlzTW92aW5nID0gdHJ1ZTtcXG4gICAgZGlkTW92ZWQgPSBmYWxzZTtcXG4gICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlKTtcXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5pdCgpIHtcXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcXG59XFxuXFxuZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xcbn1cXG5cXG52YXIgU3BvdFN3aXBlID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gU3BvdFN3aXBlKCQpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwb3RTd2lwZSk7XFxuXFxuICAgIHRoaXMudmVyc2lvbiA9ICcxLjAuMCc7XFxuICAgIHRoaXMuZW5hYmxlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xcbiAgICB0aGlzLm1vdmVUaHJlc2hvbGQgPSA3NTtcXG4gICAgdGhpcy50aW1lVGhyZXNob2xkID0gMjAwO1xcbiAgICB0aGlzLiQgPSAkO1xcblxcbiAgICB0aGlzLl9pbml0KCk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU3BvdFN3aXBlLCBbe1xcbiAgICBrZXk6IFxcXCJfaW5pdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgJCA9IHRoaXMuJDtcXG4gICAgICAkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7XFxuICAgICAgICBzZXR1cDogaW5pdFxcbiAgICAgIH07XFxuICAgICAgJC5ldmVudC5zcGVjaWFsLnRhcCA9IHtcXG4gICAgICAgIHNldHVwOiBpbml0XFxuICAgICAgfTtcXG4gICAgICAkLmVhY2goWydsZWZ0JywgJ3VwJywgJ2Rvd24nLCAncmlnaHQnXSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgJC5ldmVudC5zcGVjaWFsW1xcXCJzd2lwZVxcXCIuY29uY2F0KHRoaXMpXSA9IHtcXG4gICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xcbiAgICAgICAgICAgICQodGhpcykub24oJ3N3aXBlJywgJC5ub29wKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFNwb3RTd2lwZTtcXG59KCk7XFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4gKiBBcyBmYXIgYXMgSSBjYW4gdGVsbCwgYm90aCBzZXR1cFNwb3RTd2lwZSBhbmQgICAgKlxcbiAqIHNldHVwVG91Y2hIYW5kbGVyIHNob3VsZCBiZSBpZGVtcG90ZW50LCAgICAgICAgICAqXFxuICogYmVjYXVzZSB0aGV5IGRpcmVjdGx5IHJlcGxhY2UgZnVuY3Rpb25zICYgICAgICAgICpcXG4gKiB2YWx1ZXMsIGFuZCBkbyBub3QgYWRkIGV2ZW50IGhhbmRsZXJzIGRpcmVjdGx5LiAgKlxcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcblRvdWNoLnNldHVwU3BvdFN3aXBlID0gZnVuY3Rpb24gKCQpIHtcXG4gICQuc3BvdFN3aXBlID0gbmV3IFNwb3RTd2lwZSgkKTtcXG59O1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuICogTWV0aG9kIGZvciBhZGRpbmcgcHNldWRvIGRyYWcgZXZlbnRzIHRvIGVsZW1lbnRzICpcXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcblRvdWNoLnNldHVwVG91Y2hIYW5kbGVyID0gZnVuY3Rpb24gKCQpIHtcXG4gICQuZm4uYWRkVG91Y2ggPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcXG4gICAgICAkKGVsKS5iaW5kKCd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgLy93ZSBwYXNzIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgYmVjYXVzZSB0aGUgalF1ZXJ5IGV2ZW50XFxuICAgICAgICAvL29iamVjdCBpcyBub3JtYWxpemVkIHRvIHczYyBzcGVjcyBhbmQgZG9lcyBub3QgcHJvdmlkZSB0aGUgVG91Y2hMaXN0XFxuICAgICAgICBoYW5kbGVUb3VjaChldmVudCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB2YXIgaGFuZGxlVG91Y2ggPSBmdW5jdGlvbiBoYW5kbGVUb3VjaChldmVudCkge1xcbiAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXFxuICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcXG4gICAgICAgICAgZXZlbnRUeXBlcyA9IHtcXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxcbiAgICAgICAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcXG4gICAgICAgIHRvdWNoZW5kOiAnbW91c2V1cCdcXG4gICAgICB9LFxcbiAgICAgICAgICB0eXBlID0gZXZlbnRUeXBlc1tldmVudC50eXBlXSxcXG4gICAgICAgICAgc2ltdWxhdGVkRXZlbnQ7XFxuXFxuICAgICAgaWYgKCdNb3VzZUV2ZW50JyBpbiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5Nb3VzZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IG5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XFxuICAgICAgICAgICdidWJibGVzJzogdHJ1ZSxcXG4gICAgICAgICAgJ2NhbmNlbGFibGUnOiB0cnVlLFxcbiAgICAgICAgICAnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXFxuICAgICAgICAgICdzY3JlZW5ZJzogZmlyc3Quc2NyZWVuWSxcXG4gICAgICAgICAgJ2NsaWVudFgnOiBmaXJzdC5jbGllbnRYLFxcbiAgICAgICAgICAnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XFxuICAgICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIGZpcnN0LnNjcmVlblgsIGZpcnN0LnNjcmVlblksIGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwXFxuICAgICAgICAvKmxlZnQqL1xcbiAgICAgICAgLCBudWxsKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xcbiAgICB9O1xcbiAgfTtcXG59O1xcblxcblRvdWNoLmluaXQgPSBmdW5jdGlvbiAoJCkge1xcbiAgaWYgKHR5cGVvZiAkLnNwb3RTd2lwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgVG91Y2guc2V0dXBTcG90U3dpcGUoJCk7XFxuICAgIFRvdWNoLnNldHVwVG91Y2hIYW5kbGVyKCQpO1xcbiAgfVxcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vanMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVHJpZ2dlcnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRyaWdnZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmlnZ2VyczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganF1ZXJ5ICovIFxcXCJqcXVlcnlcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm91bmRhdGlvbl9jb3JlX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvdW5kYXRpb24uY29yZS51dGlscyAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLmNvcmUudXRpbHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm91bmRhdGlvbi51dGlsLm1vdGlvbiAqLyBcXFwiLi9qcy9mb3VuZGF0aW9uLnV0aWwubW90aW9uLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuXFxuXFxuXFxuXFxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKFxcXCJcXFwiLmNvbmNhdChwcmVmaXhlc1tpXSwgXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiKSBpbiB3aW5kb3cpIHtcXG4gICAgICByZXR1cm4gd2luZG93W1xcXCJcXFwiLmNvbmNhdChwcmVmaXhlc1tpXSwgXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiKV07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTtcXG59KCk7XFxuXFxudmFyIHRyaWdnZXJzID0gZnVuY3Rpb24gdHJpZ2dlcnMoZWwsIHR5cGUpIHtcXG4gIGVsLmRhdGEodHlwZSkuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdChpZCkpW3R5cGUgPT09ICdjbG9zZScgPyAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXShcXFwiXFxcIi5jb25jYXQodHlwZSwgXFxcIi56Zi50cmlnZ2VyXFxcIiksIFtlbF0pO1xcbiAgfSk7XFxufTtcXG5cXG52YXIgVHJpZ2dlcnMgPSB7XFxuICBMaXN0ZW5lcnM6IHtcXG4gICAgQmFzaWM6IHt9LFxcbiAgICBHbG9iYWw6IHt9XFxuICB9LFxcbiAgSW5pdGlhbGl6ZXJzOiB7fVxcbn07XFxuVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljID0ge1xcbiAgb3Blbkxpc3RlbmVyOiBmdW5jdGlvbiBvcGVuTGlzdGVuZXIoKSB7XFxuICAgIHRyaWdnZXJzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSwgJ29wZW4nKTtcXG4gIH0sXFxuICBjbG9zZUxpc3RlbmVyOiBmdW5jdGlvbiBjbG9zZUxpc3RlbmVyKCkge1xcbiAgICB2YXIgaWQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnY2xvc2UnKTtcXG5cXG4gICAgaWYgKGlkKSB7XFxuICAgICAgdHJpZ2dlcnMoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLCAnY2xvc2UnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykudHJpZ2dlcignY2xvc2UuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LFxcbiAgdG9nZ2xlTGlzdGVuZXI6IGZ1bmN0aW9uIHRvZ2dsZUxpc3RlbmVyKCkge1xcbiAgICB2YXIgaWQgPSBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZGF0YSgndG9nZ2xlJyk7XFxuXFxuICAgIGlmIChpZCkge1xcbiAgICAgIHRyaWdnZXJzKGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKSwgJ3RvZ2dsZScpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKCd0b2dnbGUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LFxcbiAgY2xvc2VhYmxlTGlzdGVuZXI6IGZ1bmN0aW9uIGNsb3NlYWJsZUxpc3RlbmVyKGUpIHtcXG4gICAgdmFyIGFuaW1hdGlvbiA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCdjbG9zYWJsZScpOyAvLyBPbmx5IGNsb3NlIHRoZSBmaXJzdCBjbG9zYWJsZSBlbGVtZW50LiBTZWUgaHR0cHM6Ly9naXQuaW8vemYtNzgzM1xcblxcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcblxcbiAgICBpZiAoYW5pbWF0aW9uICE9PSAnJykge1xcbiAgICAgIF9mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcIk1vdGlvblxcXCJdLmFuaW1hdGVPdXQoanF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xcbiAgICB9XFxuICB9LFxcbiAgdG9nZ2xlRm9jdXNMaXN0ZW5lcjogZnVuY3Rpb24gdG9nZ2xlRm9jdXNMaXN0ZW5lcigpIHtcXG4gICAgdmFyIGlkID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ3RvZ2dsZS1mb2N1cycpO1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoXFxcIiNcXFwiLmNvbmNhdChpZCkpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFtqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcyldKTtcXG4gIH1cXG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRPcGVuTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICRlbGVtLm9mZignY2xpY2suemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5vcGVuTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtb3Blbl0nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMub3Blbkxpc3RlbmVyKTtcXG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcbi8vIElmIHVzZWQgd2l0aG91dCBhIHZhbHVlIG9uIFtkYXRhLWNsb3NlXSwgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBhbGxvd2luZyBpdCB0byBjbG9zZSBhIHBhcmVudCBjb21wb25lbnQuXFxuXFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICRlbGVtLm9mZignY2xpY2suemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZUxpc3RlbmVyKTtcXG4gICRlbGVtLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZUxpc3RlbmVyKTtcXG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZV0gd2lsbCB0b2dnbGUgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXFxuXFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUxpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XFxuICAkZWxlbS5vZmYoJ2NsaWNrLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy50b2dnbGVMaXN0ZW5lcik7XFxufTsgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zYWJsZV0gd2lsbCByZXNwb25kIHRvIGNsb3NlLnpmLnRyaWdnZXIgZXZlbnRzLlxcblxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZWFibGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xcbiAgJGVsZW0ub2ZmKCdjbG9zZS56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlYWJsZUxpc3RlbmVyKTtcXG4gICRlbGVtLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlYWJsZV0sIFtkYXRhLWNsb3NhYmxlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZWFibGVMaXN0ZW5lcik7XFxufTsgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGUtZm9jdXNdIHdpbGwgcmVzcG9uZCB0byBjb21pbmcgaW4gYW5kIG91dCBvZiBmb2N1c1xcblxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVGb2N1c0xpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XFxuICAkZWxlbS5vZmYoJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLnRvZ2dsZUZvY3VzTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlRm9jdXNMaXN0ZW5lcik7XFxufTsgLy8gTW9yZSBHbG9iYWwvY29tcGxleCBsaXN0ZW5lcnMgYW5kIHRyaWdnZXJzXFxuXFxuXFxuVHJpZ2dlcnMuTGlzdGVuZXJzLkdsb2JhbCA9IHtcXG4gIHJlc2l6ZUxpc3RlbmVyOiBmdW5jdGlvbiByZXNpemVMaXN0ZW5lcigkbm9kZXMpIHtcXG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XFxuICAgICAgLy9mYWxsYmFjayBmb3IgSUUgOVxcbiAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSByZXNpemUgZXZlbnRcXG5cXG5cXG4gICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInJlc2l6ZVxcXCIpO1xcbiAgfSxcXG4gIHNjcm9sbExpc3RlbmVyOiBmdW5jdGlvbiBzY3JvbGxMaXN0ZW5lcigkbm9kZXMpIHtcXG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XFxuICAgICAgLy9mYWxsYmFjayBmb3IgSUUgOVxcbiAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcXG5cXG5cXG4gICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInNjcm9sbFxcXCIpO1xcbiAgfSxcXG4gIGNsb3NlTWVMaXN0ZW5lcjogZnVuY3Rpb24gY2xvc2VNZUxpc3RlbmVyKGUsIHBsdWdpbklkKSB7XFxuICAgIHZhciBwbHVnaW4gPSBlLm5hbWVzcGFjZS5zcGxpdCgnLicpWzBdO1xcbiAgICB2YXIgcGx1Z2lucyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShcXFwiW2RhdGEtXFxcIi5jb25jYXQocGx1Z2luLCBcXFwiXVxcXCIpKS5ub3QoXFxcIltkYXRhLXlldGktYm94PVxcXFxcXFwiXFxcIi5jb25jYXQocGx1Z2luSWQsIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF90aGlzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpO1xcblxcbiAgICAgIF90aGlzLnRyaWdnZXJIYW5kbGVyKCdjbG9zZS56Zi50cmlnZ2VyJywgW190aGlzXSk7XFxuICAgIH0pO1xcbiAgfSAvLyBHbG9iYWwsIHBhcnNlcyB3aG9sZSBkb2N1bWVudC5cXG5cXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZW1lTGlzdGVuZXIgPSBmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xcbiAgdmFyIHlldGlCb3hlcyA9IGpxdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSgnW2RhdGEteWV0aS1ib3hdJyksXFxuICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xcblxcbiAgaWYgKHBsdWdpbk5hbWUpIHtcXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBsdWdOYW1lcy5wdXNoKHBsdWdpbk5hbWUpO1xcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YocGx1Z2luTmFtZSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwbHVnaW5OYW1lWzBdID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBsdWdOYW1lcyA9IHBsdWdOYW1lcy5jb25jYXQocGx1Z2luTmFtZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY29uc29sZS5lcnJvcignUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5ncycpO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeWV0aUJveGVzLmxlbmd0aCkge1xcbiAgICB2YXIgbGlzdGVuZXJzID0gcGx1Z05hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgIHJldHVybiBcXFwiY2xvc2VtZS56Zi5cXFwiLmNvbmNhdChuYW1lKTtcXG4gICAgfSkuam9pbignICcpO1xcbiAgICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYobGlzdGVuZXJzKS5vbihsaXN0ZW5lcnMsIFRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwuY2xvc2VNZUxpc3RlbmVyKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsIHRyaWdnZXIsIGxpc3RlbmVyKSB7XFxuICB2YXIgdGltZXIsXFxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XFxuICBqcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkod2luZG93KS5vZmYodHJpZ2dlcikub24odHJpZ2dlciwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKHRpbWVyKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG4gICAgfVxcblxcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xcbiAgICB9LCBkZWJvdW5jZSB8fCAxMCk7IC8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgc2Nyb2xsIGV2ZW50XFxuICB9KTtcXG59XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGRlYm91bmNlKSB7XFxuICB2YXIgJG5vZGVzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS1yZXNpemVdJyk7XFxuXFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCAncmVzaXplLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLnJlc2l6ZUxpc3RlbmVyLCAkbm9kZXMpO1xcbiAgfVxcbn07XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gKGRlYm91bmNlKSB7XFxuICB2YXIgJG5vZGVzID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKCdbZGF0YS1zY3JvbGxdJyk7XFxuXFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCAnc2Nyb2xsLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLnNjcm9sbExpc3RlbmVyLCAkbm9kZXMpO1xcbiAgfVxcbn07XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgJG5vZGVzID0gJGVsZW0uZmluZCgnW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXScpOyAvL2VsZW1lbnQgY2FsbGJhY2tcXG5cXG4gIHZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uID0gZnVuY3Rpb24gbGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbihtdXRhdGlvblJlY29yZHNMaXN0KSB7XFxuICAgIHZhciAkdGFyZ2V0ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udGFyZ2V0KTsgLy90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxcblxcbiAgICBzd2l0Y2ggKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udHlwZSkge1xcbiAgICAgIGNhc2UgXFxcImF0dHJpYnV0ZXNcXFwiOlxcbiAgICAgICAgaWYgKCR0YXJnZXQuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSA9PT0gXFxcInNjcm9sbFxcXCIgJiYgbXV0YXRpb25SZWNvcmRzTGlzdFswXS5hdHRyaWJ1dGVOYW1lID09PSBcXFwiZGF0YS1ldmVudHNcXFwiKSB7XFxuICAgICAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLCBbJHRhcmdldCwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJHRhcmdldC5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIpID09PSBcXFwicmVzaXplXFxcIiAmJiBtdXRhdGlvblJlY29yZHNMaXN0WzBdLmF0dHJpYnV0ZU5hbWUgPT09IFxcXCJkYXRhLWV2ZW50c1xcXCIpIHtcXG4gICAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0XSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobXV0YXRpb25SZWNvcmRzTGlzdFswXS5hdHRyaWJ1dGVOYW1lID09PSBcXFwic3R5bGVcXFwiKSB7XFxuICAgICAgICAgICR0YXJnZXQuY2xvc2VzdChcXFwiW2RhdGEtbXV0YXRlXVxcXCIpLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIiwgXFxcIm11dGF0ZVxcXCIpO1xcbiAgICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoXFxcIltkYXRhLW11dGF0ZV1cXFwiKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LmNsb3Nlc3QoXFxcIltkYXRhLW11dGF0ZV1cXFwiKV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSBcXFwiY2hpbGRMaXN0XFxcIjpcXG4gICAgICAgICR0YXJnZXQuY2xvc2VzdChcXFwiW2RhdGEtbXV0YXRlXVxcXCIpLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIiwgXFxcIm11dGF0ZVxcXCIpO1xcbiAgICAgICAgJHRhcmdldC5jbG9zZXN0KFxcXCJbZGF0YS1tdXRhdGVdXFxcIikudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldC5jbG9zZXN0KFxcXCJbZGF0YS1tdXRhdGVdXFxcIildKTtcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgLy9ub3RoaW5nXFxuICAgIH1cXG4gIH07XFxuXFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIG9yIG11dGF0aW9uIGFkZCBhIHNpbmdsZSBvYnNlcnZlclxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAkbm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgdmFyIGVsZW1lbnRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24pO1xcbiAgICAgIGVsZW1lbnRPYnNlcnZlci5vYnNlcnZlKCRub2Rlc1tpXSwge1xcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IGZhbHNlLFxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1xcXCJkYXRhLWV2ZW50c1xcXCIsIFxcXCJzdHlsZVxcXCJdXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTaW1wbGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgJGRvY3VtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRPcGVuTGlzdGVuZXIoJGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZUxpc3RlbmVyKCRkb2N1bWVudCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkVG9nZ2xlTGlzdGVuZXIoJGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZWFibGVMaXN0ZW5lcigkZG9jdW1lbnQpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUZvY3VzTGlzdGVuZXIoJGRvY3VtZW50KTtcXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgJGRvY3VtZW50ID0ganF1ZXJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRNdXRhdGlvbkV2ZW50c0xpc3RlbmVyKCRkb2N1bWVudCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkUmVzaXplTGlzdGVuZXIoKTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTY3JvbGxMaXN0ZW5lcigpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlbWVMaXN0ZW5lcigpO1xcbn07XFxuXFxuVHJpZ2dlcnMuaW5pdCA9IGZ1bmN0aW9uICgkLCBGb3VuZGF0aW9uKSB7XFxuICBPYmplY3QoX2ZvdW5kYXRpb25fY29yZV91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvbkxvYWRcXFwiXSkoJCh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICgkLnRyaWdnZXJzSW5pdGlhbGl6ZWQgIT09IHRydWUpIHtcXG4gICAgICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2ltcGxlTGlzdGVuZXJzKCk7XFxuICAgICAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZEdsb2JhbExpc3RlbmVycygpO1xcbiAgICAgICQudHJpZ2dlcnNJbml0aWFsaXplZCA9IHRydWU7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgaWYgKEZvdW5kYXRpb24pIHtcXG4gICAgRm91bmRhdGlvbi5UcmlnZ2VycyA9IFRyaWdnZXJzOyAvLyBMZWdhY3kgaW5jbHVkZWQgdG8gYmUgYmFja3dhcmRzIGNvbXBhdGlibGUgZm9yIG5vdy5cXG5cXG4gICAgRm91bmRhdGlvbi5JSGVhcllvdSA9IFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnM7XFxuICB9XFxufTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9qcy9mb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJqcXVlcnlcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIHtcInJvb3RcIjpbXCJqUXVlcnlcIl0sXCJhbWRcIjpcImpRdWVyeVwiLFwiY29tbW9uanNcIjpcImpRdWVyeVwiLFwiY29tbW9uanMyXCI6XCJqUXVlcnlcIn0gKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X187XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL2V4dGVybmFsXyU3QiUyMnJvb3QlMjI6JTVCJTIyalF1ZXJ5JTIyJTVELCUyMmFtZCUyMjolMjJqUXVlcnklMjIsJTIyY29tbW9uanMlMjI6JTIyalF1ZXJ5JTIyLCUyMmNvbW1vbmpzMiUyMjolMjJqUXVlcnklMjIlN0Q/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTtcbn0pOyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwibW9kdWxlIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJ0aGlzIiwibm9HbG9iYWwiLCJhcnIiLCJnZXRQcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic2xpY2UiLCJmbGF0IiwiYXJyYXkiLCJjYWxsIiwiY29uY2F0IiwiYXBwbHkiLCJwdXNoIiwiaW5kZXhPZiIsImNsYXNzMnR5cGUiLCJ0b1N0cmluZyIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZm5Ub1N0cmluZyIsIk9iamVjdEZ1bmN0aW9uU3RyaW5nIiwic3VwcG9ydCIsImlzRnVuY3Rpb24iLCJvYmoiLCJub2RlVHlwZSIsImlzV2luZG93IiwicHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyIsInR5cGUiLCJzcmMiLCJub25jZSIsIm5vTW9kdWxlIiwiRE9NRXZhbCIsImNvZGUiLCJub2RlIiwiZG9jIiwiaSIsInZhbCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0IiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9UeXBlIiwidmVyc2lvbiIsImpRdWVyeSIsInNlbGVjdG9yIiwiY29udGV4dCIsImZuIiwiaW5pdCIsInByb3RvdHlwZSIsImpxdWVyeSIsImNvbnN0cnVjdG9yIiwibGVuZ3RoIiwidG9BcnJheSIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwibWVyZ2UiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwibWFwIiwiZWxlbSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwiZXZlbiIsImdyZXAiLCJfZWxlbSIsIm9kZCIsImxlbiIsImoiLCJlbmQiLCJzb3J0Iiwic3BsaWNlIiwiZXh0ZW5kIiwib3B0aW9ucyIsIm5hbWUiLCJjb3B5IiwiY29weUlzQXJyYXkiLCJjbG9uZSIsInRhcmdldCIsImRlZXAiLCJpc1BsYWluT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiZXhwYW5kbyIsIk1hdGgiLCJyYW5kb20iLCJyZXBsYWNlIiwiaXNSZWFkeSIsImVycm9yIiwibXNnIiwibm9vcCIsInByb3RvIiwiQ3RvciIsImlzRW1wdHlPYmplY3QiLCJnbG9iYWxFdmFsIiwiaXNBcnJheUxpa2UiLCJtYWtlQXJyYXkiLCJyZXN1bHRzIiwiaW5BcnJheSIsInNlY29uZCIsImludmVydCIsImNhbGxiYWNrSW52ZXJzZSIsIm1hdGNoZXMiLCJjYWxsYmFja0V4cGVjdCIsImFyZyIsInZhbHVlIiwiZ3VpZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic3BsaXQiLCJfaSIsInRvTG93ZXJDYXNlIiwiU2l6emxlIiwiRXhwciIsImdldFRleHQiLCJpc1hNTCIsInRva2VuaXplIiwiY29tcGlsZSIsInNlbGVjdCIsIm91dGVybW9zdENvbnRleHQiLCJzb3J0SW5wdXQiLCJoYXNEdXBsaWNhdGUiLCJzZXREb2N1bWVudCIsImRvY0VsZW0iLCJkb2N1bWVudElzSFRNTCIsInJidWdneVFTQSIsInJidWdneU1hdGNoZXMiLCJjb250YWlucyIsIkRhdGUiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwibm9ubmF0aXZlU2VsZWN0b3JDYWNoZSIsInNvcnRPcmRlciIsImEiLCJiIiwicG9wIiwicHVzaE5hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJ0cmltIiwicmNvbW1hIiwicmNvbWJpbmF0b3JzIiwicmRlc2NlbmQiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJyaHRtbCIsInJpbnB1dHMiLCJyaGVhZGVyIiwicm5hdGl2ZSIsInJxdWlja0V4cHIiLCJyc2libGluZyIsInJ1bmVzY2FwZSIsImZ1bmVzY2FwZSIsImVzY2FwZSIsIm5vbkhleCIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyY3NzZXNjYXBlIiwiZmNzc2VzY2FwZSIsImNoIiwiYXNDb2RlUG9pbnQiLCJjaGFyQ29kZUF0IiwidW5sb2FkSGFuZGxlciIsImluRGlzYWJsZWRGaWVsZHNldCIsImFkZENvbWJpbmF0b3IiLCJkaXNhYmxlZCIsIm5vZGVOYW1lIiwiZGlyIiwibmV4dCIsImNoaWxkTm9kZXMiLCJlIiwiZWxzIiwic2VlZCIsIm0iLCJuaWQiLCJtYXRjaCIsImdyb3VwcyIsIm5ld1NlbGVjdG9yIiwibmV3Q29udGV4dCIsIm93bmVyRG9jdW1lbnQiLCJleGVjIiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInFzYSIsInRlc3QiLCJ0ZXN0Q29udGV4dCIsInNjb3BlIiwidG9TZWxlY3RvciIsImpvaW4iLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGUiLCJrZXkiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZWwiLCJhZGRIYW5kbGUiLCJhdHRycyIsImhhbmRsZXIiLCJhdHRySGFuZGxlIiwic2libGluZ0NoZWNrIiwiY3VyIiwiZGlmZiIsInNvdXJjZUluZGV4IiwibmV4dFNpYmxpbmciLCJjcmVhdGVJbnB1dFBzZXVkbyIsImNyZWF0ZUJ1dHRvblBzZXVkbyIsImNyZWF0ZURpc2FibGVkUHNldWRvIiwiaXNEaXNhYmxlZCIsImNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8iLCJhcmd1bWVudCIsIm1hdGNoSW5kZXhlcyIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZVVSSSIsImRvY3VtZW50RWxlbWVudCIsImhhc0NvbXBhcmUiLCJzdWJXaW5kb3ciLCJkZWZhdWx0VmlldyIsInRvcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNsYXNzTmFtZSIsImNyZWF0ZUNvbW1lbnQiLCJnZXRCeUlkIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJmaWx0ZXIiLCJhdHRySWQiLCJmaW5kIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsInRtcCIsImlucHV0IiwiaW5uZXJIVE1MIiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImF1cCIsImFwIiwiYnAiLCJ1bnNoaWZ0IiwiZXhwciIsImVsZW1lbnRzIiwiYXR0ciIsInNwZWNpZmllZCIsInNlbCIsInVuaXF1ZVNvcnQiLCJkdXBsaWNhdGVzIiwiZGV0ZWN0RHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJ0ZXh0Q29udGVudCIsImZpcnN0Q2hpbGQiLCJub2RlVmFsdWUiLCJzZWxlY3RvcnMiLCJjcmVhdGVQc2V1ZG8iLCJyZWxhdGl2ZSIsInByZUZpbHRlciIsImV4Y2VzcyIsInVucXVvdGVkIiwibm9kZU5hbWVTZWxlY3RvciIsInBhdHRlcm4iLCJvcGVyYXRvciIsImNoZWNrIiwicmVzdWx0Iiwid2hhdCIsIl9hcmd1bWVudCIsInNpbXBsZSIsImZvcndhcmQiLCJvZlR5cGUiLCJfY29udGV4dCIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwicGFyZW50IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsImFyZ3MiLCJzZXRGaWx0ZXJzIiwiaWR4IiwibWF0Y2hlZCIsIm1hdGNoZXIiLCJ1bm1hdGNoZWQiLCJsYW5nIiwiZWxlbUxhbmciLCJoYXNoIiwibG9jYXRpb24iLCJhY3RpdmVFbGVtZW50IiwiaGFzRm9jdXMiLCJocmVmIiwidGFiSW5kZXgiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwiX21hdGNoSW5kZXhlcyIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImNvbWJpbmF0b3IiLCJiYXNlIiwic2tpcCIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwiX25hbWUiLCJkZWZhdWx0VmFsdWUiLCJ1bmlxdWUiLCJpc1hNTERvYyIsImVzY2FwZVNlbGVjdG9yIiwidW50aWwiLCJ0cnVuY2F0ZSIsImlzIiwic2libGluZ3MiLCJuIiwicm5lZWRzQ29udGV4dCIsIm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJub3QiLCJzZWxmIiwicm9vdGpRdWVyeSIsInJvb3QiLCJwYXJzZUhUTUwiLCJyZWFkeSIsInJwYXJlbnRzcHJldiIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwicHJldiIsImhhcyIsInRhcmdldHMiLCJsIiwiY2xvc2VzdCIsImluZGV4IiwicHJldkFsbCIsImFkZCIsImFkZEJhY2siLCJzaWJsaW5nIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsIm5leHRBbGwiLCJuZXh0VW50aWwiLCJwcmV2VW50aWwiLCJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50IiwicmV2ZXJzZSIsInJub3RodG1sd2hpdGUiLCJjcmVhdGVPcHRpb25zIiwib2JqZWN0IiwiXyIsImZsYWciLCJDYWxsYmFja3MiLCJmaXJpbmciLCJtZW1vcnkiLCJmaXJlZCIsImxvY2tlZCIsInF1ZXVlIiwiZmlyaW5nSW5kZXgiLCJmaXJlIiwib25jZSIsInN0b3BPbkZhbHNlIiwicmVtb3ZlIiwiZW1wdHkiLCJkaXNhYmxlIiwibG9jayIsImZpcmVXaXRoIiwiSWRlbnRpdHkiLCJ2IiwiVGhyb3dlciIsImV4IiwiYWRvcHRWYWx1ZSIsInJlc29sdmUiLCJyZWplY3QiLCJub1ZhbHVlIiwibWV0aG9kIiwicHJvbWlzZSIsImZhaWwiLCJ0aGVuIiwiRGVmZXJyZWQiLCJmdW5jIiwidHVwbGVzIiwic3RhdGUiLCJhbHdheXMiLCJkZWZlcnJlZCIsInBpcGUiLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIm9uUHJvZ3Jlc3MiLCJtYXhEZXB0aCIsImRlcHRoIiwic3BlY2lhbCIsInRoYXQiLCJtaWdodFRocm93IiwiVHlwZUVycm9yIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvY2VzcyIsImV4Y2VwdGlvbkhvb2siLCJzdGFja1RyYWNlIiwicmVqZWN0V2l0aCIsImdldFN0YWNrSG9vayIsInNldFRpbWVvdXQiLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzaW5nbGVWYWx1ZSIsInJlbWFpbmluZyIsInJlc29sdmVDb250ZXh0cyIsInJlc29sdmVWYWx1ZXMiLCJtYXN0ZXIiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJzdGFjayIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwiY2F0Y2giLCJyZWFkeVdhaXQiLCJ3YWl0IiwiY29tcGxldGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5U3RhdGUiLCJkb1Njcm9sbCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsIl9rZXkiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsIl9hbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsQ2FzZSIsInN0cmluZyIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInNldCIsImRhdGEiLCJwcm9wIiwiaGFzRGF0YSIsImRhdGFQcml2IiwiZGF0YVVzZXIiLCJyYnJhY2UiLCJybXVsdGlEYXNoIiwiZ2V0RGF0YSIsIkpTT04iLCJwYXJzZSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJjb3VudCIsImRlZmVyIiwicG51bSIsInNvdXJjZSIsInJjc3NOdW0iLCJjc3NFeHBhbmQiLCJpc0F0dGFjaGVkIiwiY29tcG9zZWQiLCJnZXRSb290Tm9kZSIsImlzSGlkZGVuV2l0aGluVHJlZSIsInN0eWxlIiwiZGlzcGxheSIsImNzcyIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwiaW5pdGlhbCIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsImJvZHkiLCJzaG93SGlkZSIsInNob3ciLCJ2YWx1ZXMiLCJoaWRlIiwidG9nZ2xlIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZGl2IiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwib3B0aW9uIiwid3JhcE1hcCIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIl9kZWZhdWx0IiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwib3B0Z3JvdXAiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwicmVmRWxlbWVudHMiLCJidWlsZEZyYWdtZW50Iiwic2NyaXB0cyIsInNlbGVjdGlvbiIsImlnbm9yZWQiLCJ3cmFwIiwiYXR0YWNoZWQiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiaHRtbFByZWZpbHRlciIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJleHBlY3RTeW5jIiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJlcnIiLCJvbiIsInR5cGVzIiwib25lIiwib3JpZ0ZuIiwiZXZlbnQiLCJvZmYiLCJoYW5kbGVPYmpJbiIsImV2ZW50SGFuZGxlIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iaiIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJjcmVhdGUiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJoYW5kbGVyUXVldWUiLCJmaXgiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJtYXRjaGVkSGFuZGxlcnMiLCJtYXRjaGVkU2VsZWN0b3JzIiwiYnV0dG9uIiwiYWRkUHJvcCIsImhvb2siLCJFdmVudCIsImVudW1lcmFibGUiLCJvcmlnaW5hbEV2ZW50Iiwid3JpdGFibGUiLCJsb2FkIiwibm9CdWJibGUiLCJjbGljayIsImxldmVyYWdlTmF0aXZlIiwidHJpZ2dlciIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwibm90QXN5bmMiLCJzYXZlZCIsImlzVHJpZ2dlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInByb3BzIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInJlbGF0ZWRUYXJnZXQiLCJ0aW1lU3RhbXAiLCJub3ciLCJpc1NpbXVsYXRlZCIsImFsdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJjdHJsS2V5IiwiZGV0YWlsIiwiZXZlbnRQaGFzZSIsIm1ldGFLZXkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJ2aWV3IiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiYnV0dG9ucyIsImNsaWVudFgiLCJjbGllbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwb2ludGVySWQiLCJwb2ludGVyVHlwZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwidGFyZ2V0VG91Y2hlcyIsInRvRWxlbWVudCIsInRvdWNoZXMiLCJ3aGljaCIsImZvY3VzIiwiYmx1ciIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwib3JpZyIsInJlbGF0ZWQiLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJjbGVhblNjcmlwdCIsIm1hbmlwdWxhdGlvblRhcmdldCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJ1ZGF0YU9sZCIsInVkYXRhQ3VyIiwiZml4SW5wdXQiLCJkb21NYW5pcCIsImNvbGxlY3Rpb24iLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJ2YWx1ZUlzRnVuY3Rpb24iLCJodG1sIiwiX2V2YWxVcmwiLCJrZWVwRGF0YSIsImNsZWFuRGF0YSIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsInNyY0VsZW1lbnRzIiwiZGVzdEVsZW1lbnRzIiwiaW5QYWdlIiwiZGV0YWNoIiwiYXBwZW5kIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsIm9yaWdpbmFsIiwiaW5zZXJ0Iiwicm51bW5vbnB4IiwiZ2V0U3R5bGVzIiwib3BlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN3YXAiLCJvbGQiLCJyYm94U3R5bGUiLCJjb21wdXRlU3R5bGVUZXN0cyIsImNvbnRhaW5lciIsImNzc1RleHQiLCJkaXZTdHlsZSIsInBpeGVsUG9zaXRpb25WYWwiLCJyZWxpYWJsZU1hcmdpbkxlZnRWYWwiLCJyb3VuZFBpeGVsTWVhc3VyZXMiLCJtYXJnaW5MZWZ0IiwicmlnaHQiLCJwaXhlbEJveFN0eWxlc1ZhbCIsImJveFNpemluZ1JlbGlhYmxlVmFsIiwid2lkdGgiLCJwb3NpdGlvbiIsInNjcm9sbGJveFNpemVWYWwiLCJvZmZzZXRXaWR0aCIsIm1lYXN1cmUiLCJyb3VuZCIsInBhcnNlRmxvYXQiLCJyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCIsImJhY2tncm91bmRDbGlwIiwiY2xlYXJDbG9uZVN0eWxlIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbEJveFN0eWxlcyIsInBpeGVsUG9zaXRpb24iLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJzY3JvbGxib3hTaXplIiwicmVsaWFibGVUckRpbWVuc2lvbnMiLCJ0YWJsZSIsInRyQ2hpbGQiLCJ0clN0eWxlIiwiaGVpZ2h0IiwicGFyc2VJbnQiLCJjdXJDU1MiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJmaW5hbCIsImNzc1Byb3BzIiwicmRpc3BsYXlzd2FwIiwicmN1c3RvbVByb3AiLCJjc3NTaG93IiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0Iiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImJveE1vZGVsQWRqdXN0bWVudCIsImRpbWVuc2lvbiIsImJveCIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiY29tcHV0ZWRWYWwiLCJleHRyYSIsImRlbHRhIiwiY2VpbCIsImdldFdpZHRoT3JIZWlnaHQiLCJib3hTaXppbmdOZWVkZWQiLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0UHJvcCIsImdldENsaWVudFJlY3RzIiwiY3NzSG9va3MiLCJvcGFjaXR5Iiwib3JpZ05hbWUiLCJpc0N1c3RvbVByb3AiLCJzZXRQcm9wZXJ0eSIsImlzRmluaXRlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsYm94U2l6ZUJ1Z2d5IiwibGVmdCIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJydW4iLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInBvcyIsInN0ZXAiLCJmeCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwiaW5Qcm9ncmVzcyIsInJmeHR5cGVzIiwicnJ1biIsInNjaGVkdWxlIiwiaGlkZGVuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW50ZXJ2YWwiLCJ0aWNrIiwiY3JlYXRlRnhOb3ciLCJnZW5GeCIsImluY2x1ZGVXaWR0aCIsImNyZWF0ZVR3ZWVuIiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwidHdlZW5lcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwib3B0cyIsIm9sZGZpcmUiLCJwcm9wVHdlZW4iLCJyZXN0b3JlRGlzcGxheSIsImlzQm94IiwiYW5pbSIsImRhdGFTaG93IiwidW5xdWV1ZWQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInByb3BGaWx0ZXIiLCJzcGVjaWFsRWFzaW5nIiwicHJvcGVydGllcyIsInN0b3BwZWQiLCJwcmVmaWx0ZXJzIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwiYmluZCIsImNvbXBsZXRlIiwidGltZXIiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJzbG93IiwiZmFzdCIsImRlbGF5IiwidGltZSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjaGVja09uIiwib3B0U2VsZWN0ZWQiLCJyYWRpb1ZhbHVlIiwiYm9vbEhvb2siLCJyZW1vdmVBdHRyIiwiblR5cGUiLCJhdHRySG9va3MiLCJib29sIiwiYXR0ck5hbWVzIiwiZ2V0dGVyIiwibG93ZXJjYXNlTmFtZSIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmVtb3ZlUHJvcCIsInByb3BGaXgiLCJ0YWJpbmRleCIsInN0cmlwQW5kQ29sbGFwc2UiLCJnZXRDbGFzcyIsImNsYXNzZXNUb0FycmF5IiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwiY3VyVmFsdWUiLCJjbGF6eiIsImZpbmFsVmFsdWUiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwic3RhdGVWYWwiLCJpc1ZhbGlkVmFsdWUiLCJjbGFzc05hbWVzIiwiaGFzQ2xhc3MiLCJycmV0dXJuIiwidmFsSG9va3MiLCJvcHRpb25TZXQiLCJmb2N1c2luIiwicmZvY3VzTW9ycGgiLCJzdG9wUHJvcGFnYXRpb25DYWxsYmFjayIsIm9ubHlIYW5kbGVycyIsImJ1YmJsZVR5cGUiLCJvbnR5cGUiLCJsYXN0RWxlbWVudCIsImV2ZW50UGF0aCIsInBhcmVudFdpbmRvdyIsInNpbXVsYXRlIiwidHJpZ2dlckhhbmRsZXIiLCJhdHRhY2hlcyIsInJxdWVyeSIsInBhcnNlWE1MIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidHJhZGl0aW9uYWwiLCJwYXJhbSIsInMiLCJ2YWx1ZU9yRnVuY3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInIyMCIsInJoYXNoIiwicmFudGlDYWNoZSIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwidHJhbnNwb3J0cyIsImFsbFR5cGVzIiwib3JpZ2luQW5jaG9yIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZGF0YVR5cGUiLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwidGhyb3dzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwidW5jYWNoZWQiLCJjYWxsYmFja0NvbnRleHQiLCJnbG9iYWxFdmVudENvbnRleHQiLCJjb21wbGV0ZURlZmVycmVkIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhvc3QiLCJoYXNDb250ZW50IiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJiZWZvcmVTZW5kIiwic3VjY2VzcyIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsImZpcnN0RWxlbWVudENoaWxkIiwid3JhcElubmVyIiwiaHRtbElzRnVuY3Rpb24iLCJ1bndyYXAiLCJ2aXNpYmxlIiwib2Zmc2V0SGVpZ2h0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ4aHJTdWNjZXNzU3RhdHVzIiwieGhyU3VwcG9ydGVkIiwiY29ycyIsImVycm9yQ2FsbGJhY2siLCJvcGVuIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwib25hYm9ydCIsIm9udGltZW91dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsImJpbmFyeSIsInNjcmlwdEF0dHJzIiwiY2hhcnNldCIsInNjcmlwdENoYXJzZXQiLCJldnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJrZWVwU2NyaXB0cyIsInBhcnNlZCIsInBhcmFtcyIsImFuaW1hdGVkIiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsInVzaW5nIiwicmVjdCIsIndpbiIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJvZmZzZXRQYXJlbnQiLCJwYXJlbnRPZmZzZXQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwicHJveHkiLCJob2xkUmVhZHkiLCJob2xkIiwicGFyc2VKU09OIiwiaXNOdW1lcmljIiwiaXNOYU4iLCJ0cmltIiwiX2pRdWVyeSIsIl8kIiwiJCIsIm5vQ29uZmxpY3QiLCJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJlcXVpcmUiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJleHBvcnRzIiwiYyIsImQiLCJvIiwiciIsInRvU3RyaW5nVGFnIiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwicHJvcGVydHkiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZXZhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Q0FBQTs7Ozs7Ozs7Ozs7OztDQWFBLENBQUUsVUFBVUEsTUFBVixF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
